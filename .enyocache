[
  {
    "path": "./src/options",
    "base": "/home/udo/git/NCPV/lib/enyo",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/options",
    "name": "enyo/options",
    "isFile": true,
    "contents": "/*jshint node:true */\n'use strict';\n\n/**\n* Returns the global enyo options hash\n* @module enyo/options\n*/\n\nmodule.exports = (global.enyo && global.enyo.options) || {};\n",
    "mtime": 1542469884691,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/options.js",
    "relPath": "enyo/options",
    "requires": [],
    "requests": [],
    "resolved": true
  },
  {
    "path": "enyo",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo",
    "name": "enyo",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/enyo",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/enyo/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/enyo/package.json": 1542469883979,
      "/home/udo/git/NCPV/lib/enyo/index.js": 1542469883979
    },
    "json": {
      "name": "enyo",
      "assets": [],
      "devAssets": [],
      "styles": [
        "css/enyo.css",
        "css/mixins.less"
      ],
      "main": "index.js",
      "moduleDir": "src",
      "filename": "enyo.js",
      "version": "2.7.0",
      "description": "Enyo is an open source object-oriented JavaScript framework emphasizing encapsulation and modularity. Enyo contains everything you need to create a fast, scalable mobile or web application.",
      "homepage": "http://enyojs.com/",
      "bugs": "http://jira.enyojs.com/",
      "keywords": [
        "framework",
        "toolkit",
        "components",
        "mobile",
        "webOS"
      ],
      "maintainers": [
        {
          "name": "Enyo JS Framework Team",
          "web": "http://enyojs.com/"
        }
      ],
      "license": "Apache-2.0",
      "scripts": {
        "test": "./node_modules/.bin/gulp"
      },
      "repository": {
        "type": "git",
        "url": "http://github.com/enyojs/enyo"
      },
      "devDependencies": {
        "chai": "^3.5.0",
        "enyo-dev": "^0.5.2",
        "gulp": "^3.9.0",
        "gulp-concat": "^2.6.0",
        "gulp-jshint": "^2.0.0",
        "gulp-mocha-phantomjs": "^0.10.1",
        "jshint": "^2.9.1",
        "jshint-stylish": "^2.1.0",
        "mocha": "^2.4.4",
        "sinon": "^1.17.3",
        "sinon-chai": "^2.8.0",
        "through2": "^2.0.0"
      }
    },
    "main": "/home/udo/git/NCPV/lib/enyo/index.js",
    "contents": "'use strict';\n\nexports = module.exports = require('./src/options');\nexports.version = '2.7.0';\n",
    "nodeModules": false,
    "relPath": "enyo",
    "requires": [
      "./src/options"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/lib/enyo/css/enyo.css",
      "/home/udo/git/NCPV/lib/enyo/css/mixins.less"
    ],
    "assets": []
  },
  {
    "path": "enyo/ready",
    "base": "/home/udo/git/NCPV",
    "external": true,
    "relName": "enyo/ready",
    "name": "enyo/ready",
    "isFile": true,
    "contents": "require('enyo');\n\n// we need to register appropriately to know when\n// the document is officially ready, to ensure that\n// client code is only going to execute at the\n// appropriate time\n\nvar doc = global.document;\nvar queue = [];\nvar ready = (\"complete\" === doc.readyState);\nvar run;\nvar init;\nvar remove;\nvar add;\nvar flush;\nvar flushScheduled = false;\n\n/**\n* Registers a callback (and optional `this` context) to run after all the Enyo and library code\n* has loaded and the `DOMContentLoaded` event (or equivalent on older browsers) has been sent.\n* \n* If called after the system is in a ready state, runs the supplied code asynchronously at the\n* earliest opportunity.\n*\n* @module enyo/ready\n* @param {Function} fn - The method to execute when the DOM is ready.\n* @param {Object} [context] - The optional context (`this`) under which to execute the\n*\tcallback method.\n* @public\n*/\nmodule.exports = function (fn, context) {\n\tqueue.push([fn, context]);\n\t// schedule another queue flush if needed to run new ready calls\n\tif (ready && !flushScheduled) {\n\t\tsetTimeout(flush, 0);\n\t\tflushScheduled = true;\n\t}\n};\n\n/**\n* @private\n*/\nrun = function (fn, context) {\n\tfn.call(context || global);\n};\n\n/**\n* @private\n*/\ninit = function (event) {\n\t// if we're interactive, it should be safe to move\n\t// forward because the content has been parsed\n\tif ((ready = (\"interactive\" === doc.readyState))) {\n\t\tif (\"DOMContentLoaded\" !== event.type && \"readystatechange\" !== event.type) {\n\t\t\tremove(event.type, init);\n\t\t\tflush();\n\t\t}\n\t}\n\t// for legacy WebKit (including webOS 3.x and less) and assurance\n\tif ((ready = (\"complete\" === doc.readyState || \"loaded\" === doc.readyState))) {\n\t\tremove(event.type, init);\n\t\tflush();\n\t}\n};\n\n/**\n* @private\n*/\nadd = function (event, fn) {\n\tdoc.addEventListener(event, fn, false);\n};\n\n/**\n* @private\n*/\nremove = function (event, fn) {\n\tdoc.removeEventListener(event, fn, false);\n};\n\n/**\n* @private\n*/\nflush = function () {\n\tif (ready && queue.length) {\n\t\twhile (queue.length) {\n\t\t\trun.apply(global, queue.shift());\n\t\t}\n\t}\n\tflushScheduled = false;\n};\n\n// ok, let's hook this up\nadd(\"DOMContentLoaded\", init);\nadd(\"readystatechange\", init);\n",
    "mtime": 1542469884707,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ready.js",
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relPath": "enyo/ready",
    "requires": [
      "enyo"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./json",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/json",
    "name": "enyo/json",
    "isFile": true,
    "contents": "require('enyo');\n\n\n/**\n* [JSON]{@glossary JSON} related methods and wrappers.\n*\n* @module enyo/json\n* @public\n*/\nmodule.exports = {\n\t\n\t/**\n\t* Wrapper for [JSON.stringify()]{@glossary JSON.stringify}. Creates a\n\t* [JSON]{@glossary JSON} [string]{@glossary String} from an\n\t* [object]{@glossary Object}.\n\t*\n\t* @see {@glossary JSON.stringify}\n\t* @param {Object} value - The [object]{@glossary Object} to convert to a\n\t*\t[JSON]{@glossary JSON} [string]{@glossary String}.\n\t* @param {(Function|String[])} [replacer] An optional parameter indicating either an\n\t*\t[array]{@glossary Array} of keys to include in the final output or a\n\t*\t[function]{@glossary Function} that will have the opportunity to dynamically return\n\t*\tvalues to include for keys.\n\t* @param {(Number|String)} [space] - Determines the spacing (if any) for pretty-printed\n\t*\toutput of the JSON string. A [number]{@glossary Number} indicates the number of\n\t* spaces to use in the output, while a string will be used verbatim.\n\t* @returns {String} The JSON string for the given object.\n\t* @public\n\t*/\n\tstringify: function(value, replacer, space) {\n\t\treturn JSON.stringify(value, replacer, space);\n\t},\n\t\n\t/**\n\t* Wrapper for [JSON.parse()]{@glossary JSON.parse}. Parses a valid\n\t* [JSON]{@glossary JSON} [string]{@glossary String} and returns an\n\t* [object]{@glossary Object}, or `null` if the parameters are invalid.\n\t*\n\t* @see {@glossary JSON.parse}\n\t* @param {String} json - The [JSON]{@glossary JSON} [string]{@glossary String} to\n\t*\tparse into an [object]{@glossary Object}.\n\t* @param {Function} [reviver] - The optional [function]{@glossary Function} to use to\n\t*\tparse individual keys of the return object.\n\t* @returns {(Object|null)} If parameters are valid, an [object]{@glossary Object}\n\t* is returned; otherwise, `null`.\n\t* @public\n\t*/\n\tparse: function(json, reviver) {\n\t\treturn json ? JSON.parse(json, reviver) : null;\n\t}\n};\n",
    "mtime": 1542469884671,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/json.js",
    "relPath": "enyo/json",
    "requires": [
      "enyo"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./utils",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/utils",
    "name": "enyo/utils",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* A collection of utilities\n* @module enyo/utils\n*/\n\n/**\n* A polyfill for platforms that don't yet support\n* [bind()]{@glossary Function.prototype.bind}. As explained in the linked article, this\n* polyfill handles the general use case but cannot exactly mirror the ECMA-262 version 5\n* implementation specification. This is an adaptation of the example promoted\n* [here]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind}.\n*/\nif (!Function.prototype.bind) {\n\tFunction.prototype.bind = function (ctx) {\n\t\t// deliberately used here...\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\n\t\t\tscop = this,\n\t\t\tnop = function () {},\n\t\t\tret;\n\n\t\t// as-per MDN's explanation of this polyfill we're filling in for the IsCallable\n\t\t// internal (we can't access it)\n\t\tif (typeof this != 'function') {\n\t\t\tthrow new TypeError('Function.prototype.bind called on non-callable object.');\n\t\t}\n\n\t\tret = function () {\n\t\t\tvar largs = args.concat(Array.prototype.slice.call(arguments)),\n\t\t\t\tlctx = this instanceof nop && ctx ? this : ctx;\n\n\t\t\treturn scop.apply(lctx, largs);\n\t\t};\n\n\t\tnop.prototype = this.prototype;\n\n\t\t/*jshint -W055 */\n\t\tret.prototype = new nop();\n\t\t/*jshint +W055 */\n\n\t\treturn ret;\n\t};\n}\n\n/**\n* Returns a function that can be extended (via `.extend()`) similar to prototypal inheritance.\n* Like {@link module:enyo/kind#inherit}, `extend()` expects as its first argument a factory function\n* that returns the new function that will be called instead of the original function. The original\n* is available as the first argument to that factory function.\n*\n* ```javascript\n* var\n*\tutils = require('enyo/utils');\n*\n* var factor = new utils.Extensible(function (a, b) {\n*\treturn a + b;\n* });\n* factor(2, 4); // returns 6;\n* factor.extend(function (sup) {\n*\treturn function (a, b) {\n*\t\treturn sup.apply(this, arguments) * b;\n*\t};\n* });\n* factor(2, 4) // return 24;\n* ```\n*\n* @param  {Function} fn - Original function that can be extended\n* @param {Object} [ctx] - Context on which `fn` will be called. Defaults to the Extensible instance.\n* @return {Function} - A wrapped version of `fn` with the `extend()` method added\n*\n* @public\n*/\nexports.Extensible = function Extensible (fn) {\n\tif (!(this instanceof Extensible)) return new Extensible(fn);\n\n\tthis.fn = fn;\n\tvar f = function () {\n\t\treturn this.fn.apply(this, arguments);\n\t}.bind(this);\n\n\tf.extend = function (factory) {\n\t\tthis.fn = factory(this.fn);\n\t}.bind(this);\n\n\treturn f;\n};\n\n/**\n* @private\n*/\nexports.nop = function () {};\n\n/**\n* @private\n*/\nexports.nob = {};\n\n/**\n* @private\n*/\nexports.nar = [];\n\n/**\n* This name is reported in inspectors as the type of objects created via delegate;\n* otherwise, we would just use {@link module:enyo/utils#nop}.\n*\n* @private\n*/\nvar Instance = exports.instance = function () {};\n\n/**\n* @private\n*/\nvar setPrototype = exports.setPrototype = function (ctor, proto) {\n\tctor.prototype = proto;\n};\n\n/**\n* Boodman/crockford delegation w/cornford optimization\n*\n* @private\n*/\nexports.delegate = function (proto) {\n\tsetPrototype(Instance, proto);\n\treturn new Instance();\n};\n\n// ----------------------------------\n// General Functions\n// ----------------------------------\n\n/**\n* Determines whether a variable is defined.\n*\n* @param {*} target - Anything that can be compared to `undefined`.\n* @returns {Boolean} `true` if defined, `false` otherwise.\n* @public\n*/\nvar exists = exports.exists = function (target) {\n\treturn (target !== undefined);\n};\n\nvar uidCounter = 0;\n\n/**\n* Creates a unique identifier (with an optional prefix) and returns the identifier as a string.\n*\n* @param {String} [prefix] - The prefix to prepend to the generated unique id.\n* @returns {String} An optionally-prefixed identifier.\n* @public\n*/\nexports.uid = function (prefix) {\n\treturn String((prefix? prefix: '') + uidCounter++);\n};\n\n/**\n* RFC4122 uuid generator for the browser.\n*\n* @returns {String} An [RFC4122]{@glossary UUID}-compliant, universally unique identifier.\n* @public\n*/\nexports.uuid = function () {\n\t// @TODO: Could possibly be faster\n\tvar t, p = (\n\t\t(Math.random().toString(16).substr(2,8)) + '-' +\n\t\t((t=Math.random().toString(16).substr(2,8)).substr(0,4)) + '-' +\n\t\t(t.substr(4,4)) +\n\t\t((t=Math.random().toString(16).substr(2,8)).substr(0,4)) + '-' +\n\t\t(t.substr(4,4)) +\n\t\t(Math.random().toString(16).substr(2,8))\n\t);\n\treturn p;\n};\n\n/**\n* Generates a random number using [Math.random]{@glossary Math.random}.\n*\n* @param {Number} bound - The multiplier used to generate the product.\n* @returns {Number} A random number.\n* @public\n*/\nexports.irand = function (bound) {\n\treturn Math.floor(Math.random() * bound);\n};\n\nvar toString = Object.prototype.toString;\n\n/**\n* Determines whether a given variable is a [String]{@glossary String}.\n*\n* @param {*} it - The variable to be tested.\n* @returns {Boolean} `true` if variable is a [String]{@glossary String};\n* otherwise, `false`.\n* @public\n*/\nexports.isString = function (it) {\n\treturn toString.call(it) === '[object String]';\n};\n\n/**\n* Determines whether a given variable is a [Function]{@glossary Function}.\n*\n* @param {*} it - The variable to be tested.\n* @returns {Boolean} `true` if variable is a [Function]{@glossary Function};\n* otherwise, `false`.\n* @public\n*/\nexports.isFunction = function (it) {\n\treturn toString.call(it) === '[object Function]';\n};\n\n/**\n* Determines whether a given variable is an [Array]{@glossary Array}.\n*\n* @param {*} it - The variable to be tested.\n* @returns {Boolean} `true` if variable is an [Array]{@glossary Array};\n* otherwise, `false`.\n* @method\n* @public\n*/\nvar isArray = exports.isArray = Array.isArray || function (it) {\n\treturn toString.call(it) === '[object Array]';\n};\n\n/**\n* Determines whether a given variable is an [Object]{@glossary Object}.\n*\n* @param {*} it - The variable to be tested.\n* @returns {Boolean} `true` if variable is an [Object]{@glossary Object};\n* otherwise, `false`.\n* @method\n* @public\n*/\nexports.isObject = Object.isObject || function (it) {\n\treturn toString.call(it) === '[object Object]';\n};\n\n/**\n* Determines whether a given variable is an explicit boolean `true`.\n*\n* @param {*} it - The variable to be tested.\n* @returns {Boolean} `true` if variable is an explicit `true`; otherwise,\n* `false`.\n* @public\n*/\nexports.isTrue = function (it) {\n\treturn !(it === 'false' || it === false || it === 0 || it === null || it === undefined);\n};\n\n/**\n* Determines whether a given variable is a numeric value.\n*\n* @param {*} it - The variable to be tested.\n* @returns {Boolean} `true` if variable is a numeric value; otherwise,\n* `false`.\n* @public\n*/\nexports.isNumeric = function (it) {\n\t// borrowed from jQuery\n\treturn !isArray(it) && (it - parseFloat(it) + 1) >= 0;\n};\n\n/**\n* Binds the `this` context of any method to a scope and a variable number of provided initial\n* parameters.\n*\n* @param {Object} scope - The `this` context for the method.\n* @param {(Function|String)} method - A Function or the name of a method to bind.\n* @param {...*} [args] Any arguments that will be provided as the initial arguments to the\n*                      enclosed method.\n* @returns {Function} The bound method/closure.\n* @public\n*/\nvar bind = exports.bind = function (scope, method) {\n\tif (!method) {\n\t\tmethod = scope;\n\t\tscope = null;\n\t}\n\tscope = scope || global;\n\tif (typeof method == 'string') {\n\t\tif (scope[method]) {\n\t\t\tmethod = scope[method];\n\t\t} else {\n\t\t\tthrow('enyo.bind: scope[\"' + method + '\"] is null (scope=\"' + scope + '\")');\n\t\t}\n\t}\n\tif (typeof method == 'function') {\n\t\tvar args = cloneArray(arguments, 2);\n\t\tif (method.bind) {\n\t\t\treturn method.bind.apply(method, [scope].concat(args));\n\t\t} else {\n\t\t\treturn function() {\n\t\t\t\tvar nargs = cloneArray(arguments);\n\t\t\t\t// invoke with collected args\n\t\t\t\treturn method.apply(scope, args.concat(nargs));\n\t\t\t};\n\t\t}\n\t} else {\n\t\tthrow('enyo.bind: scope[\"' + method + '\"] is not a function (scope=\"' + scope + '\")');\n\t}\n};\n\n/**\n* Binds a callback to a scope. If the object has a `destroyed` property that's truthy, then the\n* callback will not be run if called. This can be used to implement both\n* {@link module:enyo/CoreObject~Object#bindSafely} and {@link module:enyo/CoreObject~Object}-like objects like\n* {@link module:enyo/Model~Model} and {@link module:enyo/Collection~Collection}.\n*\n* @param {Object} scope - The `this` context for the method.\n* @param {(Function|String)} method - A Function or the name of a method to bind.\n* @param {...*} [args] Any arguments that will be provided as the initial arguments to the\n*                      enclosed method.\n* @returns {Function} The bound method/closure.\n* @public\n*/\nexports.bindSafely = function (scope, method) {\n\tif (typeof method == 'string') {\n\t\tif (scope[method]) {\n\t\t\tmethod = scope[method];\n\t\t} else {\n\t\t\tthrow('enyo.bindSafely: scope[\"' + method + '\"] is null (this=\"' + this + '\")');\n\t\t}\n\t}\n\tif (typeof method == 'function') {\n\t\tvar args = cloneArray(arguments, 2);\n\t\treturn function() {\n\t\t\tif (scope.destroyed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar nargs = cloneArray(arguments);\n\t\t\treturn method.apply(scope, args.concat(nargs));\n\t\t};\n\t} else {\n\t\tthrow('enyo.bindSafely: scope[\"' + method + '\"] is not a function (this=\"' + this + '\")');\n\t}\n};\n\n/**\n* Calls the provided `method` on `scope`, asynchronously.\n*\n* Uses [window.setTimeout()]{@glossary window.setTimeout} with minimum delay,\n* usually around 10ms.\n*\n* Additional arguments are passed to `method` when it is invoked.\n*\n* If only a single argument is supplied, will just call that function asynchronously without\n* doing any additional binding.\n*\n* @param {Object} scope - The `this` context for the method.\n* @param {(Function|String)} method - A Function or the name of a method to bind.\n* @param {...*} [args] Any arguments that will be provided as the initial arguments to the\n*                      enclosed method.\n* @returns {Number} The `setTimeout` id.\n* @public\n*/\nexports.asyncMethod = function (scope, method) {\n\tif (!method) {\n\t\t// passed just a single argument\n\t\treturn setTimeout(scope, 1);\n\t} else {\n\t\treturn setTimeout(bind.apply(scope, arguments), 1);\n\t}\n};\n\n/**\n* Calls the provided `method` ([String]{@glossary String}) on `scope` with optional\n* arguments `args` ([Array]{@glossary Array}), if the object and method exist.\n*\n* @example\n* \tutils = require('enyo/utils');\n* \tutils.call(myWorkObject, 'doWork', [3, 'foo']);\n*\n* @param {Object} scope - The `this` context for the method.\n* @param {(Function|String)} method - A Function or the name of a method to bind.\n* @param {Array} [args] - An array of arguments to pass to the method.\n* @returns {*} The return value of the method.\n* @public\n*/\nexports.call = function (scope, method, args) {\n\tvar context = scope || this;\n\tif (method) {\n\t\tvar fn = context[method] || method;\n\t\tif (fn && fn.apply) {\n\t\t\treturn fn.apply(context, args || []);\n\t\t}\n\t}\n};\n\n/**\n* Returns the current time in milliseconds. On platforms that support it,\n* [Date.now()]{@glossary Date.now} will be used; otherwise this will\n* be equivalent to [new Date().getTime()]{@glossary Date.getTime}.\n*\n* @returns {Number} Number of milliseconds representing the current time.\n* @method\n* @public\n*/\n\nvar now = exports.now = Date.now || function () {\n\treturn new Date().getTime();\n};\n\n/**\n* When [window.performance]{@glossary window.performance} is available, supplies\n* a high-precision, high-performance monotonic timestamp, which is independent of\n* changes to the system clock and thus safer for use in animation, etc. Falls back to\n* {@link module:enyo/utils#now} (based on the JavaScript [Date]{@glossary Date} object),\n* which is subject to system time changes.\n*\n* @returns {Number} Number of milliseconds representing the current time or time since\n*                   start of application execution as reported by the platform.\n* @method\n* @public\n*/\nexports.perfNow = (function () {\n\t// we have to check whether or not the browser has supplied a valid\n\t// method to use\n\tvar perf = window.performance || {};\n\t// test against all known vendor-specific implementations, but use\n\t// a fallback just in case\n\tperf.now = perf.now || perf.mozNow || perf.msNow || perf.oNow || perf.webkitNow || now;\n\treturn function () {\n\t\treturn perf.now();\n\t};\n}());\n\n/**\n* A fast-path enabled global getter that takes a string path, which may be a full path (from\n* context window/Enyo) or a relative path (to the execution context of the method). It knows how\n* to check for and call the backwards-compatible generated getters, as well as how to handle\n* computed properties. Returns `undefined` if the object at the given path cannot be found. May\n* safely be called on non-existent paths.\n*\n* @param {String} path - The path from which to retrieve a value.\n* @returns {*} The value for the given path, or `undefined` if the path could not be\n*                  completely resolved.\n* @method enyo.getPath\n* @public\n*/\nvar getPath = exports.getPath = function (path) {\n\t// we're trying to catch only null/undefined not empty string or 0 cases\n\tif (!path && path !== null && path !== undefined) return path;\n\n\tvar next = this,\n\t\tparts,\n\t\tpart,\n\t\tgetter,\n\t\tprev;\n\n\t// obviously there is a severe penalty for requesting get with a path lead\n\t// by unnecessary relative notation...\n\tif (path[0] == '.') path = path.replace(/^\\.+/, '');\n\n\t// here's where we check to make sure we have a truthy string-ish\n\tif (!path) return;\n\n\tparts = path.split('.');\n\tpart = parts.shift();\n\n\tdo {\n\t\tprev = next;\n\t\t// for constructors we must check to make sure they are undeferred before\n\t\t// looking for static properties\n\t\t// for the auto generated or provided published property support we have separate\n\t\t// routines that must be called to preserve compatibility\n\t\tif (next._getters && ((getter = next._getters[part])) && !getter.generated) next = next[getter]();\n\t\t// for all other special cases to ensure we use any overloaded getter methods\n\t\telse if (next.get && next !== this && next.get !== getPath) next = next.get(part);\n\t\t// and for regular cases\n\t\telse next = next[part];\n\t} while (next && (part = parts.shift()));\n\n\t// if necessary we ensure we've undeferred any constructor that we're\n\t// retrieving here as a final property as well\n\treturn next;\n};\n\n/**\n* @private\n*/\ngetPath.fast = function (path) {\n\t// the current context\n\tvar b = this, fn, v;\n\tif (b._getters && (fn = b._getters[path])) {\n\t\tv = b[fn]();\n\t} else {\n\t\tv = b[path];\n\t}\n\n\treturn v;\n};\n\n/**\n* @TODO: Out of date...\n* A global setter that takes a string path (relative to the method's execution context) or a\n* full path (relative to window). Attempts to automatically retrieve any previously existing\n* value to supply to any observers. If the context is an {@link module:enyo/CoreObject~Object} or subkind, the\n* {@link module:enyo/ObserverSupport~ObserverSupport.notify} method is used to notify listeners for the path's being\n* set. If the previous value is equivalent to the newly set value, observers will not be\n* triggered by default. If the third parameter is present and is an explicit boolean true, the\n* observers will be triggered regardless. Returns the context from which the method was executed.\n*\n* @param {String} path - The path for which to set the given value.\n* @param {*} is - The value to set.\n* @param {Object} [opts] - An options hash.\n* @returns {this} Whatever the given context was when executed.\n* @method enyo.setPath\n* @public\n*/\nvar setPath = exports.setPath = function (path, is, opts) {\n\t// we're trying to catch only null/undefined not empty string or 0 cases\n\tif (!path || (!path && path !== null && path !== undefined)) return this;\n\n\tvar next = this,\n\t\toptions = {create: true, silent: false, force: false},\n\t\tbase = next,\n\t\tparts,\n\t\tpart,\n\t\twas,\n\t\tforce,\n\t\tcreate,\n\t\tsilent,\n\t\tcomparator;\n\n\tif (typeof opts == 'object') opts = mixin({}, [options, opts]);\n\telse {\n\t\tforce = opts;\n\t\topts = options;\n\t}\n\n\tif (opts.force) force = true;\n\tsilent = opts.silent;\n\tcreate = opts.create;\n\tcomparator = opts.comparator;\n\n\n\t// obviously there is a severe penalty for requesting get with a path lead\n\t// by unnecessary relative notation...\n\tif (path[0] == '.') path = path.replace(/^\\.+/, '');\n\n\t// here's where we check to make sure we have a truthy string-ish\n\tif (!path) return next;\n\n\tparts = path.split('.');\n\tpart = parts.shift();\n\n\tdo {\n\n\t\tif (!parts.length) was = next.get && next.get !== getPath? next.get(part): next[part];\n\t\telse {\n\t\t\t// this allows us to ensure that if we're setting a static property of a constructor we have the\n\t\t\t// correct constructor\n\t\t\t// @TODO: It seems ludicrous to have to check this on every single part of a chain; if we didn't have\n\t\t\t// deferred constructors this wouldn't be necessary and is expensive - unnecessarily so when speed is so important\n\t\t\tif (next !== base && next.set && next.set !== setPath) {\n\t\t\t\tparts.unshift(part);\n\t\t\t\tnext.set(parts.join('.'), is, opts);\n\t\t\t\treturn base;\n\t\t\t}\n\t\t\tif (next !== base && next.get) next = (next.get !== getPath? next.get(part): next[part]) || (create && (next[part] = {}));\n\t\t\telse next = next[part] || (create && (next[part] = {}));\n\t\t}\n\n\t} while (next && parts.length && (part = parts.shift()));\n\n\tif (!next) return base;\n\n\t// now update to the new value\n\tif (next !== base && next.set && next.set !== setPath) {\n\t\tnext.set(part, is, opts);\n\t\treturn base;\n\t} else next[part] = is;\n\n\t// if possible we notify the changes but this change is notified from the immediate\n\t// parent not the root object (could be the same)\n\tif (next.notify && !silent && (force || was !== is || (comparator && comparator(was, is)))) next.notify(part, was, is, opts);\n\t// we will always return the original root-object of the call\n\treturn base;\n};\n\n/**\n* @private\n*/\nsetPath.fast = function (path, value) {\n\t// the current context\n\tvar b = this,\n\t\t// the previous value and helper variable\n\t\trv, fn;\n\t// we have to check and ensure that we're not setting a computed property\n\t// and if we are, do nothing\n\tif (b._computed && b._computed[path] !== undefined) {\n\t\treturn b;\n\t}\n\tif (b._getters && (fn=b._getters[path])) {\n\t\trv = b[fn]();\n\t} else {\n\t\trv = b[path];\n\t}\n\t// set the new value now that we can\n\tb[path] = value;\n\n\t// this method is only ever called from the context of enyo objects\n\t// as a protected method\n\tif (rv !== value) { b.notifyObservers(path, rv, value); }\n\t// return the context\n\treturn b;\n};\n\n// ----------------------------------\n// String Functions\n// ----------------------------------\n\n/**\n* Uppercases a given string. Will coerce to a [String]{@glossary String}\n* if possible/necessary.\n*\n* @param {String} str - The string to uppercase.\n* @returns {String} The uppercased string.\n* @public\n*/\nexports.toUpperCase = new exports.Extensible(function (str) {\n\tif (str != null) {\n\t\treturn str.toString().toUpperCase();\n\t}\n\treturn str;\n});\n\n/**\n* Lowercases a given string. Will coerce to a [String]{@glossary String}\n* if possible/necessary.\n*\n* @param {String} str - The string to lowercase.\n* @returns {String} The lowercased string.\n* @public\n*/\nexports.toLowerCase = new exports.Extensible(function (str) {\n\tif (str != null) {\n\t\treturn str.toString().toLowerCase();\n\t}\n\treturn str;\n});\n\n/**\n* Capitalizes a given string.\n*\n* @param {String} str - The string to capitalize.\n* @returns {String} The capitalized string.\n* @public\n*/\nexports.cap = function (str) {\n\treturn str.slice(0, 1).toUpperCase() + str.slice(1);\n};\n\n/**\n* Un-capitalizes a given string.\n*\n* @param {String} str - The string to un-capitalize.\n* @returns {String} The un-capitalized string.\n* @public\n*/\nexports.uncap = function (str) {\n\treturn str.slice(0, 1).toLowerCase() + str.slice(1);\n};\n\n/**\n* Injects an arbitrary number of values, in order, into a template string at\n* positions marked by `\"%.\"`.\n*\n* @param {String} template - The string template to inject with values.\n* @param {...String} val The values to inject into the template.\n* @returns {String} A copy of the template populated with values.\n* @public\n*/\nexports.format = function (template) {\n\tvar pattern = /\\%./g,\n\t\targ = 0,\n\t\ttmp = template,\n\t\targs = arguments,\n\t\treplacer;\n\n\treplacer = function () {\n\t\treturn args[++arg];\n\t};\n\n\treturn tmp.replace(pattern, replacer);\n};\n\n/**\n* @private\n*/\nString.prototype.trim = String.prototype.trim || function () {\n\treturn this.replace(/^\\s+|\\s+$/g, '');\n};\n\n/**\n* Takes a string and trims leading and trailing spaces. Strings with no length,\n* non-strings, and falsy values will be returned without modification.\n*\n* @param {String} str - The string from which to remove whitespace.\n* @returns {String} The trimmed string.\n* @public\n*/\nexports.trim = function (str) {\n\treturn (typeof str == 'string' && str.trim()) || str;\n};\n\n// ----------------------------------\n// Object Functions\n// ----------------------------------\n\n/**\n* A [polyfill]{@glossary polyfill} for platforms that don't support\n* [Object.create()]{@glossary Object.create}.\n*/\nObject.create = Object.create || (function () {\n\tvar Anon = function () {};\n\treturn function (obj) {\n\t\t// in the polyfill we can't support the additional features so we are ignoring\n\t\t// the extra parameters\n\t\tif (!obj || obj === null || typeof obj != 'object') throw 'Object.create: Invalid parameter';\n\t\tAnon.prototype = obj;\n\t\treturn new Anon();\n\t};\n})();\n\n/**\n* A [polyfill]{@glossary polyfill} for platforms that don't support\n* [Object.keys()]{@glossary Object.keys}.\n*/\nObject.keys = Object.keys || function (obj) {\n\tvar results = [];\n\tvar hop = Object.prototype.hasOwnProperty;\n\tfor (var prop in obj) {\n\t\tif (hop.call(obj, prop)) {\n\t\t\tresults.push(prop);\n\t\t}\n\t}\n\treturn results;\n};\n\n/**\n* Returns an array of all known enumerable properties found on a given object.\n*\n* @alias Object.keys.\n* @method enyo.keys\n* @public\n*/\nexports.keys = Object.keys;\n\n/**\n* Convenience method that takes an [array]{@glossary Array} of properties\n* and an [object]{@glossary Object} as parameters. Returns a new object\n* with only those properties named in the array that are found to exist on the\n* base object. If the third parameter is `true`, falsy values will be ignored.\n*\n* @param {String[]} properties The properties to include on the returned object.\n* @param {Object} object - The object from which to retrieve values for the requested properties.\n* @param {Boolean} [ignore=false] Whether or not to ignore copying falsy values.\n* @returns {Object} A new object populated with the requested properties and values from\n*                     the given object.\n* @public\n*/\nexports.only = function (properties, object, ignore) {\n\tvar ret = {},\n\t\tprop,\n\t\tlen,\n\t\ti;\n\n\tfor (i = 0, len = properties.length >>> 0; i < len; ++i) {\n\t\tprop = properties[i];\n\n\t\tif (ignore && (object[prop] === undefined || object[prop] === null)) continue;\n\t\tret[prop] = object[prop];\n\t}\n\n\treturn ret;\n};\n\n/**\n* Convenience method that takes two [objects]{@glossary Object} as parameters.\n* For each key from the first object, if the key also exists in the second object,\n* a mapping of the key from the first object to the key from the second object is\n* added to a result object, which is eventually returned. In other words, the\n* returned object maps the named properties of the first object to the named\n* properties of the second object. The optional third parameter is a boolean\n* designating whether to pass unknown key/value pairs through to the new object.\n* If `true`, those keys will exist on the returned object.\n*\n* @param {Object} map - The object with key/value pairs.\n* @param {Object} obj - The object whose values will be used.\n* @param {Boolean} [pass=false] Whether or not to pass unnamed properties through\n*                               from the given object.\n* @returns {Object} A new object whose properties have been mapped.\n* @public\n*/\nexports.remap = function (map, obj, pass) {\n\tvar ret = pass ? clone(obj) : {},\n\t\tkey;\n\n\tfor (key in map) {\n\t\tif (key in obj) ret[map[key]] = obj.get ? obj.get(key) : obj[key];\n\t}\n\treturn ret;\n};\n\n/**\n* Helper method that accepts an [array]{@glossary Array} of\n* [objects]{@glossary Object} and returns a hash of those objects indexed\n* by the specified `property`. If a `filter` is provided, the filter should\n* accept four parameters: the key, the value (object), the current mutable map\n* reference, and an immutable copy of the original array of objects for\n* comparison.\n*\n* @param {String} property - The property to index the array by.\n* @param {Array} array - An array of property objects.\n* @param {Function} [filter] - The filter function to use; accepts four arguments.\n* @returns {Object} A hash (object) indexed by the `property` argument\n* @public\n*/\nexports.indexBy = function (property, array, filter) {\n\t// the return value - indexed map from the given array\n\tvar map = {},\n\t\tvalue,\n\t\tlen,\n\t\tidx = 0;\n\t// sanity check for the array with an efficient native array check\n\tif (!exists(array) || !(array instanceof Array)) {\n\t\treturn map;\n\t}\n\t// sanity check the property as a string\n\tif (!exists(property) || 'string' !== typeof property) {\n\t\treturn map;\n\t}\n\t// the immutable copy of the array\n\tvar copy = clone(array);\n\t// test to see if filter actually exsits\n\tfilter = exists(filter) && 'function' === typeof filter ? filter : undefined;\n\tfor (len = array.length; idx < len; ++idx) {\n\t\t// grab the value from the array\n\t\tvalue = array[idx];\n\t\t// make sure that it exists and has the requested property at all\n\t\tif (exists(value) && exists(value[property])) {\n\t\t\tif (filter) {\n\t\t\t\t// if there was a filter use it - it is responsible for\n\t\t\t\t// updating the map accordingly\n\t\t\t\tfilter(property, value, map, copy);\n\t\t\t} else {\n\t\t\t\t// use the default behavior - check to see if the key\n\t\t\t\t// already exists on the map it will be overwritten\n\t\t\t\tmap[value[property]] = value;\n\t\t\t}\n\t\t}\n\t}\n\t// go ahead and return our modified map\n\treturn map;\n};\n\n/**\n* Creates and returns a shallow copy of an [Object]{@glossary Object} or an\n* [Array]{@glossary Array}. For objects, by default, properties will be scanned and\n* copied directly to the clone such that they would pass the\n* [hasOwnProperty()]{@glossary Object.hasOwnProperty} test. This is expensive and often not\n* required. In this case, the optional second parameter may be used to allow a more efficient\n* [copy]{@link Object.create} to be made.\n*\n* @param {(Object|Array)} base - The [Object]{@glossary Object} or\n*                              [Array]{@glossary Array} to be cloned.\n* @param {Boolean} [quick] - If `true`, when cloning objects, a faster [copy]{@link Object.create}\n*                          method will be used. This parameter has no meaning when cloning arrays.\n* @returns {*} A clone of the provided `base` if `base` is of the correct type; otherwise,\n*              returns `base` as it was passed in.\n* @public\n*/\nvar clone = exports.clone = function (base, quick) {\n\tif (base) {\n\n\t\t// avoid the overhead of calling yet another internal function to do type-checking\n\t\t// just copy the array and be done with it\n\t\tif (base instanceof Array) return base.slice();\n\t\telse if (base instanceof Object) {\n\t\t\treturn quick ? Object.create(base) : mixin({}, base);\n\t\t}\n\t}\n\n\t// we will only do this if it is not an array or native object\n\treturn base;\n};\n\nvar empty = {};\nvar mixinDefaults = {\n\texists: false,\n\tignore: false,\n\tfilter: null\n};\n\n/**\n\t@todo Rewrite with appropriate documentation for options parameter (typedef)\n\t@todo document 'quick' option\n\n\tWill take a variety of options to ultimately mix a set of properties\n\tfrom objects into single object. All configurations accept a boolean as\n\tthe final parameter to indicate whether or not to ignore _truthy_/_existing_\n\tvalues on any _objects_ prior.\n\n\tIf _target_ exists and is an object, it will be the base for all properties\n\tand the returned value. If the parameter is used but is _falsy_, a new\n\tobject will be created and returned. If no such parameter exists, the first\n\tparameter must be an array of objects and a new object will be created as\n\tthe _target_.\n\n\tThe _source_ parameter may be an object or an array of objects. If no\n\t_target_ parameter is provided, _source_ must be an array of objects.\n\n\tThe _options_ parameter allows you to set the _ignore_ and/or _exists_ flags\n\tsuch that if _ignore_ is true, it will not override any truthy values in the\n\ttarget, and if _exists_ is true, it will only use truthy values from any of\n\tthe sources. You may optionally add a _filter_ method-option that returns a\n\ttrue or false value to indicate whether the value should be used. It receives\n\tparameters in this order: _property_, _source value_, _source values_,\n\t_target_, _options_. Note that modifying the target in the filter method can\n\thave unexpected results.\n\n\tSetting _options_ to true will set all options to true.\n\n* @method enyo.mixin\n* @public\n*/\nvar mixin = exports.mixin = function () {\n\tvar ret = arguments[0],\n\t\tsrc = arguments[1],\n\t\topts = arguments[2],\n\t\tval;\n\n\tif (!ret) ret = {};\n\telse if (ret instanceof Array) {\n\t\topts = src;\n\t\tsrc = ret;\n\t\tret = {};\n\t}\n\n\tif (!opts || opts === true) opts = mixinDefaults;\n\n\tif (src instanceof Array) for (var i=0, it; (it=src[i]); ++i) mixin(ret, it, opts);\n\telse {\n\t\tfor (var key in src) {\n\t\t\tval = src[key];\n\n\t\t\t// quickly ensure the property isn't a default\n\t\t\tif (empty[key] !== val) {\n\t\t\t\tif (\n\t\t\t\t\t(!opts.exists || val) &&\n\t\t\t\t\t(!opts.ignore || !ret[key]) &&\n\t\t\t\t\t(opts.filter? opts.filter(key, val, src, ret, opts): true)\n\t\t\t\t) {\n\t\t\t\t\tret[key] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n};\n\n/**\n* Returns an [array]{@glossary Array} of the values of all properties in an\n* [object]{@glossary Object}.\n*\n* @param {Object} obj - The [Object]{@glossary Object} to read the values from.\n* @returns {Array} An [array]{@glossary Array} with the values from the `obj`.\n* @public\n*/\nexports.values = function (obj) {\n\tvar ret = [];\n\tfor (var key in obj) {\n\t\tif (obj.hasOwnProperty(key)) ret.push(obj[key]);\n\t}\n\treturn ret;\n};\n\n// ----------------------------------\n// Array Functions\n// ----------------------------------\n\n/**\n* A [polyfill]{@glossary polyfill} for platforms that don't support\n* [Array.findIndex()]{@glossary Array.findIndex}.\n*/\nArray.prototype.findIndex = Array.prototype.findIndex || function (fn, ctx) {\n\tfor (var i=0, len=this.length >>> 0; i<len; ++i) {\n\t\tif (fn.call(ctx, this[i], i, this)) return i;\n\t}\n\treturn -1;\n};\n\n/**\n* A [polyfill]{@glossary polyfill} for platforms that don't support\n* [Array.find()]{@glossary Array.find}.\n*/\nArray.prototype.find = Array.prototype.find || function (fn, ctx) {\n\tfor (var i=0, len=this.length >>> 0; i<len; ++i) {\n\t\tif (fn.call(ctx, this[i], i, this)) return this[i];\n\t}\n};\n\n/**\n* An Enyo convenience method reference to [Array.indexOf()]{@glossary Array.indexOf}.\n*\n* This also supports the legacy Enyo argument order `el.indexOf(array, offset)` and can\n* differentiate between this and the standard `array.indexOf(el, offset)`.\n*\n* **When possible, you should use the native equivalent.**\n*\n* This method supports the same arguments as the native version, plus an extra argument at the\n* beginning referring to the [array]{@glossary Array} to run this method on.\n*\n* @public\n*/\nexports.indexOf = function (array, el, offset) {\n\tif (!(array instanceof Array)) return el.indexOf(array, offset);\n\treturn array.indexOf(el, offset);\n};\n\n/**\n* An Enyo convenience method reference to [Array.lastIndexOf()]{@glossary Array.lastIndexOf}.\n*\n* This also supports the legacy Enyo argument order `el.lastIndexOf(array, offset)` and can\n* differentiate between this and the standard `array.lastIndexOf(el, offset)`.\n*\n* **When possible, you should use the native equivalent.**\n*\n* This method supports the same arguments as the native version, plus an extra argument at the\n* beginning referring to the [array]{@glossary Array} to run this method on.\n*\n* @public\n*/\nexports.lastIndexOf = function (array, el, offset) {\n\tif (!(array instanceof Array)) return el.lastIndexOf(array, offset);\n\treturn array.lastIndexOf(el, offset);\n};\n\n/**\n* An Enyo convenience method reference to [Array.findIndex()]{@glossary Array.findIndex}.\n*\n* **When possible, you should use the native equivalent.**\n*\n* This method supports the same arguments as the native version, plus an extra argument at the\n* beginning referring to the [array]{@glossary Array} to run this method on.\n*\n* @public\n*/\nexports.findIndex = function (array, fn, ctx) {\n\treturn array.findIndex(fn, ctx);\n};\n\n/**\n* An Enyo convenience method reference to [Array.find()]{@glossary Array.find}.\n*\n* **When possible, you should use the native equivalent.**\n*\n* This method supports the same arguments as the native version, plus an extra argument at the\n* beginning referring to the [array]{@glossary Array} to run this method on.\n*\n* @method enyo.find\n* @public\n*/\nvar find = exports.find = function (array, fn, ctx) {\n\treturn array.find(fn, ctx);\n};\n\n/**\n* @alias enyo.find\n* @method enyo.where\n* @public\n*/\nexports.where = find;\n\n/**\n* An Enyo convenience method reference to [Array.forEach()]{@glossary Array.forEach}.\n*\n* **When possible, you should use the native equivalent.**\n*\n* This method supports the same arguments as the native version, plus an extra argument at the\n* beginning referring to the [array]{@glossary Array} to run this method on.\n*\n* @public\n*/\nexports.forEach = function (array, fn, ctx) {\n\treturn array.forEach(fn, ctx);\n};\n\n/**\n* An Enyo convenience method reference to [Array.map()]{@glossary Array.map}.\n*\n* **When possible, you should use the native equivalent.**\n*\n* This method supports the same arguments as the native version, plus an extra argument at the\n* beginning referring to the [array]{@glossary Array} to run this method on.\n*\n* @public\n*/\nexports.map = function (array, fn, ctx) {\n\treturn array.map(fn, ctx);\n};\n\n/**\n* An Enyo convenience method reference to [Array.filter()]{@glossary Array.filter}.\n*\n* **When possible, you should use the native equivalent.**\n*\n* This method supports the same arguments as the native version, plus an extra argument at the\n* beginning referring to the [array]{@glossary Array} to run this method on.\n*\n* @public\n*/\nexports.filter = function (array, fn, ctx) {\n\treturn array.filter(fn, ctx);\n};\n\n/**\n* When given an [array]{@glossary Array} of [objects]{@glossary Object},\n* searches through the array's objects; each object with a property name matching\n* `prop` has its value for that property compiled into a result array, which is\n* eventually returned. For each array object that doesn't have a matching property,\n* an `undefined` placeholder element is added to the result array, such that the\n* returned result array has the same length as the passed-in `array` parameter.\n*\n* @param {Array} array - The [array]{@glossary Array} of [objects]{@glossary Object}\n*                      in which the `prop` will be searched for.\n* @param {String} prop - A string containing the name of the property to search for.\n* @returns {Array} An array of all the values of the named property from\n*                     objects contained in the `array`.\n* @public\n*/\nexports.pluck = function (array, prop) {\n\tif (!(array instanceof Array)) {\n\t\tvar tmp = array;\n\t\tarray = prop;\n\t\tprop = tmp;\n\t}\n\n\tvar ret = [];\n\tfor (var i=0, len=array.length >>> 0; i<len; ++i) {\n\t\tret.push(array[i]? array[i][prop]: undefined);\n\t}\n\treturn ret;\n};\n\n/**\n* Concatenates a variable number of [arrays]{@glossary Array}, removing any duplicate\n* entries.\n*\n* @returns {Array} The unique values from all [arrays]{@glossary Array}.\n* @public\n*/\nexports.merge = function (/* _arrays_ */) {\n\tvar ret = [],\n\t\tvalues = Array.prototype.concat.apply([], arguments);\n\tfor (var i=0, len=values.length >>> 0; i<len; ++i) {\n\t\tif (!~ret.indexOf(values[i])) ret.push(values[i]);\n\t}\n\treturn ret;\n};\n\n/**\n* Clones an existing [Array]{@glossary Array}, or converts an array-like\n* object into an Array.\n*\n* If `offset` is non-zero, the cloning starts from that index in the source\n* Array. The clone may be appended to an existing Array by passing in the\n* existing Array as `initialArray`.\n*\n* Array-like objects have `length` properties, and support square-bracket\n* notation `([])`. Array-like objects often do not support Array methods\n* such as `push()` or `concat()`, and so must be converted to Arrays before\n* use.\n*\n* The special `arguments` variable is an example of an array-like object.\n*\n* @public\n*/\nvar cloneArray = exports.cloneArray = function (array, offset, initialArray) {\n\tvar ret = initialArray || [];\n\tfor(var i = offset || 0, l = array.length; i<l; i++){\n\t\tret.push(array[i]);\n\t}\n\t// Alternate smarter implementation:\n\t// return Array.prototype.slice.call(array, offset);\n\t// Array.of\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of\n\treturn ret;\n};\n\n/**\n* @alias cloneArray\n* @method enyo.toArray\n* @public\n*/\nexports.toArray = cloneArray;\n\n/**\n* Within a given [array]{@glossary Array}, removes the first\n* [strictly equal to]{@glossary ===} occurrence of `el`.\n* Note that `array` is modified directly.\n*\n* @param {Array} array - The [Array]{@glossary Array} to look through.\n* @param {*} el - The element to search for and remove.\n* @public\n*/\nexports.remove = function (array, el) {\n\tif (!(array instanceof Array)) {\n\t\tvar tmp = array;\n\t\tarray = el;\n\t\tel = tmp;\n\t}\n\n\tvar i = array.indexOf(el);\n\tif (-1 < i) array.splice(i, 1);\n\treturn array;\n};\n\n/**\n* This regex pattern is used by the [isRtl()]{@link module:enyo/utils#isRtl} function.\n*\n* Arabic: \\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFE\n* Hebrew: \\u0590-\\u05FF\\uFB1D-\\uFB4F\n*\n* @private\n*/\nvar rtlPattern = /[\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFE\\u0590-\\u05FF\\uFB1D-\\uFB4F]/;\n\n/**\n* Takes content `str` and determines whether or not it is [RTL]{@glossary RTL}.\n*\n* @param {String} str - A [String]{@glossary String} to check the [RTL]{@glossary RTL}-ness of.\n* @return {Boolean} `true` if `str` should be RTL; `false` if not.\n* @public\n*/\nexports.isRtl = function (str) {\n\treturn rtlPattern.test(str);\n};",
    "mtime": 1542469884723,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/utils.js",
    "relPath": "enyo/utils",
    "requires": [
      "enyo"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./roots",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/roots",
    "name": "enyo/roots",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* @module enyo/roots\n*/\n\n/**\n* @private\n*/\nvar callbacks = [],\n\troots = [];\n\n/**\n* Registers a single callback to be executed whenever a root view is rendered.\n* \n* @name enyo.rendered\n* @method\n* @param {Function} method - The callback to execute.\n* @param {Object} [context=enyo.global] The context under which to execute the callback.\n* @public\n*/\nexports.rendered = function (method, context) {\n\tcallbacks.push({method: method, context: context || global});\n};\n\n/**\n* @private\n*/\nexports.roots = roots;\n\n/**\n* Invokes all known callbacks (if any) against the root view once it has been rendered.\n* This method is not likely to be executed very often.\n* \n* @private\n*/\nfunction invoke (root) {\n\tcallbacks.forEach(function (ln) {\n\t\tln.method.call(ln.context, root);\n\t});\n}\n\n/**\n* @private\n*/\nexports.addToRoots = function (view) {\n\tvar rendered,\n\t\tdestroy;\n\t\n\t// since it is possible to call renderInto more than once on a given view we ensure we\n\t// don't register it twice unnecessarily\n\tif (roots.indexOf(view) === -1) {\n\t\t\n\t\troots.push(view);\n\t\t\n\t\t// hijack the rendered method\n\t\trendered = view.rendered;\n\t\t\n\t\t// hijack the destroy method\n\t\tdestroy = view.destroy;\n\t\t\n\t\t// supply our rendered hook\n\t\tview.rendered = function () {\n\t\t\t// we call the original first\n\t\t\trendered.apply(this, arguments);\n\t\t\t\n\t\t\t// and now we invoke the known callbacks against this root\n\t\t\tinvoke(this);\n\t\t};\n\t\t\n\t\t// supply our destroy hook\n\t\tview.destroy = function () {\n\t\t\tvar idx = roots.indexOf(this);\n\t\t\t\n\t\t\t// remove it from the roots array\n\t\t\tif (idx > -1) roots.splice(idx, 1);\n\t\t\t\n\t\t\t// now we can call the original\n\t\t\tdestroy.apply(this, arguments);\n\t\t};\n\t}\n};\n",
    "mtime": 1542469884715,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/roots.js",
    "relPath": "enyo/roots",
    "requires": [
      "enyo"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./job",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/job",
    "name": "enyo/job",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains methods for dealing with jobs.\n* @module enyo/job\n*/\nvar _jobs = {};\n\n/**\n* Runs a job after a specified amount of time has elapsed\n* since a job with the same name has run.\n* \n* Jobs can be used to throttle behaviors.  If some event may occur one time or\n* multiple times, but we want a response to occur only once every `n` seconds,\n* we can use a job.\n*\n* ```\n* onscroll: function() {\n* \t// updateThumb will be called, but only when 1 second has elapsed since the\n* \t// last onscroll\n* \texports(\"updateThumb\", this.bindSafely(\"updateThumb\"), 1000);\n* }\n* ```\n*\n* @param {String} nom - The name of the job to throttle.\n* @param {(Function|String)} job - Either the name of a method or a [function]{@glossary Function}\n*                                to execute as the requested job.\n* @param {Number} wait - The number of milliseconds to wait before executing the job again.\n* @function\n* @public\n*/\nexports = module.exports = function (nom, job, wait) {\n\texports.stop(nom);\n\t_jobs[nom] = setTimeout(function() {\n\t\texports.stop(nom);\n\t\tjob();\n\t}, wait);\n};\n\n/**\n* Cancels the named job, if it has not already fired.\n*\n* @param {String} nom - The name of the job to cancel.\n* @static\n* @public\n*/\nexports.stop = function (nom) {\n\tif (_jobs[nom]) {\n\t\tclearTimeout(_jobs[nom]);\n\t\tdelete _jobs[nom];\n\t}\n};\n\n/**\n* Immediately invokes the job and prevents any other calls\n* to `exports.throttle()` with the same job name from running for the\n* specified amount of time.\n* \n* This is used for throttling user events when you want to provide an\n* immediate response, but later invocations might just be noise if they arrive\n* too often.\n* \n* @param {String} nom - The name of the job to throttle.\n* @param {(Function|String)} job - Either the name of a method or a [function]{@glossary Function}\n*                                to execute as the requested job.\n* @param {Number} wait - The number of milliseconds to wait before executing the\n*                      job again.\n* @static\n* @public\n*/\nexports.throttle = function (nom, job, wait) {\n\t// if we still have a job with this name pending, return immediately\n\tif (_jobs[nom]) {\n\t\treturn;\n\t}\n\tjob();\n\t_jobs[nom] = setTimeout(function() {\n\t\texports.stop(nom);\n\t}, wait);\n};\n",
    "mtime": 1542469884663,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/job.js",
    "relPath": "enyo/job",
    "requires": [
      "enyo"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./platform",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/platform",
    "name": "enyo/platform",
    "isFile": true,
    "contents": "require('enyo');\n\nvar utils = require('./utils');\n\n/**\n* Determines OS versions of platforms that need special treatment. Can have one of the following\n* properties:\n*\n* * android\n* * androidChrome (Chrome on Android, standard starting in 4.1)\n* * androidFirefox\n* * ie\n* * edge\n* * ios\n* * webos\n* * windowsPhone\n* * blackberry\n* * tizen\n* * safari (desktop version)\n* * chrome (desktop version)\n* * firefox (desktop version)\n* * firefoxOS\n*\n* If the property is defined, its value will be the major version number of the platform.\n*\n* Example:\n* ```javascript\n* // android 2 does not have 3d css\n* if (enyo.platform.android < 3) {\n* \tt = 'translate(30px, 50px)';\n* } else {\n* \tt = 'translate3d(30px, 50px, 0)';\n* }\n* this.applyStyle('-webkit-transform', t);\n* ```\n*\n* @module enyo/platform\n*/\nexports = module.exports = {\n\t/**\n\t* `true` if the platform has native single-finger [events]{@glossary event}.\n\t* @public\n\t*/\n\ttouch: Boolean(('ontouchstart' in window) || window.navigator.msMaxTouchPoints || (window.navigator.msManipulationViewsEnabled && window.navigator.maxTouchPoints)),\n\t/**\n\t* `true` if the platform has native double-finger [events]{@glossary event}.\n\t* @public\n\t*/\n\tgesture: Boolean(('ongesturestart' in window) || ('onmsgesturestart' in window && (window.navigator.msMaxTouchPoints > 1 || window.navigator.maxTouchPoints > 1)))\n\n\t/**\n\t* The name of the platform that was detected or `undefined` if the platform\n\t* was unrecognized. This value is the key name for the major version of the\n\t* platform on the exported object.\n\t* @member {String} platformName\n\t* @public\n\t*/\n\n};\n\nvar ua = navigator.userAgent;\nvar ep = exports;\nvar platforms = [\n\t// Windows Phone 7 - 10\n\t{platform: 'windowsPhone', regex: /Windows Phone (?:OS )?(\\d+)[.\\d]+/},\n\t// Android 4+ using Chrome\n\t{platform: 'androidChrome', regex: /Android .* Chrome\\/(\\d+)[.\\d]+/},\n\t// Android 2 - 4\n\t{platform: 'android', regex: /Android(?:\\s|\\/)(\\d+)/},\n\t// Kindle Fire\n\t// Force version to 2, (desktop mode does not list android version)\n\t{platform: 'android', regex: /Silk\\/1./, forceVersion: 2, extra: {silk: 1}},\n\t// Kindle Fire HD (Silk versions 2 or 3)\n\t// Force version to 4\n\t{platform: 'android', regex: /Silk\\/2./, forceVersion: 4, extra: {silk: 2}},\n\t{platform: 'android', regex: /Silk\\/3./, forceVersion: 4, extra: {silk: 3}},\n\t// IE 8 - 10\n\t{platform: 'ie', regex: /MSIE (\\d+)/},\n\t// IE 11\n\t{platform: 'ie', regex: /Trident\\/.*; rv:(\\d+)/},\n\t// Edge\n\t{platform: 'edge', regex: /Edge\\/(\\d+)/},\n\t// iOS 3 - 5\n\t// Apple likes to make this complicated\n\t{platform: 'ios', regex: /iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/},\n\t// webOS 1 - 3\n\t{platform: 'webos', regex: /(?:web|hpw)OS\\/(\\d+)/},\n\t// webOS 4 / OpenWebOS\n\t{platform: 'webos', regex: /WebAppManager|Isis|webOS\\./, forceVersion: 4},\n\t// Open webOS release LuneOS\n\t{platform: 'webos', regex: /LuneOS/, forceVersion: 4, extra: {luneos: 1}},\n\t// desktop Safari\n\t{platform: 'safari', regex: /Version\\/(\\d+)[.\\d]+\\s+Safari/},\n\t// desktop Chrome\n\t{platform: 'chrome', regex: /Chrome\\/(\\d+)[.\\d]+/},\n\t// Firefox on Android\n\t{platform: 'androidFirefox', regex: /Android;.*Firefox\\/(\\d+)/},\n\t// FirefoxOS\n\t{platform: 'firefoxOS', regex: /Mobile;.*Firefox\\/(\\d+)/},\n\t// desktop Firefox\n\t{platform: 'firefox', regex: /Firefox\\/(\\d+)/},\n\t// Blackberry Playbook\n\t{platform: 'blackberry', regex: /PlayBook/i, forceVersion: 2},\n\t// Blackberry 10+\n\t{platform: 'blackberry', regex: /BB1\\d;.*Version\\/(\\d+\\.\\d+)/},\n\t// Tizen\n\t{platform: 'tizen', regex: /Tizen (\\d+)/}\n];\nfor (var i = 0, p, m, v; (p = platforms[i]); i++) {\n\tm = p.regex.exec(ua);\n\tif (m) {\n\t\tif (p.forceVersion) {\n\t\t\tv = p.forceVersion;\n\t\t} else {\n\t\t\tv = Number(m[1]);\n\t\t}\n\t\tep[p.platform] = v;\n\t\tif (p.extra) {\n\t\t\tutils.mixin(ep, p.extra);\n\t\t}\n\t\tep.platformName = p.platform;\n\t\tbreak;\n\t}\n}\n",
    "mtime": 1542469884703,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/platform.js",
    "relPath": "enyo/platform",
    "requires": [
      "enyo",
      "./utils"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./logger",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/logger",
    "name": "enyo/logger",
    "isFile": true,
    "contents": "require('enyo');\n\nvar\n\tjson = require('./json'),\n\tutils = require('./utils'),\n\tplatform = require('./platform');\n\n/**\n* These platforms only allow one argument for [console.log()]{@glossary console.log}:\n*\n* * android\n* * ios\n* * webos\n*\n* @ignore\n*/\nvar dumbConsole = Boolean(platform.android || platform.ios || platform.webos);\n\n/**\n* Internally used methods and properties associated with logging.\n*\n* @module enyo/logger\n* @public\n*/\nexports = module.exports = {\n\n\t/**\n\t* The log level to use. Can be a value from -1 to 99, where -1 disables all\n\t* logging, 0 is 'error', 10 is 'warn', and 20 is 'log'. It is preferred that\n\t* this value be set using the [setLogLevel()]{@link module:enyo/logger#setLogLevel}\n\t* method.\n\t*\n\t* @type {Number}\n\t* @default 99\n\t* @public\n\t*/\n\tlevel: 99,\n\n\t/**\n\t* The known levels.\n\t*\n\t* @private\n\t*/\n\tlevels: {log: 20, warn: 10, error: 0},\n\n\t/**\n\t* @private\n\t*/\n\tshouldLog: function (fn) {\n\t\tvar ll = parseInt(this.levels[fn], 0);\n\t\treturn (ll <= this.level);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tvalidateArgs: function (args) {\n\t\t// gracefully handle and prevent circular reference errors in objects\n\t\tfor (var i=0, l=args.length, item; (item=args[i]) || i<l; i++) {\n\t\t\ttry {\n\t\t\t\tif (typeof item === 'object') {\n\t\t\t\t\targs[i] = json.stringify(item);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\targs[i] = 'Error: ' + e.message;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\t_log: function (fn, args) {\n\t\t// avoid trying to use console on IE instances where the object hasn't been\n\t\t// created due to the developer tools being unopened\n\t\tvar console = global.console;\n\t\tif (typeof console === 'undefined') {\n            return;\n        }\n\t\t//var a$ = utils.logging.formatArgs(fn, args);\n\t\tvar a$ = utils.isArray(args) ? args : utils.cloneArray(args);\n\t\tif (platform.androidFirefox) {\n\t\t\t// Firefox for Android's console does not handle objects with circular references\n\t\t\tthis.validateArgs(a$);\n\t\t}\n\t\tif (dumbConsole) {\n\t\t\t// at least in early versions of webos, console.* only accept a single argument\n\t\t\ta$ = [a$.join(' ')];\n\t\t}\n\t\tvar fn$ = console[fn];\n\t\tif (fn$ && fn$.apply) {\n\t\t\t// some consoles support 'warn', 'info', and so on\n\t\t\tfn$.apply(console, a$);\n\t\t} else if (console.log.apply) {\n\t\t\t// some consoles support console.log.apply\n\t\t\tconsole.log.apply(console, a$);\n\t\t} else {\n\t\t\t// otherwise, do our own formatting\n\t\t\tconsole.log(a$.join(' '));\n\t\t}\n\t},\n\n\t/**\n\t* This is exposed elsewhere.\n\t*\n\t* @private\n\t*/\n\tlog: function (fn, args) {\n\n\t\tif (fn != 'log' && fn != 'warn' && fn != 'error') {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t\tfn = 'log';\n\t\t}\n\n\t\tvar console = global.console;\n\t\tif (typeof console !== 'undefined') {\n\t\t\tif (this.shouldLog(fn)) {\n\t\t\t\tthis._log(fn, args);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n* Sets the log level to the given value. This will restrict the amount of output depending on\n* the settings. The higher the value, the more output that will be allowed. The default is\n* 99. The value, -1, would silence all logging, even 'error' (0).\n* Without the 'see': {@link module:enyo/logger#log}.\n*\n* @see module:enyo/logger#level\n* @see module:enyo/logger#log\n* @see module:enyo/logger#warn\n* @see module:enyo/logger#error\n* @param {Number} level - The level to set logging to.\n*/\nexports.setLogLevel = function (level) {\n\tvar ll = parseInt(level, 0);\n\tif (isFinite(ll)) {\n\t\tthis.level = ll;\n\t}\n};\n\n/**\n* A wrapper for [console.log()]{@glossary console.log}, compatible\n* across supported platforms. Will output only if the current\n* [log level]{@link module:enyo/logger#level} allows it. [Object]{@glossary Object}\n* parameters will be serialized via [JSON.stringify()]{@glossary JSON.stringify}\n* automatically.\n*\n* @utility\n* @see {@glossary console.log}\n* @param {...*} - The arguments to be logged.\n* @public\n*/\n\n/**\n* A wrapper for [console.warn()]{@glossary console.warn}, compatible\n* across supported platforms. Will output only if the current\n* [log level]{@link module:enyo/logger#level} allows it. [Object]{@glossary Object}\n* parameters will be serialized via [JSON.stringify()]{@glossary JSON.stringify}\n* automatically.\n*\n* @utility\n* @see {@glossary console.warn}\n* @param {...*} - The arguments to be logged.\n* @public\n*/\nexports.warn = function () {\n\tthis.log('warn', arguments);\n};\n\n/**\n* A wrapper for [console.error()]{@glossary console.error}, compatible\n* across supported platforms. Will output only if the current\n* [log level]{@link module:enyo/logger#level} allows it. [Object]{@glossary Object}\n* parameters will be serialized via [JSON.stringify()]{@glossary JSON.stringify}\n* automatically.\n*\n* @utility\n* @see {@glossary console.error}\n* @param {...*} - The arguments to be logged.\n* @public\n*/\nexports.error = function () {\n\tthis.log('error', arguments);\n};\n",
    "mtime": 1542469884679,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/logger.js",
    "relPath": "enyo/logger",
    "requires": [
      "enyo",
      "./json",
      "./utils",
      "./platform"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./dom",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/dom",
    "name": "enyo/dom",
    "isFile": true,
    "contents": "/**\n* Contains methods for working with DOM\n* @module enyo/dom\n*/\nrequire('enyo');\n\nvar\n\troots = require('./roots'),\n\tutils = require('./utils'),\n\tplatform = require('./platform');\n\nvar dom = module.exports = {\n\n\t/**\n\t* Shortcut for `document.getElementById()` if `id` is a string; otherwise,\n\t* returns `id`. Uses `global.document` unless a document is specified in the\n\t* (optional) `doc` parameter.\n\t*\n\t* ```javascript\n\t* var\n\t* \tdom = require('enyo/dom');\n\t*\n\t* // find 'node' if it's a string id, or return it unchanged if it's already a node reference\n\t* var domNode = dom.byId(node);\n\t* ```\n\t*\n\t* @param {String} id - The document element ID to get.\n\t* @param {Node} [doc] - A [node]{@glossary Node} to search in. Default is the whole\n\t*\tdocument.\n\t* @returns {Element} A reference to a DOM element.\n\t* @public\n\t*/\n\tbyId: function(id, doc){\n\t\treturn (typeof id == 'string') ? (doc || document).getElementById(id) : id;\n\t},\n\n\t/**\n\t* Returns a string with ampersand, less-than, and greater-than characters replaced with HTML\n\t* entities, e.g.,\n\t* ```\n\t* '&lt;code&gt;'This &amp; That'&lt;/code&gt;'\n\t* ```\n\t* becomes\n\t* ```\n\t* '&amp;lt;code&amp;gt;'This &amp;amp; That'&amp;lt;/code&amp;gt;'\n\t* ```\n\t*\n\t* @param {String} text - A string with entities you'd like to escape/convert.\n\t* @returns {String} A string that is properly escaped (the above characters.)\n\t* @public\n\t*/\n\tescape: function(text) {\n\t\treturn text !== null ? String(text).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;') : '';\n\t},\n\n\t/**\n\t* Returns an object describing the geometry of this node.\n\t*\n\t* @param {Node} n - The [node]{@glossary Node} to measure.\n\t* @returns {Object} An object containing the properties `top`, `left`,\n\t* `height`, and `width`.\n\t* @public\n\t*/\n\tgetBounds: function(n) {\n\t\tif (n) {\n\t\t\treturn {left: n.offsetLeft, top: n.offsetTop, width: n.offsetWidth, height: n.offsetHeight};\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetComputedStyle: function(node) {\n\t\treturn global.getComputedStyle && node && global.getComputedStyle(node, null);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetComputedStyleValue: function(node, property, computedStyle) {\n\t\tvar s   = computedStyle || this.getComputedStyle(node),\n\t\t\tnIE = platform.ie;\n\n\t\ts = s ? s.getPropertyValue(property) : null;\n\n\t\tif (nIE) {\n\t\t\tvar oConversion = {\n\t\t\t\t'thin'   : '2px',\n\t\t\t\t'medium' : '4px',\n\t\t\t\t'thick'  : '6px',\n\t\t\t\t'none'   : '0'\n\t\t\t};\n\t\t\tif (typeof oConversion[s] != 'undefined') {\n\t\t\t\ts = oConversion[s];\n\t\t\t}\n\n\t\t\tif (s == 'auto') {\n\t\t\t\tswitch (property) {\n\t\t\t\tcase 'width':\n\t\t\t\t\ts = node.offsetWidth;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'height':\n\t\t\t\t\ts = node.offsetHeight;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn s;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetFirstElementByTagName: function(tagName) {\n\t\tvar e = document.getElementsByTagName(tagName);\n\t\treturn e && e[0];\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tapplyBodyFit: function() {\n\t\tvar h = this.getFirstElementByTagName('html');\n\t\tif (h) {\n\t\t\tthis.addClass(h, 'enyo-document-fit');\n\t\t}\n\t\tdom.addBodyClass('enyo-body-fit');\n\t\tdom.bodyIsFitting = true;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetWindowWidth: function() {\n\t\tif (global.innerWidth) {\n\t\t\treturn global.innerWidth;\n\t\t}\n\t\tif (document.body && document.body.offsetWidth) {\n\t\t\treturn document.body.offsetWidth;\n\t\t}\n\t\tif (document.compatMode=='CSS1Compat' &&\n\t\t\tdocument.documentElement &&\n\t\t\tdocument.documentElement.offsetWidth ) {\n\t\t\treturn document.documentElement.offsetWidth;\n\t\t}\n\t\treturn 320;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetWindowHeight: function() {\n\t\tif (global.innerHeight) {\n\t\t\treturn global.innerHeight;\n\t\t}\n\t\tif (document.body && document.body.offsetHeight) {\n\t\t\treturn document.body.offsetHeight;\n\t\t}\n\t\tif (document.compatMode=='CSS1Compat' &&\n\t\t\tdocument.documentElement &&\n\t\t\tdocument.documentElement.offsetHeight ) {\n\t\t\treturn document.documentElement.offsetHeight;\n\t\t}\n\t\treturn 480;\n\t},\n\n\t/**\n\t* The proportion by which the `body` tag differs from the global size, in both X and Y\n\t* dimensions. This is relevant when we need to scale the whole interface down from 1920x1080\n\t* (1080p) to 1280x720 (720p), for example.\n\t*\n\t* @private\n\t*/\n\t_bodyScaleFactorY: 1,\n\t_bodyScaleFactorX: 1,\n\tupdateScaleFactor: function() {\n\t\tvar bodyBounds = this.getBounds(document.body);\n\t\tthis._bodyScaleFactorY = bodyBounds.height / this.getWindowHeight();\n\t\tthis._bodyScaleFactorX = bodyBounds.width / this.getWindowWidth();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetComputedBoxValue: function(node, prop, boundary, computedStyle) {\n\t\tvar s = computedStyle || this.getComputedStyle(node);\n\t\tif (s) {\n\t\t\tvar p = s.getPropertyValue(prop + '-' + boundary);\n\t\t\treturn p === 'auto' ? 0 : parseInt(p, 10);\n\t\t}\n\t\treturn 0;\n\t},\n\n\t/**\n\t* Gets the boundaries of a [node's]{@glossary Node} `margin` or `padding` box.\n\t*\n\t* @param {Node} node - The [node]{@glossary Node} to measure.\n\t* @param {Node} box - The boundary to measure from ('padding' or 'margin').\n\t* @returns {Object} An object containing the properties `top`, `right`, `bottom`, and\n\t*\t`left`.\n\t* @public\n\t*/\n\tcalcBoxExtents: function(node, box) {\n\t\tvar s = this.getComputedStyle(node);\n\t\treturn {\n\t\t\ttop: this.getComputedBoxValue(node, box, 'top', s),\n\t\t\tright: this.getComputedBoxValue(node, box, 'right', s),\n\t\t\tbottom: this.getComputedBoxValue(node, box, 'bottom', s),\n\t\t\tleft: this.getComputedBoxValue(node, box, 'left', s)\n\t\t};\n\t},\n\n\t/**\n\t* Gets the calculated padding of a node. Shortcut for\n\t* {@link module:enyo/dom#calcBoxExtents}.\n\t*\n\t* @param {Node} node - The [node]{@glossary Node} to measure.\n\t* @returns {Object} An object containing the properties `top`, `right`, `bottom`, and\n\t*\t`left`.\n\t* @public\n\t*/\n\tcalcPaddingExtents: function(node) {\n\t\treturn this.calcBoxExtents(node, 'padding');\n\t},\n\n\t/**\n\t* Gets the calculated margin of a node. Shortcut for\n\t* {@link module:enyo/dom#calcBoxExtents}.\n\t*\n\t* @param {Node} node - The [node]{@glossary Node} to measure.\n\t* @returns {Object} An object containing the properties `top`, `right`, `bottom`, and\n\t*\t`left`.\n\t* @public\n\t*/\n\tcalcMarginExtents: function(node) {\n\t\treturn this.calcBoxExtents(node, 'margin');\n\t},\n\t/**\n\t* Returns an object like `{top: 0, left: 0, bottom: 100, right: 100, height: 10, width: 10}`\n\t* that represents the object's position relative to `relativeToNode` (suitable for absolute\n\t* positioning within that parent node). Negative values mean part of the object is not\n\t* visible. If you leave `relativeToNode` as `undefined` (or it is not a parent element), then\n\t* the position will be relative to the viewport and suitable for absolute positioning in a\n\t* floating layer.\n\t*\n\t* @param {Node} node - The [node]{@glossary Node} to measure.\n\t* @param {Node} relativeToNode - The [node]{@glossary Node} to measure the distance from.\n\t* @returns {Object} An object containing the properties `top`, `right`, `bottom`, `left`,\n\t*\t`height`, and `width`.\n\t* @public\n\t*/\n\tcalcNodePosition: function(targetNode, relativeToNode) {\n\t\t// Parse upward and grab our positioning relative to the viewport\n\t\tvar top = 0,\n\t\t\tleft = 0,\n\t\t\tnode = targetNode,\n\t\t\twidth = node.offsetWidth,\n\t\t\theight = node.offsetHeight,\n\t\t\ttransformProp = dom.getStyleTransformProp(),\n\t\t\txregex = /translateX\\((-?\\d+)px\\)/i,\n\t\t\tyregex = /translateY\\((-?\\d+)px\\)/i,\n\t\t\tborderLeft = 0, borderTop = 0,\n\t\t\ttotalHeight = 0, totalWidth = 0,\n\t\t\toffsetAdjustLeft = 0, offsetAdjustTop = 0;\n\n\t\tif (relativeToNode) {\n\t\t\ttotalHeight = relativeToNode.offsetHeight;\n\t\t\ttotalWidth = relativeToNode.offsetWidth;\n\t\t} else {\n\t\t\ttotalHeight = (document.body.parentNode.offsetHeight > this.getWindowHeight() ? this.getWindowHeight() - document.body.parentNode.scrollTop : document.body.parentNode.offsetHeight);\n\t\t\ttotalWidth = (document.body.parentNode.offsetWidth > this.getWindowWidth() ? this.getWindowWidth() - document.body.parentNode.scrollLeft : document.body.parentNode.offsetWidth);\n\t\t}\n\n\t\tif (node.offsetParent) {\n\t\t\tdo {\n\t\t\t\t// Adjust the offset if relativeToNode is a child of the offsetParent\n\t\t\t\tif (relativeToNode && relativeToNode.compareDocumentPosition(node.offsetParent) & Node.DOCUMENT_POSITION_CONTAINS) {\n\t\t\t\t\toffsetAdjustLeft = relativeToNode.offsetLeft;\n\t\t\t\t\toffsetAdjustTop = relativeToNode.offsetTop;\n\t\t\t\t}\n\t\t\t\t// Ajust our top and left properties based on the position relative to the parent\n\t\t\t\tleft += node.offsetLeft - (node.offsetParent ? node.offsetParent.scrollLeft : 0) - offsetAdjustLeft;\n\t\t\t\tif (transformProp && xregex.test(node.style[transformProp])) {\n\t\t\t\t\tleft += parseInt(node.style[transformProp].replace(xregex, '$1'), 10);\n\t\t\t\t}\n\t\t\t\ttop += node.offsetTop - (node.offsetParent ? node.offsetParent.scrollTop : 0) - offsetAdjustTop;\n\t\t\t\tif (transformProp && yregex.test(node.style[transformProp])) {\n\t\t\t\t\ttop += parseInt(node.style[transformProp].replace(yregex, '$1'), 10);\n\t\t\t\t}\n\t\t\t\t// Need to correct for borders if any exist on parent elements\n\t\t\t\tif (node !== targetNode) {\n\t\t\t\t\tif (global.getComputedStyle) {\n\t\t\t\t\t\tborderLeft = parseInt(global.getComputedStyle(node, '').getPropertyValue('border-left-width'), 10);\n\t\t\t\t\t\tborderTop = parseInt(global.getComputedStyle(node, '').getPropertyValue('border-top-width'), 10);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No computed style options, so try the normal style object (much less robust)\n\t\t\t\t\t\tborderLeft = parseInt(node.style.borderLeftWidth, 10);\n\t\t\t\t\t\tborderTop = parseInt(node.style.borderTopWidth, 10);\n\t\t\t\t\t}\n\t\t\t\t\tif (borderLeft) {\n\t\t\t\t\t\tleft += borderLeft;\n\t\t\t\t\t}\n\t\t\t\t\tif (borderTop) {\n\t\t\t\t\t\ttop += borderTop;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Continue if we have an additional offsetParent, and either don't have a relativeToNode or the offsetParent is contained by the relativeToNode (if offsetParent contains relativeToNode, then we have already calculated up to the node, and can safely exit)\n\t\t\t} while ((node = node.offsetParent) && (!relativeToNode || relativeToNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY));\n\t\t}\n\t\treturn {\n\t\t\t'top': top,\n\t\t\t'left': left,\n\t\t\t'bottom': totalHeight - top - height,\n\t\t\t'right': totalWidth - left - width,\n\t\t\t'height': height,\n\t\t\t'width': width\n\t\t};\n\t},\n\n\t/**\n\t* Removes a node from the DOM.\n\t*\n\t* @param {Node} node - The [node]{@glossary Node} to remove.\n\t* @public\n\t*/\n\tremoveNode: function (node) {\n\t\tif (node.parentNode) node.parentNode.removeChild(node);\n\t},\n\n\t/**\n\t* Sets the `innerHTML` property of the specified `node` to `html`.\n\t*\n\t* @param {Node} node - The [node]{@glossary Node} to set.\n\t* @param {String} html - An HTML string.\n\t* @public\n\t*/\n\tsetInnerHtml: function(node, html) {\n\t\tnode.innerHTML = html;\n\t},\n\n\t/**\n\t* Checks a [DOM]{@glossary Node} [node]{@glossary Node} for a specific CSS class.\n\t*\n\t* @param {Node} node - The [node]{@glossary Node} to set.\n\t* @param {String} s - The class name to check for.\n\t* @returns {(Boolean|undefined)} `true` if `node` has the `s` class; `undefined`\n\t* if there is no `node` or it has no `className` property.\n\t* @public\n\t*/\n\thasClass: function(node, s) {\n\t\tif (!node || !s || !node.className) { return; }\n\t\treturn (' ' + node.className + ' ').indexOf(' ' + s + ' ') >= 0;\n\t},\n\n\t/**\n\t* Uniquely adds a CSS class to a DOM node.\n\t*\n\t* @param {Node} node - The [node]{@glossary Node} to set.\n\t* @param {String} s - The class name to add.\n\t* @public\n\t*/\n\taddClass: function(node, s) {\n\t\tif (node && s && !this.hasClass(node, s)) {\n\t\t\tvar ss = node.className;\n\t\t\tnode.className = (ss + (ss ? ' ' : '') + s);\n\t\t}\n\t},\n\n\t/**\n\t* Removes a CSS class from a DOM node if it exists.\n\t*\n\t* @param {Node} node - The [node]{@glossary Node} from which to remove the class.\n\t* @param {String} s - The class name to remove from `node`.\n\t* @public\n\t*/\n\tremoveClass: function(node, s) {\n\t\tif (node && s && this.hasClass(node, s)) {\n\t\t\tvar ss = node.className;\n\t\t\tnode.className = (' ' + ss + ' ').replace(' ' + s + ' ', ' ').slice(1, -1);\n\t\t}\n\t},\n\n\t/**\n\t* Adds a class to `document.body`. This defers the actual class change if nothing has been\n\t* rendered into `body` yet.\n\t*\n\t* @param {String} s - The class name to add to the document's `body`.\n\t* @public\n\t*/\n\taddBodyClass: function(s) {\n\t\tif (!utils.exists(roots.roots) || roots.roots.length === 0) {\n\t\t\tif (dom._bodyClasses) {\n\t\t\t\tdom._bodyClasses.push(s);\n\t\t\t} else {\n\t\t\t\tdom._bodyClasses = [s];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdom.addClass(document.body, s);\n\t\t}\n\t},\n\n\t/**\n\t* Returns an object describing the absolute position on the screen, relative to the top left\n\t* corner of the screen. This function takes into account account absolute/relative\n\t* `offsetParent` positioning, `scroll` position, and CSS transforms (currently\n\t* `translateX`, `translateY`, and `matrix3d`).\n\t*\n\t* ```javascript\n\t* {top: ..., right: ..., bottom: ..., left: ..., height: ..., width: ...}\n\t* ```\n\t*\n\t* Values returned are only valid if `hasNode()` is truthy. If there's no DOM node for the\n\t* object, this returns a bounds structure with `undefined` as the value of all fields.\n\t*\n\t* @param {Node} n - The [node]{@glossary Node} to measure.\n\t* @returns {Object} An object containing the properties `top`, `right`, `bottom`, `left`,\n\t*\t`height`, and `width`.\n\t* @public\n\t*/\n\tgetAbsoluteBounds: function(targetNode) {\n\t\treturn utils.clone(targetNode.getBoundingClientRect());\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tflushBodyClasses: function() {\n\t\tif (dom._bodyClasses) {\n\t\t\tfor (var i = 0, c; (c=dom._bodyClasses[i]); ++i) {\n\t\t\t\tdom.addClass(document.body, c);\n\t\t\t}\n\t\t\tdom._bodyClasses = null;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\t_bodyClasses: null,\n\n\t/**\n\t* Convert to various unit formats. Useful for converting pixels to a resolution-independent\n\t* measurement method, like \"rem\". Other units are available if defined in the\n\t* {@link module:enyo/dom#unitToPixelFactors} object.\n\t*\n\t* ```javascript\n\t* var\n\t* \tdom = require('enyo/dom');\n\t*\n\t* // Do calculations and get back the desired CSS unit.\n\t* var frameWidth = 250,\n\t*     frameWithMarginInches = dom.unit( 10 + frameWidth + 10, 'in' ),\n\t*     frameWithMarginRems = dom.unit( 10 + frameWidth + 10, 'rem' );\n\t* // '2.8125in' == frameWithMarginInches\n\t* // '22.5rem' == frameWithMarginRems\n\t* ```\n\t*\n\t* @param {(String|Number)} pixels - The the pixels or math to convert to the unit.\n\t*\t(\"px\" suffix in String format is permitted. ex: `'20px'`)\n\t* @param {(String)} toUnit - The name of the unit to convert to.\n\t* @returns {(Number|undefined)} Resulting conversion, in case of malformed input, `undefined`\n\t* @public\n\t*/\n\tunit: function (pixels, toUnit) {\n\t\tif (!toUnit || !this.unitToPixelFactors[toUnit]) return;\n\t\tif (typeof pixels == 'string' && pixels.substr(-2) == 'px') pixels = parseInt(pixels.substr(0, pixels.length - 2), 10);\n\t\tif (typeof pixels != 'number') return;\n\n\t\treturn (pixels / this.unitToPixelFactors[toUnit]) + '' + toUnit;\n\t},\n\n\t/**\n\t* Object that stores all of the pixel conversion factors to each keyed unit.\n\t*\n\t* @public\n\t*/\n\tunitToPixelFactors: {\n\t\t'rem': 12,\n\t\t'in': 96\n\t}\n};\n\n// override setInnerHtml for Windows 8 HTML applications\nif (typeof global.MSApp !== 'undefined' && typeof global.MSApp.execUnsafeLocalFunction !== 'undefined') {\n\tdom.setInnerHtml = function(node, html) {\n\t\tglobal.MSApp.execUnsafeLocalFunction(function() {\n\t\t\tnode.innerHTML = html;\n\t\t});\n\t};\n}\n\n// use faster classList interface if it exists\nif (document.head && document.head.classList) {\n\tdom.hasClass = function(node, s) {\n\t\tif (node) {\n\t\t\treturn node.classList.contains(s);\n\t\t}\n\t};\n\tdom.addClass = function(node, s) {\n\t\tif (node) {\n\t\t\treturn node.classList.add(s);\n\t\t}\n\t};\n\tdom.removeClass = function (node, s) {\n\t\tif (node) {\n\t\t\treturn node.classList.remove(s);\n\t\t}\n\t};\n}\n\n/**\n* Allows bootstrapping in environments that do not have a global object right away.\n*\n* @param {Function} func - The function to run\n* @public\n*/\ndom.requiresWindow = function(func) {\n\tfunc();\n};\n\n\nvar cssTransformProps = ['transform', '-webkit-transform', '-moz-transform', '-ms-transform', '-o-transform'],\n\tstyleTransformProps = ['transform', 'webkitTransform', 'MozTransform', 'msTransform', 'OTransform'];\n\n/**\n* @private\n*/\ndom.calcCanAccelerate = function() {\n\t/* Android 2 is a liar: it does NOT support 3D transforms, even though Perspective is the best check */\n\tif (platform.android <= 2) {\n\t\treturn false;\n\t}\n\tvar p$ = ['perspective', 'WebkitPerspective', 'MozPerspective', 'msPerspective', 'OPerspective'];\n\tfor (var i=0, p; (p=p$[i]); i++) {\n\t\tif (typeof document.body.style[p] != 'undefined') {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\n/**\n* @private\n*/\ndom.getCssTransformProp = function() {\n\tif (this._cssTransformProp) {\n\t\treturn this._cssTransformProp;\n\t}\n\tvar i = utils.indexOf(this.getStyleTransformProp(), styleTransformProps);\n\tthis._cssTransformProp = cssTransformProps[i];\n\treturn this._cssTransformProp;\n};\n\n/**\n* @private\n*/\ndom.getStyleTransformProp = function() {\n\tif (this._styleTransformProp || !document.body) {\n\t\treturn this._styleTransformProp;\n\t}\n\tfor (var i = 0, p; (p = styleTransformProps[i]); i++) {\n\t\tif (typeof document.body.style[p] != 'undefined') {\n\t\t\tthis._styleTransformProp = p;\n\t\t\treturn this._styleTransformProp;\n\t\t}\n\t}\n};\n\n/**\n* @private\n*/\ndom.domTransformsToCss = function(inTransforms) {\n\tvar n, v, text = '';\n\tfor (n in inTransforms) {\n\t\tv = inTransforms[n];\n\t\tif ((v !== null) && (v !== undefined) && (v !== '')) {\n\t\t\ttext +=  n + '(' + v + ') ';\n\t\t}\n\t}\n\treturn text;\n};\n\n/**\n* @private\n*/\ndom.transformsToDom = function(control) {\n\tvar css = this.domTransformsToCss(control.domTransforms),\n\t\tstyleProp;\n\n\tif (control.hasNode()) {\n\t\tstyleProp = this.getStyleTransformProp();\n\t} else {\n\t\tstyleProp = this.getCssTransformProp();\n\t}\n\n\tif (styleProp) control.applyStyle(styleProp, css);\n};\n\n/**\n* Returns `true` if the platform supports CSS3 Transforms.\n*\n* @returns {Boolean} `true` if platform supports CSS `transform` property;\n* otherwise, `false`.\n* @public\n*/\ndom.canTransform = function() {\n\treturn Boolean(this.getStyleTransformProp());\n};\n\n/**\n* Returns `true` if platform supports CSS3 3D Transforms.\n*\n* Typically used like this:\n* ```\n* if (dom.canAccelerate()) {\n* \tdom.transformValue(this.$.slidingThing, 'translate3d', x + ',' + y + ',' + '0')\n* } else {\n* \tdom.transformValue(this.$.slidingThing, 'translate', x + ',' + y);\n* }\n* ```\n*\n* @returns {Boolean} `true` if platform supports CSS3 3D Transforms;\n* otherwise, `false`.\n* @public\n*/\ndom.canAccelerate = function() {\n\treturn (this.accelerando !== undefined) ? this.accelerando : document.body && (this.accelerando = this.calcCanAccelerate());\n};\n\n/**\n* Applies a series of transforms to the specified {@link module:enyo/Control~Control}, using\n* the platform's prefixed `transform` property.\n*\n* **Note:** Transforms are not commutative, so order is important.\n*\n* Transform values are updated by successive calls, so\n* ```javascript\n* dom.transform(control, {translate: '30px, 40px', scale: 2, rotate: '20deg'});\n* dom.transform(control, {scale: 3, skewX: '-30deg'});\n* ```\n*\n* is equivalent to:\n* ```javascript\n* dom.transform(control, {translate: '30px, 40px', scale: 3, rotate: '20deg', skewX: '-30deg'});\n* ```\n*\n* When applying these transforms in a WebKit browser, this is equivalent to:\n* ```javascript\n* control.applyStyle('-webkit-transform', 'translate(30px, 40px) scale(3) rotate(20deg) skewX(-30deg)');\n* ```\n*\n* And in Firefox, this is equivalent to:\n* ```javascript\n* control.applyStyle('-moz-transform', 'translate(30px, 40px) scale(3) rotate(20deg) skewX(-30deg)');\n* ```\n*\n* @param {module:enyo/Control~Control} control - The {@link module:enyo/Control~Control} to transform.\n* @param {Object} transforms - The set of transforms to apply to `control`.\n* @public\n*/\ndom.transform = function(control, transforms) {\n\tvar d = control.domTransforms = control.domTransforms || {};\n\tutils.mixin(d, transforms);\n\tthis.transformsToDom(control);\n};\n\n/**\n* Applies a single transform to the specified {@link module:enyo/Control~Control}.\n*\n* Example:\n* ```\n* tap: function(inSender, inEvent) {\n* \tvar c = inEvent.originator;\n* \tvar r = c.rotation || 0;\n* \tr = (r + 45) % 360;\n* \tc.rotation = r;\n* \tdom.transformValue(c, 'rotate', r);\n* }\n* ```\n*\n* This will rotate the tapped control by 45 degrees clockwise.\n*\n* @param {module:enyo/Control~Control} control - The {@link module:enyo/Control~Control} to transform.\n* @param {String} transform - The name of the transform function.\n* @param {(String|Number)} value - The value to apply to the transform.\n* @public\n*/\ndom.transformValue = function(control, transform, value) {\n\tvar d = control.domTransforms = control.domTransforms || {};\n\td[transform] = value;\n\tthis.transformsToDom(control);\n};\n\n/**\n* Applies a transform that should trigger GPU compositing for the specified\n* {@link module:enyo/Control~Control}. By default, the acceleration is only\n* applied if the browser supports it. You may also optionally force-set `value`\n* directly, to be applied to `translateZ(value)`.\n*\n* @param {module:enyo/Control~Control} control - The {@link module:enyo/Control~Control} to accelerate.\n* @param {(String|Number)} [value] - An optional value to apply to the acceleration transform\n*\tproperty.\n* @public\n*/\ndom.accelerate = function(control, value) {\n\tvar v = value == 'auto' ? this.canAccelerate() : value;\n\tthis.transformValue(control, 'translateZ', v ? 0 : null);\n};\n\n\n/**\n * The CSS `transition` property name for the current browser/platform, e.g.:\n *\n * * `-webkit-transition`\n * * `-moz-transition`\n * * `transition`\n *\n * @type {String}\n * @private\n */\ndom.transition = (platform.ios || platform.android || platform.chrome || platform.androidChrome || platform.safari)\n\t? '-webkit-transition'\n\t: (platform.firefox || platform.firefoxOS || platform.androidFirefox)\n\t\t? '-moz-transition'\n\t\t: 'transition';\n",
    "mtime": 1542469884971,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/dom.js",
    "relPath": "enyo/dom",
    "requires": [
      "enyo",
      "./roots",
      "./utils",
      "./platform"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./animation",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/animation",
    "name": "enyo/animation",
    "isFile": true,
    "contents": "/**\n* Contains methods useful for animations.\n* @module enyo/animation\n*/\n\nrequire('enyo');\n\nvar\n\tplatform = require('./platform'),\n\tutils = require('./utils');\n\nvar ms = Math.round(1000/60),\n\tprefix = ['', 'webkit', 'moz', 'ms', 'o'],\n\trAF = 'requestAnimationFrame',\n\tcRAF = 'cancelRequestAnimationFrame',\n\tcAF = 'cancelAnimationFrame',\n\ti, pl, p, wcRAF, wrAF, wcAF,\n\t_requestFrame, _cancelFrame, cancelFrame;\n\n/*\n* Fallback on setTimeout\n*\n* @private\n*/\n_requestFrame = function(callback) {\n\treturn global.setTimeout(callback, ms);\n};\n\n/*\n* Fallback on clearTimeout\n*\n* @private\n*/\n_cancelFrame = function(id) {\n\treturn global.clearTimeout(id);\n};\n\nfor (i = 0, pl = prefix.length; (p = prefix[i]) || i < pl; i++) {\n\t// if we're on ios 6 just use setTimeout, requestAnimationFrame has some kinks\n\tif (platform.ios === 6) {\n\t\tbreak;\n\t}\n\n\t// if prefixed, becomes Request and Cancel\n\twrAF = p ? (p + utils.cap(rAF)) : rAF;\n\twcRAF = p ? (p + utils.cap(cRAF)) : cRAF;\n\twcAF = p ? (p + utils.cap(cAF)) : cAF;\n\n\t// Test for cancelRequestAnimationFrame, because some browsers (Firefix 4-10) have a request without a cancel\n\tcancelFrame = global[wcAF] || global[wcRAF];\n\tif (cancelFrame) {\n\t\t_cancelFrame = cancelFrame;\n\t\t_requestFrame = global[wrAF];\n\t\tif (p == 'webkit') {\n\t\t\t/*\n\t\t\t\tNote: In Chrome, the first return value of webkitRequestAnimationFrame is 0.\n\t\t\t\tWe make 1 bogus call so the first used return value of webkitRequestAnimationFrame is > 0, as the spec requires.\n\t\t\t\tThis makes it so that the requestId is always truthy.\n\t\t\t\t(we choose to do this rather than wrapping the native function to avoid the overhead)\n\t\t\t*/\n\t\t\t_cancelFrame(_requestFrame(utils.nop));\n\t\t}\n\t\tbreak;\n\t}\n}\n/**\n* Requests an animation callback.\n*\n* On compatible browsers, if `node` is defined, the [callback]{@glossary callback} will\n* fire only if `node` is visible.\n*\n* @param {Function} callback - A [callback]{@glossary callback} to be executed on the\n*                            animation frame.\n* @param {Node} node - The DOM node to request the animation frame for.\n* @returns {Object} A request id to be used with\n*                     {@link module:enyo/animation#cancelRequestAnimationFrame}.\n* @public\n*/\nexports.requestAnimationFrame = function(callback, node) {\n\treturn _requestFrame(callback, node);\n};\n/**\n* Cancels a requested animation callback with the specified id.\n*\n* @param {Number} id - The identifier of an animation request we wish to cancel.\n* @deprecated since 2.7.0\n* @public\n*/\nexports.cancelRequestAnimationFrame = function(id) {\n\treturn _cancelFrame(id);\n};\n/**\n* Cancels a requested animation callback with the specified id.\n*\n* @param {Number} id - The identifier of an animation request we wish to cancel.\n* @public\n*/\nexports.cancelAnimationFrame = function(id) {\n\treturn _cancelFrame(id);\n};\n\n/**\n* A set of interpolation functions for animations, similar in function to CSS3\n* transitions.\n*\n* These are intended for use with {@link module:enyo/animation#easedLerp}. Each easing function\n* accepts one (1) [Number]{@glossary Number} parameter and returns one (1)\n* [Number]{@glossary Number} value.\n*\n* @public\n*/\nexports.easing = /** @lends module:enyo/animation~easing.prototype */ {\n\t/**\n\t* cubicIn\n\t*\n\t* @public\n\t*/\n\tcubicIn: function(n) {\n\t\treturn Math.pow(n, 3);\n\t},\n\t/**\n\t* cubicOut\n\t*\n\t* @public\n\t*/\n\tcubicOut: function(n) {\n\t\treturn Math.pow(n - 1, 3) + 1;\n\t},\n\t/**\n\t* expoOut\n\t*\n\t* @public\n\t*/\n\texpoOut: function(n) {\n\t\treturn (n == 1) ? 1 : (-1 * Math.pow(2, -10 * n) + 1);\n\t},\n\t/**\n\t* quadInOut\n\t*\n\t* @public\n\t*/\n\tquadInOut: function(n) {\n\t\tn = n * 2;\n\t\tif (n < 1) {\n\t\t\treturn Math.pow(n, 2) / 2;\n\t\t}\n\t\treturn -1 * ((--n) * (n - 2) - 1) / 2;\n\t},\n\t/**\n\t* linear\n\t*\n\t* @public\n\t*/\n\tlinear: function(n) {\n\t\treturn n;\n\t}\n};\n\n/**\n* Gives an interpolation of an animated transition's distance from 0 to 1.\n*\n* Given a start time (`t0`) and an animation duration (`duration`), this\n* method applies the `easing` function to the percentage of time elapsed\n* divided by duration, capped at 100%.\n*\n* @param {Number} t0 - Start time.\n* @param {Number} duration - Duration in milliseconds.\n* @param {Function} easing - An easing [function]{@glossary Function} reference from\n*\t{@link module:enyo/animation#easing}.\n* @param {Boolean} reverse - Whether the animation will run in reverse.\n* @returns {Number} The resulting position, capped at a maximum of 100%.\n* @public\n*/\nexports.easedLerp = function(t0, duration, easing, reverse) {\n\tvar lerp = (utils.perfNow() - t0) / duration;\n\tif (reverse) {\n\t\treturn lerp >= 1 ? 0 : (1 - easing(1 - lerp));\n\t} else {\n\t\treturn lerp >= 1 ? 1 : easing(lerp);\n\t}\n};\n\n/**\n* Gives an interpolation of an animated transition's distance from\n* `startValue` to `valueChange`.\n*\n* Applies the `easing` function with a wider range of variables to allow for\n* more complex animations.\n*\n* @param {Number} t0 - Start time.\n* @param {Number} duration - Duration in milliseconds.\n* @param {Function} easing - An easing [function]{@glossary Function} reference from\n*\t{@link module:enyo/animation#easing}.\n* @param {Boolean} reverse - Whether the animation will run in reverse.\n* @param {Number} time\n* @param {Number} startValue - Starting value.\n* @param {Number} valueChange\n* @returns {Number} The resulting position, capped at a maximum of 100%.\n* @public\n*/\nexports.easedComplexLerp = function(t0, duration, easing, reverse, time, startValue, valueChange) {\n\tvar lerp = (utils.perfNow() - t0) / duration;\n\tif (reverse) {\n\t\treturn easing(1 - lerp, time, startValue, valueChange, duration);\n\t} else {\n\t\treturn easing(lerp, time, startValue, valueChange, duration);\n\t}\n};\n",
    "mtime": 1542469884623,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/animation.js",
    "relPath": "enyo/animation",
    "requires": [
      "enyo",
      "./platform",
      "./utils"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "enyo/kind",
    "base": "/home/udo/git/NCPV/src",
    "external": true,
    "relName": "enyo/kind",
    "name": "enyo/kind",
    "isFile": true,
    "contents": "require('enyo');\n\nvar\n\tlogger = require('./logger'),\n\tutils = require('./utils');\n\nvar defaultCtor = null;\n\n/**\n* Creates a JavaScript {@glossary constructor} function with\n* a prototype defined by `props`. **All constructors must have a unique name.**\n*\n* `kind()` makes it easy to build a constructor-with-prototype (like a\n* class) that has advanced features like prototype-chaining\n* ({@glossary inheritance}).\n*\n* A plug-in system is included for extending the abilities of the\n* {@glossary kind} generator, and constructors are allowed to\n* perform custom operations when subclassed.\n*\n* If you make changes to `enyo/kind`, be sure to add or update the appropriate\n* [unit tests](@link https://github.com/enyojs/enyo/tree/master/tools/test/core/tests).\n*\n* For more information, see the documentation on\n* [Kinds]{@linkplain $dev-guide/key-concepts/kinds.html} in the Enyo Developer Guide.\n*\n* @module enyo/kind\n* @param {Object} props - A [hash]{@glossary Object} of properties used to define and create\n*\tthe {@glossary kind}\n* @public\n*/\n/*jshint -W120*/\nvar kind = exports = module.exports = function (props) {\n/*jshint +W120*/\n\t// extract 'name' property\n\tvar name = props.name || '';\n\tdelete props.name;\n\t// extract 'kind' property\n\tvar hasKind = ('kind' in props);\n\tvar kindName = props.kind;\n\tdelete props.kind;\n\t// establish base class reference\n\tvar base = constructorForKind(kindName);\n\tvar isa = base && base.prototype || null;\n\t// if we have an explicit kind property with value undefined, we probably\n\t// tried to reference a kind that is not yet in scope\n\tif (hasKind && kindName === undefined || base === undefined) {\n\t\tvar problem = kindName === undefined ? 'undefined kind' : 'unknown kind (' + kindName + ')';\n\t\tthrow 'enyo.kind: Attempt to subclass an ' + problem + '. Check dependencies for [' + (name || '<unnamed>') + '].';\n\t}\n\t// make a boilerplate constructor\n\tvar ctor = kind.makeCtor();\n\t// semi-reserved word 'constructor' causes problems with Prototype and IE, so we rename it here\n\tif (props.hasOwnProperty('constructor')) {\n\t\tprops._constructor = props.constructor;\n\t\tdelete props.constructor;\n\t}\n\t// create our prototype\n\t//ctor.prototype = isa ? enyo.delegate(isa) : {};\n\tutils.setPrototype(ctor, isa ? utils.delegate(isa) : {});\n\t// there are special cases where a base class has a property\n\t// that may need to be concatenated with a subclasses implementation\n\t// as opposed to completely overwriting it...\n\tkind.concatHandler(ctor, props);\n\n\t// put in our props\n\tutils.mixin(ctor.prototype, props);\n\t// alias class name as 'kind' in the prototype\n\t// but we actually only need to set this if a new name was used,\n\t// not if it is inheriting from a kind anonymously\n\tif (name) {\n\t\tctor.prototype.kindName = name;\n\t}\n\t// this is for anonymous constructors\n\telse {\n\t\tctor.prototype.kindName = base && base.prototype? base.prototype.kindName: '';\n\t}\n\t// cache superclass constructor\n\tctor.prototype.base = base;\n\t// reference our real constructor\n\tctor.prototype.ctor = ctor;\n\t// support pluggable 'features'\n\tutils.forEach(kind.features, function(fn){ fn(ctor, props); });\n\t\n\tif (name) kindCtors[name] = ctor;\n\t\n\treturn ctor;\n};\n\nexports.setDefaultCtor = function (ctor) {\n\tdefaultCtor = ctor;\n};\n\nvar getDefaultCtor = exports.getDefaultCtor = function () {\n\treturn defaultCtor;\n};\n\n/**\n* @private\n*/\nvar concatenated = exports.concatenated = [];\n\n/**\n* Creates a singleton of a given {@glossary kind} with a given\n* definition. **The `name` property will be the instance name of the singleton\n* and must be unique.**\n*\n* ```javascript\n* var\n* \tkind = require('enyo/kind'),\n* \tControl = require('enyo/Control');\n*\n* module.exports = singleton({\n* \tkind: Control,\n* \tname: 'app.MySingleton',\n* \tpublished: {\n* \t\tvalue: 'foo'\n* \t},\n* \tmakeSomething: function() {\n* \t\t//...\n* \t}\n* });\n*\n* app.MySingleton.makeSomething();\n* app.MySingleton.setValue('bar');\n*```\n*\n* @public\n*/\nexports.singleton = function (conf) {\n\t// extract 'name' property (the name of our singleton)\n\tdelete(conf.name);\n\t// create an unnamed kind and save its constructor's function\n\tvar Kind = kind(conf);\n\tvar inst = new Kind();\n\treturn inst;\n};\n\n/**\n* @name module:enyo/kind.makeCtor\n* @method\n* @private\n*/\nkind.makeCtor = function () {\n\tvar enyoConstructor = function () {\n\t\tif (!(this instanceof enyoConstructor)) {\n\t\t\tthrow 'enyo.kind: constructor called directly, not using \"new\"';\n\t\t}\n\n\t\t// two-pass instantiation\n\t\tvar result;\n\t\tif (this._constructor) {\n\t\t\t// pure construction\n\t\t\tresult = this._constructor.apply(this, arguments);\n\t\t}\n\t\t// defer initialization until entire constructor chain has finished\n\t\tif (this.constructed) {\n\t\t\t// post-constructor initialization\n\t\t\tthis.constructed.apply(this, arguments);\n\t\t}\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t};\n\treturn enyoConstructor;\n};\n\n/**\n* Feature hooks for the oop system\n*\n* @name module:enyo/kind.features\n* @private\n*/\nkind.features = [];\n\n/**\n* Used internally by several mechanisms to allow safe and normalized handling for extending a\n* [kind's]{@glossary kind} super-methods. It can take a\n* [constructor]{@glossary constructor}, a [prototype]{@glossary Object.prototype}, or an\n* instance.\n*\n* @name module:enyo/kind.extendMethods\n* @method\n* @private\n*/\nkind.extendMethods = function (ctor, props, add) {\n\tvar proto = ctor.prototype || ctor,\n\t\tb = proto.base;\n\tif (!proto.inherited && b) {\n\t\tproto.inherited = kind.inherited;\n\t}\n\t// rename constructor to _constructor to work around IE8/Prototype problems\n\tif (props.hasOwnProperty('constructor')) {\n\t\tprops._constructor = props.constructor;\n\t\tdelete props.constructor;\n\t}\n\t// decorate function properties to support inherited (do this ex post facto so that\n\t// ctor.prototype is known, relies on elements in props being copied by reference)\n\tfor (var n in props) {\n\t\tvar p = props[n];\n\t\tif (isInherited(p)) {\n\t\t\t// ensure that if there isn't actually a super method to call, it won't\n\t\t\t// fail miserably - while this shouldn't happen often, it is a sanity\n\t\t\t// check for mixin-extensions for kinds\n\t\t\tif (add) {\n\t\t\t\tp = proto[n] = p.fn(proto[n] || utils.nop);\n\t\t\t} else {\n\t\t\t\tp = proto[n] = p.fn(b? (b.prototype[n] || utils.nop): utils.nop);\n\t\t\t}\n\t\t}\n\t\tif (utils.isFunction(p)) {\n\t\t\tif (add) {\n\t\t\t\tproto[n] = p;\n\t\t\t\tp.displayName = n + '()';\n\t\t\t} else {\n\t\t\t\tp._inherited = b? b.prototype[n]: null;\n\t\t\t\t// FIXME: we used to need some extra values for inherited, then inherited got cleaner\n\t\t\t\t// but in the meantime we used these values to support logging in Object.\n\t\t\t\t// For now we support this legacy situation, by suppling logging information here.\n\t\t\t\tp.displayName = proto.kindName + '.' + n + '()';\n\t\t\t}\n\t\t}\n\t}\n};\nkind.features.push(kind.extendMethods);\n\n/**\n* Called by {@link module:enyo/CoreObject~Object} instances attempting to access super-methods\n* of a parent class ([kind]{@glossary kind}) by calling\n* `this.inherited(arguments)` from within a kind method. This can only be done\n* safely when there is known to be a super class with the same method.\n*\n* @name module:enyo/kind.inherited\n* @method\n* @private\n*/\nkind.inherited = function (originals, replacements) {\n\t// one-off methods are the fast track\n\tvar target = originals.callee;\n\tvar fn = target._inherited;\n\n\t// regardless of how we got here, just ensure we actually\n\t// have a function to call or else we throw a console\n\t// warning to notify developers they are calling a\n\t// super method that doesn't exist\n\tif ('function' === typeof fn) {\n\t\tvar args = originals;\n\t\tif (replacements) {\n\t\t\t// combine the two arrays, with the replacements taking the first\n\t\t\t// set of arguments, and originals filling up the rest.\n\t\t\targs = [];\n\t\t\tvar i = 0, l = replacements.length;\n\t\t\tfor (; i < l; ++i) {\n\t\t\t\targs[i] = replacements[i];\n\t\t\t}\n\t\t\tl = originals.length;\n\t\t\tfor (; i < l; ++i) {\n\t\t\t\targs[i] = originals[i];\n\t\t\t}\n\t\t}\n\t\treturn fn.apply(this, args);\n\t} else {\n\t\tlogger.warn('enyo.kind.inherited: unable to find requested ' +\n\t\t\t'super-method from -> ' + originals.callee.displayName + ' in ' + this.kindName);\n\t}\n};\n\n// dcl inspired super-inheritance\n\nvar Inherited = function (fn) {\n\tthis.fn = fn;\n};\n\n/**\n* When defining a method that overrides an existing method in a [kind]{@glossary kind}, you\n* can wrap the definition in this function and it will decorate it appropriately for inheritance\n* to work.\n*\n* The older `this.inherited(arguments)` method still works, but this version results in much\n* faster code and is the only one supported for kind [mixins]{@glossary mixin}.\n*\n* @param {Function} fn - A [function]{@glossary Function} that takes a single\n*   argument (usually named `sup`) and returns a function where\n*   `sup.apply(this, arguments)` is used as a mechanism to make the\n*   super-call.\n* @public\n*/\nexports.inherit = function (fn) {\n\treturn new Inherited(fn);\n};\n\n/**\n* @private\n*/\nvar isInherited = exports.isInherited = function (fn) {\n\treturn fn && (fn instanceof Inherited);\n};\n\n\n//\n// 'statics' feature\n//\nkind.features.push(function(ctor, props) {\n\t// install common statics\n\tif (!ctor.subclass) {\n\t\tctor.subclass = kind.statics.subclass;\n\t}\n\tif (!ctor.extend) {\n\t\tctor.extend = kind.statics.extend;\n\t}\n\tif (!ctor.kind) {\n\t\tctor.kind = kind.statics.kind;\n\t}\n\t// move props statics to constructor\n\tif (props.statics) {\n\t\tutils.mixin(ctor, props.statics);\n\t\tdelete ctor.prototype.statics;\n\t}\n\t// also support protectedStatics which won't interfere with defer\n\tif (props.protectedStatics) {\n\t\tutils.mixin(ctor, props.protectedStatics);\n\t\tdelete ctor.prototype.protectedStatics;\n\t}\n\t// allow superclass customization\n\tvar base = ctor.prototype.base;\n\twhile (base) {\n\t\tbase.subclass(ctor, props);\n\t\tbase = base.prototype.base;\n\t}\n});\n\n/**\n* @private\n*/\nkind.statics = {\n\n\t/**\n\t* A [kind]{@glossary kind} may set its own `subclass()` method as a\n\t* static method for its [constructor]{@glossary constructor}. Whenever\n\t* it is subclassed, the constructor and properties will be passed through\n\t* this method for special handling of important features.\n\t*\n\t* @name module:enyo/kind.subclass\n\t* @method\n\t* @param {Function} ctor - The [constructor]{@glossary constructor} of the\n\t*\t[kind]{@glossary kind} being subclassed.\n\t* @param {Object} props - The properties of the kind being subclassed.\n\t* @public\n\t*/\n\tsubclass: function (ctor, props) {},\n\n\t/**\n\t* Allows for extension of the current [kind]{@glossary kind} without\n\t* creating a new kind. This method is available on all\n\t* [constructors]{@glossary constructor}, although calling it on a\n\t* [deferred]{@glossary deferred} constructor will force it to be\n\t* resolved at that time. This method does not re-run the\n\t* {@link module:enyo/kind.features} against the constructor or instance.\n\t*\n\t* @name module:enyo/kind.extend\n\t* @method\n\t* @param {Object|Object[]} props A [hash]{@glossary Object} or [array]{@glossary Array}\n\t*\tof [hashes]{@glossary Object}. Properties will override\n\t*\t[prototype]{@glossary Object.prototype} properties. If a\n\t*\tmethod that is being added already exists, the new method will\n\t*\tsupersede the existing one. The method may call\n\t*\t`this.inherited()` or be wrapped with `kind.inherit()` to call\n\t*\tthe original method (this chains multiple methods tied to a\n\t*\tsingle [kind]{@glossary kind}).\n\t* @param {Object} [target] - The instance to be extended. If this is not specified, then the\n\t*\t[constructor]{@glossary constructor} of the\n\t*\t[object]{@glossary Object} this method is being called on will\n\t*\tbe extended.\n\t* @returns {Object} The constructor of the class, or specific\n\t*\tinstance, that has been extended.\n\t* @public\n\t*/\n\textend: function (props, target) {\n\t\tvar ctor = this\n\t\t\t, exts = utils.isArray(props)? props: [props]\n\t\t\t, proto, fn;\n\n\t\tfn = function (key, value) {\n\t\t\treturn !(typeof value == 'function' || isInherited(value)) && concatenated.indexOf(key) === -1;\n\t\t};\n\n\t\tproto = target || ctor.prototype;\n\t\tfor (var i=0, ext; (ext=exts[i]); ++i) {\n\t\t\tkind.concatHandler(proto, ext, true);\n\t\t\tkind.extendMethods(proto, ext, true);\n\t\t\tutils.mixin(proto, ext, {filter: fn});\n\t\t}\n\n\t\treturn target || ctor;\n\t},\n\n\t/**\n\t* Creates a new sub-[kind]{@glossary kind} of the current kind.\n\t*\n\t* @name module:enyo/kind.kind\n\t* @method\n\t* @param  {Object} props A [hash]{@glossary Object} of properties used to define and create\n\t*\tthe [kind]{@glossary kind}\n\t* @return {Function} Constructor of the new kind\n\t* @public\n\t*/\n\tkind: function (props) {\n\t\tif (props.kind && props.kind !== this) {\n\t\t\tlogger.warn('Creating a different kind from a constructor\\'s kind() method is not ' +\n\t\t\t\t'supported and will be replaced with the constructor.');\n\t\t}\n\t\tprops.kind = this;\n\t\treturn kind(props);\n\t}\n};\n\n/**\n* @method\n* @private\n*/\nexports.concatHandler = function (ctor, props, instance) {\n\tvar proto = ctor.prototype || ctor\n\t\t, base = proto.ctor;\n\n\twhile (base) {\n\t\tif (base.concat) base.concat(ctor, props, instance);\n\t\tbase = base.prototype.base;\n\t}\n};\n\nvar kindCtors =\n/**\n* Factory for [kinds]{@glossary kind} identified by [strings]{@glossary String}.\n*\n* @type Object\n* @deprecated Since 2.6.0\n* @private\n*/\n\texports._kindCtors = {};\n\n/**\n* @method\n* @private\n*/\nvar constructorForKind = exports.constructorForKind = function (kind) {\n\tif (kind === null) {\n\t\treturn kind;\n\t} else if (kind === undefined) {\n\t\treturn getDefaultCtor();\n\t}\n\telse if (utils.isFunction(kind)) {\n\t\treturn kind;\n\t}\n\tlogger.warn('Creating instances by name is deprecated. Name used:', kind);\n\t// use memoized constructor if available...\n\tvar ctor = kindCtors[kind];\n\tif (ctor) {\n\t\treturn ctor;\n\t}\n\t// otherwise look it up and memoize what we find\n\t//\n\t// if kind is an object in enyo, say \"Control\", then ctor = enyo[\"Control\"]\n\t// if kind is a path under enyo, say \"Heritage.Button\", then ctor = enyo[\"Heritage.Button\"] || enyo.Heritage.Button\n\t// if kind is a fully qualified path, say \"enyo.Heritage.Button\", then ctor = enyo[\"enyo.Heritage.Button\"] || enyo.enyo.Heritage.Button || enyo.Heritage.Button\n\t//\n\t// Note that kind \"Foo\" will resolve to enyo.Foo before resolving to global \"Foo\".\n\t// This is important so \"Image\" will map to built-in Image object, instead of enyo.Image control.\n\tctor = Theme[kind] || (global.enyo && global.enyo[kind]) || utils.getPath.call(global, 'enyo.' + kind) || global[kind] || utils.getPath.call(global, kind);\n\n\t// If what we found at this namespace isn't a function, it's definitely not a kind constructor\n\tif (!utils.isFunction(ctor)) {\n\t\tthrow '[' + kind + '] is not the name of a valid kind.';\n\t}\n\tkindCtors[kind] = ctor;\n\treturn ctor;\n};\n\n/**\n* Namespace for current theme (`enyo.Theme.Button` references the Button specialization for the\n* current theme).\n*\n* @deprecated Since 2.6.0\n* @private\n*/\nvar Theme = exports.Theme = {};\n\n/**\n* @method\n* @deprecated Since 2.6.0\n* @private\n*/\nexports.registerTheme = function (ns) {\n\tutils.mixin(Theme, ns);\n};\n\n/**\n* @method\n* @private\n*/\nexports.createFromKind = function (nom, param) {\n\tvar Ctor = nom && constructorForKind(nom);\n\tif (Ctor) {\n\t\treturn new Ctor(param);\n\t}\n};\n",
    "mtime": 1542469884675,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/kind.js",
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relPath": "enyo/kind",
    "requires": [
      "enyo",
      "./logger",
      "./utils"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "../HTMLStringDelegate",
    "base": "/home/udo/git/NCPV/lib/enyo/src/Control",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/HTMLStringDelegate",
    "name": "enyo/HTMLStringDelegate",
    "isFile": true,
    "contents": "require('enyo');\n\nvar\n\tDom = require('./dom');\n\nvar selfClosing = {img: 1, hr: 1, br: 1, area: 1, base: 1, basefont: 1, input: 1, link: 1,\n\tmeta: 1, command: 1, embed: 1, keygen: 1, wbr: 1, param: 1, source: 1, track: 1, col: 1};\n\n/**\n* This is the default render delegate used by {@link module:enyo/Control~Control}. It\n* generates the HTML [string]{@glossary String} content and correctly inserts\n* it into the DOM. A string-concatenation technique is used to perform DOM\n* insertion in batches.\n*\n* @module enyo/HTMLStringDelegate\n* @public\n*/\nmodule.exports = {\n\t\n\t/**\n\t* @private\n\t*/\n\tinvalidate: function (control, item) {\n\t\tswitch (item) {\n\t\tcase 'content':\n\t\t\tthis.renderContent(control);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontrol.tagsValid = false;\n\t\t\tbreak;\n\t\t}\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\trender: function (control) {\n\t\tif (control.parent) {\n\t\t\tcontrol.parent.beforeChildRender(control);\n\t\t\t\n\t\t\tif (!control.parent.generated) return;\n\t\t\tif (control.tag === null) return control.parent.render();\n\t\t}\n\t\t\n\t\tif (!control.hasNode()) this.renderNode(control);\n\t\tif (control.hasNode()) {\n\t\t\tthis.renderDom(control);\n\t\t\tif (control.generated) control.rendered();\n\t\t}\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\trenderInto: function (control, parentNode) {\n\t\tparentNode.innerHTML = this.generateHtml(control);\n\t\t\n\t\tif (control.generated) control.rendered();\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\trenderNode: function (control) {\n\t\tthis.teardownRender(control);\n\t\tcontrol.node = document.createElement(control.tag);\n\t\tcontrol.addNodeToParent();\n\t\tcontrol.set('generated', true);\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\trenderDom: function (control) {\n\t\tthis.renderAttributes(control);\n\t\tthis.renderStyles(control);\n\t\tthis.renderContent(control);\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\trenderStyles: function (control) {\n\t\tvar style = control.style;\n\t\t\n\t\t// we can safely do this knowing it will synchronize properly without a double\n\t\t// set in the DOM because we're flagging the internal property\n\t\tif (control.hasNode()) {\n\t\t\tcontrol.node.style.cssText = style;\n\t\t\t// retrieve the parsed value for synchronization\n\t\t\tcontrol.cssText = style = control.node.style.cssText;\n\t\t\t// now we set it knowing they will be synchronized and everybody that is listening\n\t\t\t// will also be updated to know about the change\n\t\t\tcontrol.set('style', style);\n\t\t}\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\trenderAttributes: function (control) {\n\t\tvar attrs = control.attributes,\n\t\t\tnode = control.hasNode(),\n\t\t\tkey,\n\t\t\tval;\n\t\t\n\t\tif (node) {\n\t\t\tfor (key in attrs) {\n\t\t\t\tval = attrs[key];\n\t\t\t\tif (val === null || val === false || val === \"\") {\n\t\t\t\t\tnode.removeAttribute(key);\n\t\t\t\t} else {\n\t\t\t\t\tnode.setAttribute(key, val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\trenderContent: function (control) {\n\t\tif (control.generated) this.teardownChildren(control);\n\t\tif (control.hasNode()) control.node.innerHTML = this.generateInnerHtml(control);\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tgenerateHtml: function (control) {\n\t\tvar content,\n\t\t\thtml;\n\t\t\n\t\tif (control.canGenerate === false) {\n\t\t\treturn '';\n\t\t}\n\t\t// do this first in case content generation affects outer html (styles or attributes)\n\t\tcontent = this.generateInnerHtml(control);\n\t\t// generate tag, styles, attributes\n\t\thtml = this.generateOuterHtml(control, content);\n\t\t// NOTE: 'generated' is used to gate access to findNodeById in\n\t\t// hasNode, because findNodeById is expensive.\n\t\t// NOTE: we typically use 'generated' to mean 'created in DOM'\n\t\t// but that has not actually happened at this point.\n\t\t// We set 'generated = true' here anyway to avoid having to walk the\n\t\t// control tree a second time (to set it later).\n\t\t// The contract is that insertion in DOM will happen synchronously\n\t\t// to generateHtml() and before anybody should be calling hasNode().\n\t\tcontrol.set('generated', true);\n\t\treturn html;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tgenerateOuterHtml: function (control, content) {\n\t\tif (!control.tag) return content;\n\t\tif (!control.tagsValid) this.prepareTags(control);\n\t\treturn control._openTag + content + control._closeTag;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tgenerateInnerHtml: function (control) {\n\t\tvar allowHtml = control.allowHtml,\n\t\t\tcontent;\n\t\t\n\t\t// flow can alter the way that html content is rendered inside\n\t\t// the container regardless of whether there are children.\n\t\tcontrol.flow();\n\t\tif (control.children.length) return this.generateChildHtml(control);\n\t\telse {\n\t\t\tcontent = control.get('content');\n\t\t\treturn allowHtml ? content : Dom.escape(content);\n\t\t}\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tgenerateChildHtml: function (control) {\n\t\tvar child,\n\t\t\thtml = '',\n\t\t\ti = 0,\n\t\t\tdelegate;\n\t\t\n\t\tfor (; (child = control.children[i]); ++i) {\n\t\t\tdelegate = child.renderDelegate || this;\n\t\t\thtml += delegate.generateHtml(child);\n\t\t}\n\t\t\n\t\treturn html;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tprepareTags: function (control) {\n\t\tvar html = '';\n\t\t\n\t\t// open tag\n\t\thtml += '<' + control.tag + (control.style ? ' style=\"' + control.style + '\"' : '');\n\t\thtml += this.attributesToHtml(control.attributes);\n\t\tif (selfClosing[control.tag]) {\n\t\t\tcontrol._openTag = html + '/>';\n\t\t\tcontrol._closeTag = '';\n\t\t} else {\n\t\t\tcontrol._openTag = html + '>';\n\t\t\tcontrol._closeTag = '</' + control.tag + '>';\n\t\t}\n\t\t\n\t\tcontrol.tagsValid = true;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tattributesToHtml: function(attrs) {\n\t\tvar key,\n\t\t\tval,\n\t\t\thtml = '';\n\t\t\t\n\t\tfor (key in attrs) {\n\t\t\tval = attrs[key];\n\t\t\tif (val != null && val !== false && val !== '') {\n\t\t\t\thtml += ' ' + key + '=\"' + this.escapeAttribute(val) + '\"';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn html;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tescapeAttribute: function (text) {\n\t\tif (typeof text != 'string') return text;\n\t\n\t\treturn String(text).replace(/&/g, '&amp;').replace(/\\\"/g, '&quot;');\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tteardownRender: function (control, cache) {\n\t\tif (control.generated) {\n\t\t\tif (typeof control.beforeTeardown === 'function') {\n\t\t\t\tcontrol.beforeTeardown();\n\t\t\t}\n\t\t\tthis.teardownChildren(control, cache);\n\t\t}\n\t\t\t\n\t\tcontrol.node = null;\n\t\tcontrol.set('generated', false);\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tteardownChildren: function (control, cache) {\n\t\tvar child,\n\t\t\ti = 0;\n\n\t\tfor (; (child = control.children[i]); ++i) {\n\t\t\tchild.teardownRender(cache);\n\t\t}\n\t}\n};\n",
    "mtime": 1542469884183,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/HTMLStringDelegate.js",
    "relPath": "enyo/HTMLStringDelegate",
    "requires": [
      "enyo",
      "./dom"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./util",
    "base": "/home/udo/git/NCPV/lib/enyo/src/gesture",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/gesture/util",
    "name": "enyo/gesture/util",
    "isFile": true,
    "contents": "var\n\tdom = require('../dom'),\n\tplatform = require('../platform'),\n\tutils = require('../utils');\n\n/**\n* Used internally by {@link module:enyo/gesture}\n*\n* @module enyo/gesture/util\n* @private\n*/\nmodule.exports = {\n\n\t/**\n\t* @private\n\t*/\n\teventProps: ['target', 'relatedTarget', 'clientX', 'clientY', 'pageX', 'pageY',\n\t\t'screenX', 'screenY', 'altKey', 'ctrlKey', 'metaKey', 'shiftKey',\n\t\t'detail', 'identifier', 'dispatchTarget', 'which', 'srcEvent'],\n\n\t/**\n\t* Creates an {@glossary event} of type `type` and returns it.\n\t* `evt` should be an event [object]{@glossary Object}.\n\t*\n\t* @param {String} type - The type of {@glossary event} to make.\n\t* @param {(Event|Object)} evt - The event you'd like to clone or an object that looks like it.\n\t* @returns {Object} The new event [object]{@glossary Object}.\n\t* @public\n\t*/\n\tmakeEvent: function(type, evt) {\n\t\tvar e = {};\n\t\te.type = type;\n\t\tfor (var i=0, p; (p=this.eventProps[i]); i++) {\n\t\t\te[p] = evt[p];\n\t\t}\n\t\te.srcEvent = e.srcEvent || evt;\n\t\te.preventDefault = this.preventDefault;\n\t\te.disablePrevention = this.disablePrevention;\n\n\t\tif (dom._bodyScaleFactorX !== 1 || dom._bodyScaleFactorY !== 1) {\n\t\t\t// Intercept only these events, not all events, like: hold, release, tap, etc,\n\t\t\t// to avoid doing the operation again.\n\t\t\tif (e.type == 'move' || e.type == 'up' || e.type == 'down' || e.type == 'enter' || e.type == 'leave') {\n\t\t\t\te.clientX *= dom._bodyScaleFactorX;\n\t\t\t\te.clientY *= dom._bodyScaleFactorY;\n\t\t\t}\n\t\t}\n\t\t//\n\t\t// normalize event.which and event.pageX/event.pageY\n\t\t// Note that while 'which' works in IE9, it is broken for mousemove. Therefore,\n\t\t// in IE, use global.event.button\n\t\tif (platform.ie < 10) {\n\t\t\tvar b = global.event && global.event.button;\n\t\t\tif (b) {\n\t\t\t\t// multi-button not supported, priority: left, right, middle\n\t\t\t\t// (note: IE bitmask is 1=left, 2=right, 4=center);\n\t\t\t\te.which = b & 1 ? 1 : (b & 2 ? 2 : (b & 4 ? 3 : 0));\n\t\t\t}\n\t\t} else if (platform.webos || global.PalmSystem) {\n\t\t\t// Temporary fix for owos: it does not currently supply 'which' on move events\n\t\t\t// and the user agent string doesn't identify itself so we test for PalmSystem\n\t\t\tif (e.which === 0) {\n\t\t\t\te.which = 1;\n\t\t\t}\n\t\t}\n\t\treturn e;\n\t},\n\n\t/**\n\t* Installed on [events]{@glossary event} and called in event context.\n\t*\n\t* @private\n\t*/\n\tpreventDefault: function() {\n\t\tif (this.srcEvent) {\n\t\t\tthis.srcEvent.preventDefault();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdisablePrevention: function() {\n\t\tthis.preventDefault = utils.nop;\n\t\tif (this.srcEvent) {\n\t\t\tthis.srcEvent.preventDefault = utils.nop;\n\t\t}\n\t}\n};\n",
    "mtime": 1542469884655,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/gesture/util.js",
    "relPath": "enyo/gesture/util",
    "requires": [
      "../dom",
      "../platform",
      "../utils"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./MixinSupport",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/MixinSupport",
    "name": "enyo/MixinSupport",
    "isFile": true,
    "contents": "/**\n* Exports the {@link module:enyo/MixinSupport~MixinSupport} mixin.\n* @module enyo/MixinSupport\n*/\n\nrequire('enyo');\n\n\nvar\n\tutils = require('./utils'),\n\tkind = require('./kind'),\n\tlogger = require('./logger');\n\nkind.concatenated.push('mixins');\n\nvar sup = kind.statics.extend;\n\nvar extend = kind.statics.extend = function extend (args, target) {\n\tif (utils.isArray(args)) return utils.forEach(args, function (ln) { extend.call(this, ln, target); }, this);\n\tif (typeof args == 'string') apply(target || this.prototype, args);\n\telse {\n\t\tif (args.mixins) feature(target || this, args);\n\t\n\t\t// this allows for mixins to apply mixins which...is less than ideal but possible\n\t\tif (args.name) apply(target || this.prototype, args);\n\t\telse sup.apply(this, arguments);\n\t}\n};\n\n/*\n* Applies, with safeguards, a given mixin to an object.\n*/\nfunction apply (proto, props) {\n\tvar applied = proto._mixins? (proto._mixins = proto._mixins.slice()): (proto._mixins = [])\n\t\t, name = utils.isString(props)? props: props.name\n\t\t, idx = utils.indexOf(name, applied);\n\tif (idx < 0) {\n\t\tname == props && (props = utils.getPath(name));\n\t\t// if we could not resolve the requested mixin (should never happen)\n\t\t// we throw a simple little error\n\t\t// @TODO: Normalize error format\n\t\t!props && logger.error('Could not find the mixin ' + name);\n\t\t\n\t\t// it should be noted that this ensures it won't recursively re-add the same mixin but\n\t\t// since it is possible for mixins to apply mixins the names will be out of order\n\t\t// this name is pushed on but the nested mixins are applied before this one\n\t\tname && applied.push(name);\n\t\t\n\t\tprops = utils.clone(props);\n\t\t\n\t\t// we need to temporarily move the constructor if it has one so it\n\t\t// will override the correct method - this is a one-time permanent\n\t\t// runtime operation so subsequent additions of the mixin don't require\n\t\t// it again\n\t\tif (props.hasOwnProperty('constructor')) {\n\t\t\tprops._constructor = props.constructor;\n\t\t\tdelete props.constructor;\n\t\t}\n\t\t\n\t\tdelete props.name;\n\t\textend(props, proto);\n\t\t\n\t\t// now put it all back the way it was\n\t\tprops.name = name;\n\t}\n}\n\nfunction feature (ctor, props) {\n\tif (props.mixins) {\n\t\tvar proto = ctor.prototype || ctor\n\t\t\t, mixins = props.mixins;\n\t\t\n\t\t// delete props.mixins;\n\t\t// delete proto.mixins;\n\t\t\n\t\tproto._mixins && (proto._mixins = proto._mixins.slice());\n\t\tutils.forEach(mixins, function (ln) { apply(proto, ln); });\n\t}\n}\n\nkind.features.push(feature);\n\n/**\n* An internally-used support {@glossary mixin} that adds API methods to aid in\n* using and applying mixins to [kinds]{@glossary kind}.\n*\n* @mixin\n* @protected\n*/\nvar MixinSupport = {\n\t\n\t/**\n\t* @private\n\t*/\n\tname: 'MixinSupport',\n\t\n\t/**\n\t* Extends the instance with the given properties.\n\t*\n\t* @param {Object} props - The property [hash]{@glossary Object} from which to extend\n\t*\tthe callee.\n\t*/\n\textend: function (props) {\n\t\tprops && apply(this, props);\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\timportProps: kind.inherit(function (sup) {\n\t\treturn function (props) {\n\t\t\tprops && props.mixins && feature(this, props);\n\t\t\t\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t})\n};\n\nmodule.exports = MixinSupport;\n",
    "mtime": 1542469884271,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/MixinSupport.js",
    "relPath": "enyo/MixinSupport",
    "requires": [
      "enyo",
      "./utils",
      "./kind",
      "./logger"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./LinkedListNode",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/LinkedListNode",
    "name": "enyo/LinkedListNode",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/LinkedListNode~LinkedListNode} kind.\n* @module enyo/LinkedListNode\n*/\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils');\n\n/**\n* An abstract linked-list node.\n*\n* @class LinkedListNode\n* @private\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/LinkedListNode~LinkedListNode.prototype */ {\n\t\n\t/**\n\t* @private\n\t*/\n\tkind: null,\n\t\n\t/**\n\t* @private\n\t*/\n\n\t\n\t/**\n\t* @private\n\t*/\n\tprev: null,\n\t\n\t/**\n\t* @private\n\t*/\n\tnext: null,\n\t\n\t/**\n\t* @private\n\t*/\n\tcopy: function () {\n\t\tvar cpy = new this.ctor();\n\t\tcpy.prev = this.prev;\n\t\tcpy.next = this.next;\n\t\treturn cpy;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tconstructor: function (props) {\n\t\tprops && utils.mixin(this, props);\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tdestroy: function () {\n\t\t// clear reference to previous node\n\t\tthis.prev = null;\n\t\t\n\t\t// if we have a reference to our next node\n\t\t// we continue down the chain\n\t\tthis.next && this.next.destroy();\n\t\t\n\t\t// clear our reference to the next node\n\t\tthis.next = null;\n\t}\n});\n",
    "mtime": 1542469884247,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/LinkedListNode.js",
    "relPath": "enyo/LinkedListNode",
    "requires": [
      "enyo",
      "./kind",
      "./utils"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./Binding",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/Binding",
    "name": "enyo/Binding",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/Binding~Binding} kind.\n* @module enyo/Binding\n*/\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils');\n\nvar bindings = [];\n\nvar DIRTY_FROM = 0x01\n\t, DIRTY_TO = 0x02;\n\n/**\n* Used to determine if an {@link module:enyo/Binding~Binding} is actually ready.\n*\n* @private\n*/\nfunction ready (binding) {\n\tvar rdy = binding.ready;\n\t\n\tif (!rdy) {\n\t\t\n\t\tvar from = binding.from || '',\n\t\t\tto = binding.to || '',\n\t\t\tsource = binding.source,\n\t\t\ttarget = binding.target,\n\t\t\towner = binding.owner,\n\t\t\ttwoWay = !binding.oneWay,\n\t\t\ttoTarget;\n\t\t\n\t\tif (typeof from != 'string') from = '';\n\t\tif (typeof to != 'string') to = '';\n\t\t\n\t\tif (!source) {\n\t\t\t\n\t\t\t// the worst case scenario here is for backward compatibility purposes\n\t\t\t// we have to at least be able to derive the source via the from string\n\t\t\tif (from[0] == '^') {\n\t\t\t\t\n\t\t\t\t// this means we're reaching for a global\n\t\t\t\tvar fromParts = from.split('.');\n\t\t\t\tfrom = fromParts.pop();\n\t\t\t\tsource = utils.getPath.call(global, fromParts.join('.').slice(1));\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tsource = owner;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif (!target) {\n\t\t\t\n\t\t\t// same worst case as above, for backwards compatibility purposes\n\t\t\t// we have to at least be able to derive the target via the to string\n\t\t\tif (to[0] == '^') {\n\t\t\t\t\n\t\t\t\t// this means we're reaching for a global\n\t\t\t\tvar toParts = to.split('.');\n\t\t\t\tto = toParts.pop();\n\t\t\t\ttarget = utils.getPath.call(global, toParts.join('.').slice(1));\n\t\t\t} else {\n\t\t\t\ttarget = owner;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// we do this so we don't overwrite the originals in case we need to reset later\n\t\tbinding._target = target;\n\t\tbinding._source = source;\n\t\tbinding._from = from[0] == '.'? from.slice(1): from;\n\t\tbinding._to = to[0] == '.'? to.slice(1): to;\n\t\t\n\t\tif (!twoWay) {\n\t\t\ttoTarget = binding._to.split('.');\n\t\t\tif (toTarget.length > 2) {\n\t\t\t\ttoTarget.pop();\n\t\t\t\tbinding._toTarget = toTarget.join('.');\n\t\t\t}\n\t\t}\n\t\t\n\t\t// now our sanitization\n\t\trdy = !! (\n\t\t\t(source && (typeof source == 'object')) &&\n\t\t\t(target && (typeof target == 'object')) &&\n\t\t\t(from) &&\n\t\t\t(to)\n\t\t);\n\t}\n\t\n\t/*jshint -W093 */\n\treturn (binding.ready = rdy);\n\t/*jshint +W093 */\n}\n\n\n/**\n* @class PassiveBinding\n* @public\n*/\nvar PassiveBinding = kind(\n\t/** @lends module:enyo/Binding~PassiveBinding.prototype */ {\n\t\n\tname: 'enyo.PassiveBinding',\n\t\n\t/**\n\t* @private\n\t*/\n\tkind: null,\n\t\n\t/**\n\t* This property is used extensively for various purposes within a\n\t* [binding]{@link module:enyo/Binding~Binding}. One primary purpose is to serve as a root\n\t* [object]{@glossary Object} from which to\tsearch for the binding's ends (the\n\t* [source]{@link module:enyo/Binding~Binding#source} and/or [target]{@link module:enyo/Binding~Binding#target}).\n\t* If the owner created the binding, it will also be responsible for destroying \n\t* it (automatically).\n\t*\n\t* @type {module:enyo/CoreObject~Object}\n\t* @default null\n\t* @public\n\t*/\n\towner: null,\n\t\n\t/**\n\t* Set this only to a reference for an [object]{@glossary Object} to use\n\t* as the source for the [binding]{@link module:enyo/Binding~Binding}. If this is not a\n\t* [bindable]{@link module:enyo/BindingSupport~BindingSupport} object, the source will be derived\n\t* from the [from]{@link module:enyo/Binding~Binding#from} property during initialization.\n\t* \n\t* @type {Object}\n\t* @default null\n\t* @public\n\t*/\n\tsource: null,\n\t\n\t/**\n\t* Set this only to a reference for an [object]{@glossary Object} to use\n\t* as the target for the [binding]{@link module:enyo/Binding~Binding}. If this is not a\n\t* [bindable]{@link module:enyo/BindingSupport~BindingSupport} object, the target will will be\n\t* derived from the [to]{@link module:enyo/Binding~Binding#to} property during initialization.\n\t* \n\t* @type {Object}\n\t* @default null\n\t* @public\n\t*/\n\ttarget: null,\n\t\n\t/**\n\t* A path in which the property of the [source]{@link module:enyo/Binding~Binding#source} to\n\t* bind from may be found. If the source is explicitly provided and the path\n\t* is relative (i.e., it begins with a `\".\"`), it is relative to the source;\n\t* otherwise, it is relative to the [owner]{@link module:enyo/Binding~Binding#owner} of the\n\t* [binding]{@link module:enyo/Binding~Binding}. To have a binding be evaluated from the\n\t* global scope, prefix the path with a `\"^\"`. If the source and the `\"^\"`\n\t* are used in tandem, the `\"^\"` will be ignored and the path will be assumed\n\t* to be relative to the provided source.\n\t* \n\t* @type {String}\n\t* @default null\n\t* @public\n\t*/\n\tfrom: null,\n\t\n\t/**\n\t* A path in which the property of the [target]{@link module:enyo/Binding~Binding#target} to\n\t* bind from may be found. If the target is explicitly provided and the path\n\t* is relative (i.e., it begins with a `\".\"`), it is relative to the target;\n\t* otherwise, it is relative to the owner of the [binding]{@link module:enyo/Binding~Binding}.\n\t* To have a binding be evaluated from the global scope, prefix the path with\n\t* a `\"^\"`. If the target and the `\"^\"` are used in tandem, the `\"^\"` will be\n\t* ignored and the path will be assumed to be relative to the provided target.\n\t* \n\t* @type {String}\n\t* @default null\n\t* @public\n\t*/\n\tto: null,\n\n\t/**\n\t* Set this to a [function]{@glossary Function} or the name of a method on\n\t* the [owner]{@link module:enyo/Binding~Binding#owner} of this [binding]{@link module:enyo/Binding~Binding}.\n\t* The transform is used to programmatically modify the value being synchronized.\n\t* See {@link module:enyo/Binding~Binding~Transform} for detailed information on the parameters\n\t* that are available to `transform`.\n\t* \n\t* @type {module:enyo/Binding~Binding~Transform}\n\t* @default null\n\t* @public\n\t*/\n\ttransform: null,\n\t\n\t/**\n\t* Indicates whether the [binding]{@link module:enyo/Binding~Binding} is actually ready.\n\t* \n\t* @returns {Boolean} `true` if ready; otherwise, `false`.\n\t* @public\n\t*/\n\tisReady: function () {\n\t\treturn this.ready || ready(this);\n\t},\n\t\n\t/**\n\t* Causes a single propagation attempt to fail. Typically not called outside\n\t* the scope of a [transform]{@link module:enyo/Binding~Binding#transform}.\n\t* \n\t* @public\n\t*/\n\tstop: function () {\n\t\tthis._stop = true;\n\t},\n\t\n\t/**\n\t* Resets all properties to their original state.\n\t* \n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\treset: function () {\n\t\tthis.ready = null;\n\t\tthis._source = this._target = this._to = this._from = this._toTarget = null;\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* Rebuilds the entire [binding]{@link module:enyo/Binding~Binding} and synchronizes\n\t* the value from the [source]{@link module:enyo/Binding~Binding#source} to the\n\t* [target]{@link module:enyo/Binding~Binding#target}.\n\t* \n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\trebuild: function () {\n\t\treturn this.reset().sync();\n\t},\n\t\n\t/**\n\t* Synchronizes values from the [source]{@link module:enyo/Binding~Binding#source} to the\n\t* [target]{@link module:enyo/Binding~Binding#target}. This usually will not need to be called manually.\n\t* [Two-way bindings]{@link module:enyo/Binding~Binding#oneWay} will automatically synchronize from the\n\t* target end once they are connected.\n\t* \n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tsync: function () {\n\t\tvar source, target, from, to, xform, val;\n\n\t\tif (this.isReady()) {\n\t\t\tsource = this._source;\n\t\t\ttarget = this._target;\n\t\t\tfrom = this._from;\n\t\t\tto = this._to;\n\t\t\txform = this.getTransform();\n\t\t\tval = utils.getPath.apply(source, [from]);\n\n\t\t\tif (xform) val = xform.call(this.owner || this, val, DIRTY_FROM, this);\n\t\t\tif (!this._stop) utils.setPath.apply(target, [to, val, {create: false}]);\n\t\t}\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* Releases all of the [binding's]{@link module:enyo/Binding~Binding} parts. Typically, this method will\n\t* not need to be called directly unless the binding was created without an\n\t* [owner]{@link module:enyo/Binding~Binding#owner}.\n\t* \n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tdestroy: function () {\n\t\tvar owner = this.owner,\n\t\t\tidx;\n\t\t\n\t\tthis.owner = null;\n\t\tthis.source = this._source = null;\n\t\tthis.target = this._target = null;\n\t\tthis.ready = null;\n\t\tthis.destroyed = true;\n\t\t\n\t\t// @todo: remove me or postpone operation?\n\t\tidx = bindings.indexOf(this);\n\t\tif (idx > -1) bindings.splice(idx, 1);\n\t\t\n\t\tif (owner && !owner.destroyed) owner.removeBinding(this);\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tgetTransform: function () {\n\t\treturn this._didInitTransform ? this.transform : (function (bnd) {\n\t\t\tbnd._didInitTransform = true;\n\t\t\t\n\t\t\tvar xform = bnd.transform,\n\t\t\t\towner = bnd.owner,\n\t\t\t\txformOwner = owner && owner.bindingTransformOwner;\n\t\t\t\n\t\t\tif (xform) {\n\t\t\t\tif (typeof xform == 'string') {\n\t\t\t\t\tif (xformOwner && xformOwner[xform]) {\n\t\t\t\t\t\txform = xformOwner[xform];\n\t\t\t\t\t} else if (owner && owner[xform]) {\n\t\t\t\t\t\txform = owner[xform];\n\t\t\t\t\t} else {\n\t\t\t\t\t\txform = utils.getPath.call(global, xform);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*jshint -W093 */\n\t\t\t\treturn (bnd.transform = (typeof xform == 'function' ? xform : null));\n\t\t\t\t/*jshint +W093 */\n\t\t\t}\n\t\t})(this);\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tconstructor: function (props) {\n\t\tbindings.push(this);\n\t\t\n\t\tif (props) utils.mixin(this, props);\n\t\t\n\t\tif (!this.euid) this.euid = utils.uid('b');\n\n\t\tthis.sync();\n\t}\n});\n\n/**\n* The details for an {@link module:enyo/Binding~Binding#transform} [function]{@glossary Function},\n* including the available parameters and how they can be used.\n* \n* @callback module:enyo/Binding~Binding~Transform\n* @param {*} value - The value being synchronized.\n* @param {Number} direction - The direction of synchronization; will be either\n* \t1 (source value has changed and will be written to target) or 2 (target\n* \tvalue has changed and will be written to source).\n* @param {Object} binding - A reference to the associated [binding]{@link module:enyo/Binding~Binding}. In cases \n* \twhere the binding should be interrupted and not propagate the synchronization at all, call\n* \tthe [stop()]{@link module:enyo/Binding~Binding#stop} method on the passed-in binding reference.\n*/\n\n/**\n* {@link module:enyo/Binding~Binding} is a mechanism used to keep properties synchronized. A \n* binding may be used to link two properties on different\n* [objects]{@glossary Object}, or even two properties on the same object.\n* Once a binding has been established, it will wait for change notifications;\n* when a notification arrives, the binding will synchronize the value between\n* the two ends. Note that bindings may be either\n* [one-way]{@link module:enyo/Binding~Binding#oneWay} (the default) or\n* [two-way]{@link module:enyo/Binding~Binding#oneWay}.\n* \n* Usually, you will not need to create Binding objects arbitrarily, but will\n* instead rely on the public [BindingSupport API]{@link module:enyo/BindingSupport~BindingSupport},\n* which is applied to [Object]{@link module:enyo/CoreObject~Object} and so is available on\n* all of its [subkinds]{@glossary subkind}.\n* \n* @class Binding\n* @public\n*/\nexports = module.exports = kind(\n\t/** @lends module:enyo/Binding~Binding.prototype */ {\n\t\n\tname: 'enyo.Binding',\n\t\n\t/**\n\t* @private\n\t*/\n\tkind: PassiveBinding,\n\t\n\t/**\n\t* If a [binding]{@link module:enyo/Binding~Binding} is one-way, this flag should be `true` (the default). \n\t* If this flag is set to `false`, the binding will be two-way.\n\t*\n\t* @type {Boolean}\n\t* @default true\n\t* @public\n\t*/\n\toneWay: true,\n\t\n\t/**\n\t* If the [binding]{@link module:enyo/Binding~Binding} was able to resolve both ends (i.e., its \n\t* [source]{@link module:enyo/Binding~Binding#source} and [target]{@link module:enyo/Binding~Binding#target} \n\t* [objects]{@glossary Object}), this value will be `true`. Setting this manually will\n\t* have undesirable effects.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\tconnected: false,\n\t\n\t/**\n\t* By default, a [binding]{@link module:enyo/Binding~Binding} will attempt to connect to both ends \n\t* ([source]{@link module:enyo/Binding~Binding#source} and [target]{@link module:enyo/Binding~Binding#target}). If this \n\t* process should be deferred, set this flag to `false`.\n\t*\n\t* @type {Boolean}\n\t* @default true\n\t* @public\n\t*/\n\tautoConnect: true,\n\t\n\t/**\n\t* By default, a [binding]{@link module:enyo/Binding~Binding} will attempt to synchronize its values from \n\t* its [source]{@link module:enyo/Binding~Binding#source} to its [target]{@link module:enyo/Binding~Binding#target}. If \n\t* this process should be deferred, set this flag to `false`.\n\t* \n\t* @type {Boolean}\n\t* @default true\n\t* @public\n\t*/\n\tautoSync: true,\n\t\n\t/**\n\t* The `dirty` property represents the changed value state of both the property designated by\n\t* the [from]{@link module:enyo/Binding~Binding#from} path and the property designated by the \n\t* [to]{@link module:enyo/Binding~Binding#to} path.\n\t*\n\t* @type {Number}\n\t* @default module:enyo/Binding#DIRTY_FROM\n\t* @public\n\t*/\n\tdirty: DIRTY_FROM,\n\t\n\t/**\n\t* Indicates whether the [binding]{@link module:enyo/Binding~Binding} is currently connected.\n\t*\n\t* @returns {Boolean} `true` if connected; otherwise, `false`.\n\t* @public\n\t*/\n\tisConnected: function () {\n\t\tvar from = this._from,\n\t\t\tto = this.oneWay ? (this._toTarget || this._to) : this._to,\n\t\t\tsource = this._source,\n\t\t\ttarget = this._target,\n\t\t\ttoChain,\n\t\t\tfromChain;\n\t\t\t\n\t\tif (from && to && source && target) {\n\t\t\tif (!this.oneWay || this._toTarget) toChain = target.getChains()[to];\n\t\t\tfromChain = source.getChains()[from];\n\t\t\t\n\t\t\treturn this.connected\n\t\t\t\t&& (fromChain ? fromChain.isConnected() : true)\n\t\t\t\t&& (toChain ? toChain.isConnected() : true);\n\t\t}\n\t\t\n\t\treturn false;\n\t},\n\t\n\t/**\n\t* Resets all properties to their original state.\n\t* \n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\treset: function () {\n\t\tthis.disconnect();\n\t\treturn PassiveBinding.prototype.reset.apply(this, arguments);\n\t},\n\t\n\t/**\n\t* Rebuilds the entire [binding]{@link module:enyo/Binding~Binding}. Will synchronize if it is able to \n\t* connect and the [autoSync]{@link module:enyo/Binding~Binding#autoSync} flag is `true`.\n\t* \n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\trebuild: function () {\n\t\treturn this.reset().connect();\n\t},\n\t\n\t/**\n\t* Connects the ends (i.e., the [source]{@link module:enyo/Binding~Binding#source} and\n\t* [target]{@link module:enyo/Binding~Binding#target}) of the [binding]{@link module:enyo/Binding~Binding}. While you\n\t* typically won't need to call this method, it is safe to call even when the ends are\n\t* already established. Note that if one or both of the ends does become connected and the\n\t* [autoSync]{@link module:enyo/Binding~Binding#autoSync} flag is `true`, the ends will automatically be\n\t* synchronized.\n\t* \n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tconnect: function () {\n\t\tif (!this.isConnected()) {\n\t\t\tif (this.isReady()) {\n\t\t\t\tthis._source.observe(this._from, this._sourceChanged, this, {priority: true});\n\t\t\t\t\n\t\t\t\t// for two-way bindings we register to observe changes\n\t\t\t\t// from the target\n\t\t\t\tif (!this.oneWay) this._target.observe(this._to, this._targetChanged, this);\n\t\t\t\telse if (this._toTarget) {\n\t\t\t\t\tthis._target.observe(this._toTarget, this._toTargetChanged, this, {priority: true});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// we flag it as having been connected\n\t\t\t\tthis.connected = true;\n\t\t\t\tif (this.isConnected() && this.autoSync) this.sync(true);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* Disconnects from the ends (i.e., the [source]{@link module:enyo/Binding~Binding#source} and \n\t* [target]{@link module:enyo/Binding~Binding#target}) if a connection exists at either end. This method \n\t* will most likely not need to be called directly.\n\t* \n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tdisconnect: function () {\n\t\tif (this.isConnected()) {\n\t\t\tthis._source.unobserve(this._from, this._sourceChanged, this);\n\t\t\t\n\t\t\t// for two-way bindings we unregister the observer from\n\t\t\t// the target as well\n\t\t\tif (!this.oneWay) this._target.unobserve(this._to, this._targetChanged, this);\n\t\t\telse if (this._toTarget) {\n\t\t\t\tthis._target.unobserve(this._toTarget, this._toTargetChanged, this);\n\t\t\t}\n\t\t\t\n\t\t\tthis.connected = false;\n\t\t}\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* Synchronizes values from the [source]{@link module:enyo/Binding~Binding#source} to the\n\t* [target]{@link module:enyo/Binding~Binding#target}. This usually will not need to be called manually.\n\t* [Two-way bindings]{@link module:enyo/Binding~Binding#oneWay} will automatically synchronize from the\n\t* target end once they are connected.\n\t* \n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tsync: function (force) {\n\t\tvar source = this._source,\n\t\t\ttarget = this._target,\n\t\t\tfrom = this._from,\n\t\t\tto = this._to,\n\t\t\txform = this.getTransform(),\n\t\t\tval;\n\t\t\n\t\tif (this.isReady() && this.isConnected()) {\n\t\t\t\t\n\t\t\tswitch (this.dirty || (force && DIRTY_FROM)) {\n\t\t\tcase DIRTY_TO:\n\t\t\t\tval = target.get(to);\n\t\t\t\tif (xform) val = xform.call(this.owner || this, val, DIRTY_TO, this);\n\t\t\t\tif (!this._stop) source.set(from, val, {create: false});\n\t\t\t\tbreak;\n\t\t\tcase DIRTY_FROM:\n\t\t\t\t\n\t\t\t// @TODO: This should never need to happen but is here just in case\n\t\t\t// it is ever arbitrarily called not having been dirty?\n\t\t\t// default:\n\t\t\t\tval = source.get(from);\n\t\t\t\tif (xform) val = xform.call(this.owner || this, val, DIRTY_FROM, this);\n\t\t\t\tif (!this._stop) target.set(to, val, {create: false});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.dirty = null;\n\t\t\tthis._stop = null;\n\t\t}\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* Releases all of the [binding's]{@link module:enyo/Binding~Binding} parts and unregisters its \n\t* [observers]{@link module:enyo/ObserverSupport~ObserverSupport}. Typically, this method will not need to be called \n\t* directly unless the binding was created without an [owner]{@link module:enyo/Binding~Binding#owner}.\n\t* \n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tdestroy: function () {\n\t\tthis.disconnect();\n\n\t\treturn PassiveBinding.prototype.destroy.apply(this, arguments);\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tconstructor: function (props) {\n\t\tbindings.push(this);\n\t\t\n\t\tif (props) utils.mixin(this, props);\n\t\t\n\t\tif (!this.euid) this.euid = utils.uid('b');\n\t\tif (this.autoConnect) this.connect();\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\t_sourceChanged: function (was, is, path) {\n\t\t// @TODO: Should it...would it benefit from using these passed in values?\n\t\tthis.dirty = this.dirty == DIRTY_TO ? null : DIRTY_FROM;\n\t\treturn this.dirty == DIRTY_FROM && this.sync();\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\t_targetChanged: function (was, is, path) {\n\t\t// @TODO: Same question as above, it seems useful but would it affect computed\n\t\t// properties or stale values?\n\t\tthis.dirty = this.dirty == DIRTY_FROM ? null : DIRTY_TO;\n\t\treturn this.dirty == DIRTY_TO && this.sync();\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\t_toTargetChanged: function (was, is, path) {\n\t\tthis.dirty = DIRTY_FROM;\n\t\tthis.reset().connect();\n\t}\n});\n\n/**\n* Retrieves a [binding]{@link module:enyo/Binding~Binding} by its global id.\n*\n* @param {String} euid - The [Enyo global id]{@glossary EUID} by which to retrieve a \n*\t[binding]{@link module:enyo/Binding~Binding}.\n* @returns {module:enyo/Binding~Binding|undefined} A reference to the binding if the id\n*\tis found; otherwise, it will return [undefined]{@glossary undefined}.\n* \n* @static\n* @public\n*/\nexports.find = function (euid) {\n\treturn bindings.find(function (ln) {\n\t\treturn ln.euid == euid;\n\t});\n};\n\n/**\n* All {@link module:enyo/Binding~Binding} instances are stored in this list and may be retrieved via the\n* {@link module:enyo/Binding.find} method using an {@link module:enyo/Binding~Binding#id} identifier.\n*\n* @type {module:enyo/Binding~Binding[]}\n* @default []\n* @public\n*/\nexports.bindings = bindings;\n\n/**\n* Possible value of the [dirty]{@link module:enyo/Binding~Binding#dirty} property, indicating that the value \n* of the [binding source]{@link module:enyo/Binding~Binding#source} has changed.\n* \n* @static\n* @public\n*/\nexports.DIRTY_FROM = DIRTY_FROM;\n\n/**\n* Possible value of the [dirty]{@link module:enyo/Binding~Binding#dirty} property, indicating that the value\n* of the [binding target]{@link module:enyo/Binding~Binding#target} has changed.\n* \n* @static\n* @public\n*/\nexports.DIRTY_TO = DIRTY_TO;\n\n/**\n* The default [kind]{@glossary kind} that provides [binding]{@link module:enyo/Binding~Binding} \n* functionality.\n* \n* @static\n* @public\n*/\nexports.defaultBindingKind = exports;\n\n/**\n* The kind declaration for the [PassiveBinding]{@link module:enyo/Binding~PassiveBinding} kind\n* @public\n*/\nexports.PassiveBinding = PassiveBinding;\n",
    "mtime": 1542469884035,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/Binding.js",
    "relPath": "enyo/Binding",
    "requires": [
      "enyo",
      "./kind",
      "./utils"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./ComputedSupport",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/ComputedSupport",
    "name": "enyo/ComputedSupport",
    "isFile": true,
    "contents": "/**\n* Exports the {@link module:enyo/ComputedSupport~ComputedSupport} mixin.\n* @module enyo/ComputedSupport\n*/\n\nrequire('enyo');\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils');\n\nvar extend = kind.statics.extend;\n\t\nkind.concatenated.push('computed');\n\nfunction getComputedValue (obj, path) {\n\tvar cache = obj._getComputedCache(path)\n\t\t, isCached = obj._isComputedCached(path);\n\t\n\t// in the end, for efficiency and completeness in other situations\n\t// it is better to know the returned value of all computed properties\n\t// but in cases where they are set as cached we will sometimes use\n\t// that value\n\tif (cache.dirty || cache.dirty === undefined) {\n\t\tisCached && (cache.dirty = false);\n\t\tcache.previous = cache.value;\n\t\tcache.value = obj[path]();\n\t}\n\t\n\treturn cache.value;\n}\n\nfunction queueComputed (obj, path) {\n\tvar queue = obj._computedQueue || (obj._computedQueue = [])\n\t\t, deps = obj._computedDependencies[path];\n\t\t\n\tif (deps) {\n\t\tfor (var i=0, dep; (dep=deps[i]); ++i) {\n\t\t\tif (!queue.length || -1 == queue.indexOf(dep)) queue.push(dep);\n\t\t}\n\t}\n}\n\nfunction flushComputed (obj) {\n\tvar queue = obj._computedQueue;\n\tobj._computedQueue = null;\n\tif (queue && obj.isObserving()) {\n\t\tfor (var i=0, ln; (ln=queue[i]); ++i) {\n\t\t\tobj.notify(ln, obj._getComputedCache(ln).value, getComputedValue(obj, ln));\n\t\t}\n\t}\n}\n\n/**\n* A {@glossary mixin} that adds API methods to support\n* [computed properties]{@glossary computed_property}. Unlike other support mixins,\n* this mixin does not need to be explicitly included by a [kind]{@glossary kind}. If the\n* `computed` [array]{@glossary Array} is found in a kind definition, this mixin will\n* automatically be included.\n*\n* @mixin\n* @public\n*/\nvar ComputedSupport = {\n\t/**\n\t* @private\n\t*/\n\tname: 'ComputedSuport',\n\t\n\t/**\n\t* @private\n\t*/\n\t_computedRecursion: 0,\n\t\n\t/**\n\t* Primarily intended for internal use, this method determines whether the\n\t* given path is a known [computed property]{@glossary computed_property}.\n\t*\n\t* @param {String} path - The property or path to test.\n\t* @returns {Boolean} Whether or not the `path` is a\n\t*\t[computed property]{@glossary computed_property}.\n\t* @public\n\t*/\n\tisComputed: function (path) {\n\t\t// if it exists it will be explicitly one of these cases and it is cheaper than hasOwnProperty\n\t\treturn this._computed && (this._computed[path] === true || this._computed[path] === false);\n\t},\n\t\n\t/**\n\t* Primarily intended for internal use, this method determines whether the\n\t* given path is a known dependency of a\n\t* [computed property]{@glossary computed_property}.\n\t*\n\t* @param {String} path - The property or path to test.\n\t* @returns {Boolean} Whether or not the `path` is a dependency of a\n\t*\t[computed property]{@glossary computed_property}.\n\t* @public\n\t*/\n\tisComputedDependency: function (path) {\n\t\treturn !! (this._computedDependencies? this._computedDependencies[path]: false);\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tget: kind.inherit(function (sup) {\n\t\treturn function (path) {\n\t\t\treturn this.isComputed(path)? getComputedValue(this, path): sup.apply(this, arguments);\n\t\t};\n\t}),\n\t\n\t/**\n\t* @private\n\t*/\n\tset: kind.inherit(function (sup) {\n\t\treturn function (path) {\n\t\t\t// we do not accept parameters for computed properties\n\t\t\treturn this.isComputed(path)? this: sup.apply(this, arguments);\n\t\t};\n\t}),\n\t\n\t/**\n\t* @private\n\t*/\n\tnotifyObservers: function () {\n\t\treturn this.notify.apply(this, arguments);\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tnotify: kind.inherit(function (sup) {\n\t\treturn function (path, was, is) {\n\t\t\tthis.isComputedDependency(path) && queueComputed(this, path);\n\t\t\tthis._computedRecursion++;\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis._computedRecursion--;\n\t\t\tthis._computedQueue && this._computedRecursion === 0 && flushComputed(this);\n\t\t\treturn this;\n\t\t};\n\t}),\n\t\n\t/**\n\t* @private\n\t*/\n\t_isComputedCached: function (path) {\n\t\treturn this._computed[path];\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\t_getComputedCache: function (path) {\n\t\tvar cache = this._computedCache || (this._computedCache = {});\n\t\treturn cache[path] || (cache[path] = {});\n\t}\n};\n\nmodule.exports = ComputedSupport;\n\n/*\n* Hijack the original so we can add additional default behavior.\n*/\nvar sup = kind.concatHandler;\n\n// @NOTE: It seems like a lot of work but it really won't happen that much and the more\n// we push to kind-time the better for initialization time\n\n/**\n* @private\n*/\nkind.concatHandler = function (ctor, props, instance) {\n\n\tsup.call(this, ctor, props, instance);\n\n\t// only matters if there are computed properties to manage\n\tif (props.computed) {\n\t\t\n\t\tvar proto = ctor.prototype || ctor\n\t\t\t, computed = proto._computed? Object.create(proto._computed): {}\n\t\t\t, dependencies = proto._computedDependencies? Object.create(proto._computedDependencies): {};\n\t\t\n\t\t// if it hasn't already been applied we need to ensure that the prototype will\n\t\t// actually have the computed support mixin present, it will not apply it more\n\t\t// than once to the prototype\n\t\textend(ComputedSupport, proto);\n\t\n\t\t// @NOTE: This is the handling of the original syntax provided for computed properties in 2.3.ish...\n\t\t// All we do here is convert it to a structure that can be used for the other scenario and preferred\n\t\t// computed declarations format\n\t\tif (!props.computed || !(props.computed instanceof Array)) {\n\t\t\t(function () {\n\t\t\t\tvar tmp = [], deps, name, conf;\n\t\t\t\t// here is the slow iteration over the properties...\n\t\t\t\tfor (name in props.computed) {\n\t\t\t\t\t// points to the dependencies of the computed method\n\t\t\t\t\tdeps = props.computed[name];\n\t\t\t\t\t/*jshint -W083 */\n\t\t\t\t\tconf = deps && deps.find(function (ln) {\n\t\t\t\t\t\t// we deliberately remove the entry here and forcibly return true to break\n\t\t\t\t\t\treturn typeof ln == 'object'? (utils.remove(deps, ln) || true): false;\n\t\t\t\t\t});\n\t\t\t\t\t/*jshint +W083 */\n\t\t\t\t\t// create a single entry now for the method/computed with all dependencies\n\t\t\t\t\ttmp.push({method: name, path: deps, cached: conf? conf.cached: null});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// note that we only do this one so even for a mixin that is evaluated several\n\t\t\t\t// times this would only happen once\n\t\t\t\tprops.computed = tmp;\n\t\t\t}());\n\t\t}\n\t\t\n\t\tvar addDependency = function (path, dep) {\n\t\t\t// its really an inverse look at the original\n\t\t\tvar deps;\n\t\t\t\n\t\t\tif (dependencies[path] && !dependencies.hasOwnProperty(path)) dependencies[path] = dependencies[path].slice();\n\t\t\tdeps = dependencies[path] || (dependencies[path] = []);\n\t\t\tdeps.push(dep);\n\t\t};\n\t\t\n\t\t// now we handle the new computed properties the way we intended to\n\t\tfor (var i=0, ln; (ln=props.computed[i]); ++i) {\n\t\t\t// if the entry already exists we are merely updating whether or not it is\n\t\t\t// now cached\n\t\t\tcomputed[ln.method] = !! ln.cached;\n\t\t\t// we must now look to add an entry for any given dependencies and map them\n\t\t\t// back to the computed property they will trigger\n\t\t\t/*jshint -W083 */\n\t\t\tif (ln.path && ln.path instanceof Array) ln.path.forEach(function (dep) { addDependency(dep, ln.method); });\n\t\t\t/*jshint +W083 */\n\t\t\telse if (ln.path) addDependency(ln.path, ln.method);\n\t\t}\n\t\t\n\t\t// arg, free the key from the properties so it won't be applied later...\n\t\t// delete props.computed;\n\t\t// make sure to reassign the correct items to the prototype\n\t\tproto._computed = computed;\n\t\tproto._computedDependencies = dependencies;\n\t}\n};\n",
    "mtime": 1542469884079,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ComputedSupport.js",
    "relPath": "enyo/ComputedSupport",
    "requires": [
      "enyo",
      "./kind",
      "./utils"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./ApplicationSupport",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/ApplicationSupport",
    "name": "enyo/ApplicationSupport",
    "isFile": true,
    "contents": "/**\n* Exports the {@link module:enyo/ApplicationSupport~ApplicationSupport} mixin.\n* @module enyo/ApplicationSupport\n*/\n\nrequire('enyo');\n\nvar kind = require('./kind');\n\n/**\n* An internally-used support {@glossary mixin} that is applied to all\n* [components]{@link module:enyo/Component~Component} of an {@link module:enyo/Application~Application} instance\n* (and to their components, recursively). This mixin adds an `app` property to\n* each component -- a local reference to the `Application` instance that\n* the component belongs to.\n* \n* @mixin\n* @protected\n*/\nvar ApplicationSupport = {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'ApplicationSupport',\n\n\t/**\n\t* @private\n\t*/\n\tadjustComponentProps: kind.inherit(function (sup) {\n\t\treturn function (props) {\n\t\t\tprops.app = props.app || this.app;\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\t// release the reference to the application\n\t\t\tthis.app = null;\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t})\n\n};\n\nmodule.exports = ApplicationSupport;\n",
    "mtime": 1542469884015,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ApplicationSupport.js",
    "relPath": "enyo/ApplicationSupport",
    "requires": [
      "enyo",
      "./kind"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./ComponentBindingSupport",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/ComponentBindingSupport",
    "name": "enyo/ComponentBindingSupport",
    "isFile": true,
    "contents": "/**\n* Exports the {@link module:enyo/ComponentBindingSupport~ComponentBindingSupport} mixin.\n* @module enyo/ComponentBindingSupport\n*/\n\nrequire('enyo');\n\nvar\n\tkind = require('./kind');\n\n/**\n* An internally-used {@glossary mixin} applied to {@link module:enyo/Component~Component}\n* instances to better support [bindings]{@link module:enyo/Binding~Binding}.\n*\n* @mixin\n* @protected\n*/\nvar ComponentBindingSupport = {\n\t\n\t/**\n\t* @private\n\t*/\n\tname: 'ComponentBindingSupport',\n\t\n\t/**\n\t* @private\n\t*/\n\tadjustComponentProps: kind.inherit(function (sup) {\n\t\treturn function (props) {\n\t\t\tsup.apply(this, arguments);\n\t\t\tprops.bindingTransformOwner || (props.bindingTransformOwner = this.getInstanceOwner());\n\t\t};\n\t})\n};\n\nmodule.exports = ComponentBindingSupport;\n",
    "mtime": 1542469884079,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ComponentBindingSupport.js",
    "relPath": "enyo/ComponentBindingSupport",
    "requires": [
      "enyo",
      "./kind"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./floatingLayer",
    "base": "/home/udo/git/NCPV/lib/enyo/src/Control",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/Control/floatingLayer",
    "name": "enyo/Control/floatingLayer",
    "isFile": true,
    "contents": "/**\n* Exports the {@link module:enyo/Control/floatingLayer~FloatingLayer} singleton instance.\n* @module enyo/Control/floatingLayer\n*/\n\nvar\n\tkind = require('../kind'),\n\tplatform = require('../platform');\n\nmodule.exports = function (Control) {\n\t/**\n\t* {@link module:enyo/Control/floatingLayer~FloatingLayer} is a\n\t* [control]{@link module:enyo/Control~Control} that provides a layer for controls that should be\n\t* displayed above an [application]{@link module:enyo/Application~Application}. The `floatingLayer`\n\t* singleton can be set as a control's parent to have the control float above the application, e.g.:\n\t*\n\t* ```\n\t* var floatingLayer = require('enyo/floatingLayer');\n\t* ...\n\t* create: kind.inherit(function (sup) {\n\t*\treturn function() {\n\t*\t\tsup.apply(this, arguments);\n\t*\t\tthis.setParent(floatingLayer);\n\t*\t}\n\t* });\n\t* ```\n\t*\n\t* Note: `FloatingLayer` is not meant to be instantiated by users.\n\t*\n\t* @class FloatingLayer\n\t* @extends module:enyo/Control~Control\n\t* @ui\n\t* @protected\n\t*/\n\tvar FloatingLayer = kind(\n\t\t/** @lends module:enyo/Control/floatingLayer~FloatingLayer.prototype */ {\n\n\t\t/**\n\t\t* @private\n\t\t*/\n\t\tkind: Control,\n\n\t\t/**\n\t\t* @private\n\t\t*/\n\t\tclasses: 'enyo-fit enyo-clip enyo-untouchable',\n\n\t\t/**\n\t\t* @private\n\t\t*/\n\t\taccessibilityPreventScroll: true,\n\n\t\t/**\n\t\t* @method\n\t\t* @private\n\t\t*/\n\t\tcreate: kind.inherit(function (sup) {\n\t\t\treturn function() {\n\t\t\t\tsup.apply(this, arguments);\n\t\t\t\tthis.setParent(null);\n\n\t\t\t\tif (platform.ie < 11) {\n\t\t\t\t\tthis.removeClass('enyo-fit');\n\t\t\t\t}\n\t\t\t};\n\t\t}),\n\n\t\t/**\n\t\t* Detects when [node]{@glossary Node} is detatched due to `document.body` being stomped.\n\t\t*\n\t\t* @method\n\t\t* @private\n\t\t*/\n\t\thasNode: kind.inherit(function (sup) {\n\t\t\treturn function() {\n\t\t\t\tsup.apply(this, arguments);\n\t\t\t\tif (this.node && !this.node.parentNode) {\n\t\t\t\t\tthis.teardownRender();\n\t\t\t\t}\n\t\t\t\treturn this.node;\n\t\t\t};\n\t\t}),\n\n\t\t/**\n\t\t* @method\n\t\t* @private\n\t\t*/\n\t\trender: kind.inherit(function (sup) {\n\t\t\treturn function() {\n\t\t\t\tthis.parentNode = document.body;\n\t\t\t\treturn sup.apply(this, arguments);\n\t\t\t};\n\t\t}),\n\n\t\t/**\n\t\t* @private\n\t\t*/\n\t\tgenerateInnerHtml: function () {\n\t\t\treturn '';\n\t\t},\n\n\t\t/**\n\t\t* @private\n\t\t*/\n\t\tbeforeChildRender: function () {\n\t\t\tif (!this.hasNode()) {\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t* @private\n\t\t*/\n\t\tteardownChildren: function () {\n\t\t}\n\t});\n\n\treturn FloatingLayer;\n};",
    "mtime": 1542469884099,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/Control/floatingLayer.js",
    "relPath": "enyo/Control/floatingLayer",
    "requires": [
      "../kind",
      "../platform"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./MultipleDispatchSupport",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/MultipleDispatchSupport",
    "name": "enyo/MultipleDispatchSupport",
    "isFile": true,
    "contents": "/**\n* Exports the {@link module:enyo/MultipleDispatchSupport~MultipleDispatchSupport} mixin.\n* @module enyo/MultipleDispatchSupport\n*/\n\nrequire('enyo');\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils');\n\n/**\n* A collection of methods to allow a single {@link module:enyo/Component~Component} to\n* [dispatch]{@link module:enyo/Component~Component#dispatchEvent} a single {@glossary event} to\n* multiple targets. The events are synchronously propagated in the order in\n* which the targets are encountered. Note that this {@glossary mixin} is\n* already applied to a base [kind]{@glossary kind},\n* {@link module:enyo/MultipleDispatchComponent~MultipleDispatchComponent}.\n*\n* @mixin\n* @public\n*/\nvar MultipleDispatchSupport = {\n\t\n\t/**\n\t* @private\n\t*/\n\tname: 'MultipleDispatchSupport',\n\t\n\t/**\n\t* Adds a target for dispatching.\n\t*\n\t* @param {module:enyo/Component~Component} component - The {@link module:enyo/Component~Component} to add as a dispatch target.\n\t* @public\n\t*/\n\taddDispatchTarget: function (component) {\n\t\tvar dt = this._dispatchTargets;\n\t\tif (component && !~utils.indexOf(component, dt)) {\n\t\t\tdt.push(component);\n\t\t}\n\t},\n\t/**\n\t* Removes a target from dispatching.\n\t*\n\t* @param {module:enyo/Component~Component} component - The {@link module:enyo/Component~Component} to remove as a dispatch\n\t*\ttarget.\n\t* @public\n\t*/\n\tremoveDispatchTarget: function (component) {\n\t\tvar dt = this._dispatchTargets, i;\n\t\ti = utils.indexOf(component, dt);\n\t\tif (i > -1) {\n\t\t\tdt.splice(i, 1);\n\t\t}\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tbubbleUp: kind.inherit(function (sup) {\n\t\treturn function (name, event, sender) {\n\t\t\tif (this._dispatchDefaultPath) {\n\t\t\t\tsup.apply(this, arguments);\n\t\t\t}\n\t\t\tvar dt = this._dispatchTargets;\n\t\t\tfor (var i=0, t; (t=dt[i]); ++i) {\n\t\t\t\tif (t && !t.destroyed) {\n\t\t\t\t\tt.dispatchBubble(name, event, sender);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}),\n\t\n\t/**\n\t* @private\n\t*/\n\townerChanged: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tvar o = this.owner;\n\t\t\tthis._dispatchDefaultPath = !! o;\n\t\t};\n\t}),\n\t\n\t/**\n\t* @private\n\t*/\n\tconstructor: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis._dispatchTargets = [];\n\t\t\treturn sup.apply(this, arguments);\n\t\t};\n\t}),\n\t\n\t/**\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis._dispatchTargets = null;\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\t\n\t/**\n\t* @private\n\t*/\n\t_dispatchDefaultPath: false\n};\n\nmodule.exports = MultipleDispatchSupport;\n",
    "mtime": 1542469884291,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/MultipleDispatchSupport.js",
    "relPath": "enyo/MultipleDispatchSupport",
    "requires": [
      "enyo",
      "./kind",
      "./utils"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "enyo/Layout",
    "base": "/home/udo/git/NCPV/lib/layout/src/FittableLayout",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/Layout",
    "name": "enyo/Layout",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/Layout~Layout} kind.\n* @module enyo/Layout\n*/\n\nvar\n\tkind = require('./kind');\n\n/**\n* {@link module:enyo/Layout~Layout} is the base [kind]{@glossary kind} for layout\n* kinds. Layout kinds are used by {@link module:enyo/UiComponent~UiComponent}-based\n* [controls]{@link module:enyo/Control~Control} to allow for arranging of child controls by\n* setting the [layoutKind]{@link module:enyo/UiComponent~UiComponent#layoutKind} property.\n* \n* Derived kinds will usually provide their own\n* [layoutClass]{@link module:enyo/Layout~Layout#layoutClass} property to affect the CSS\n* rules used, and may also implement the [flow()]{@link module:enyo/Layout~Layout#flow}\n* and [reflow()]{@link module:enyo/Layout~Layout#reflow} methods. `flow()` is called\n* during control rendering, while `reflow()` is called when the associated\n* control is resized.\n*\n* @class Layout\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/Layout~Layout.prototype */ {\n\n\tname: 'enyo.Layout',\n\n\t/**\n\t* @private\n\t*/\n\tkind: null,\n\n\t/** \n\t* CSS class that's added to the [control]{@link module:enyo/Control~Control} using this \n\t* [layout]{@link module:enyo/Layout~Layout} [kind]{@glossary kind}.\n\t*\n\t* @type {String}\n\t* @default ''\n\t* @public\n\t*/\n\tlayoutClass: '',\n\t\n\t/**\n\t* @private\n\t*/\n\tconstructor: function (container) {\n\t\tthis.container = container;\n\t\tif (container) {\n\t\t\tcontainer.addClass(this.layoutClass);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdestroy: function () {\n\t\tif (this.container) {\n\t\t\tthis.container.removeClass(this.layoutClass);\n\t\t}\n\t},\n\t\n\t/**\n\t* Called during static property layout (i.e., during rendering).\n\t*\n\t* @public\n\t*/\n\tflow: function () {\n\t},\n\n\t/** \n\t* Called during dynamic measuring layout (i.e., during a resize).\n\t*\n\t* May short-circuit and return `true` if the layout needs to be\n\t* redone when the associated Control is next shown. This is useful\n\t* for cases where the Control itself has `showing` set to `true`\n\t* but an ancestor is hidden, and the layout is therefore unable to\n\t* get accurate measurements of the Control or its children.\n\t*\n\t* @public\n\t*/\n\treflow: function () {\n\t}\n});\n",
    "mtime": 1542469884227,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/Layout.js",
    "relPath": "enyo/Layout",
    "requires": [
      "enyo",
      "./kind"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./LinkedList",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/LinkedList",
    "name": "enyo/LinkedList",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/LinkedList~LinkedList} kind.\n* @module enyo/LinkedList\n*/\n\nvar\n\tkind = require('./kind');\n\nvar\n\tLinkedListNode = require('./LinkedListNode');\n\n/**\n* An abstract linked-list.\n*\n* @class LinkedList\n* @private\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/LinkedList~LinkedList.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tkind: null,\n\n\t/**\n\t* @private\n\t*/\n\tnodeKind: LinkedListNode,\n\n\t/**\n\t* @private\n\t*/\n\thead: null,\n\n\t/**\n\t* @private\n\t*/\n\ttail: null,\n\n\t/**\n\t* @private\n\t*/\n\tlength: 0,\n\n\t/**\n\t* @private\n\t*/\n\tclear: function () {\n\t\tif (this.head) {\n\t\t\t// this will trigger a chain event down the list\n\t\t\tthis.head.destroy();\n\t\t}\n\t\tthis.head = null;\n\t\tthis.tail = null;\n\t\tthis.length = 0;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tslice: function (fromNode, toNode) {\n\t\tvar node = fromNode || this.head\n\t\t\t, list = new this.ctor()\n\t\t\t, cpy;\n\n\t\t// ensure we have a final node or our tail\n\t\ttoNode = toNode || this.tail;\n\n\t\tif (node && node !== toNode) {\n\t\t\tdo {\n\t\t\t\tcpy = node.copy();\n\t\t\t\tlist.appendNode(cpy);\n\t\t\t} while ((node = node.next) && node !== toNode);\n\t\t}\n\n\t\treturn list;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdestroy: function () {\n\t\tthis.clear();\n\t\tthis.destroyed = true;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcreateNode: function (props) {\n\t\treturn new this.nodeKind(props);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdeleteNode: function (node) {\n\t\tthis.removeNode(node);\n\n\t\t// can't chain destruct because we removed its chain references\n\t\tnode.destroy();\n\t\treturn this;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tremoveNode: function (node) {\n\t\tvar prev = node.prev\n\t\t\t, next = node.next;\n\n\t\tprev && (prev.next = next);\n\t\tnext && (next.prev = prev);\n\t\tthis.length--;\n\t\tnode.next = node.prev = null;\n\t\treturn this;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tappendNode: function (node, targetNode) {\n\t\ttargetNode = targetNode || this.tail;\n\n\t\tif (targetNode) {\n\t\t\tif (targetNode.next) {\n\t\t\t\tnode.next = targetNode.next;\n\t\t\t}\n\n\t\t\ttargetNode.next = node;\n\t\t\tnode.prev = targetNode;\n\n\t\t\tif (targetNode === this.tail) {\n\t\t\t\tthis.tail = node;\n\t\t\t}\n\n\t\t\tthis.length++;\n\t\t} else {\n\n\t\t\tthis.head = this.tail = node;\n\t\t\tnode.prev = node.next = null;\n\t\t\tthis.length = 1;\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tfind: function (fn, ctx, targetNode) {\n\t\tvar node = targetNode || this.head;\n\t\tif (node) {\n\t\t\tdo {\n\t\t\t\tif (fn.call(ctx || this, node, this)) {\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t} while ((node = node.next));\n\t\t}\n\t\t// if no node qualified it returns false\n\t\treturn false;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tforward: function (fn, ctx, targetNode) {\n\t\tvar node = targetNode || this.head;\n\t\tif (node) {\n\t\t\tdo {\n\t\t\t\tif (fn.call(ctx || this, node, this)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while ((node = node.next));\n\t\t}\n\t\t// returns the last node (if any) that was processed in the chain\n\t\treturn node;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tbackward: function (fn, ctx, targetNode) {\n\t\tvar node = targetNode || this.tail;\n\t\tif (node) {\n\t\t\tdo {\n\t\t\t\tif (fn.call(ctx || this, node, this)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while ((node = node.prev));\n\t\t}\n\t\t// returns the last node (if any) that was processed in the chain\n\t\treturn node;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tconstructor: function () {\n\t\tthis.nodeType = kind.constructorForKind(this.nodeType);\n\t}\n});\n",
    "mtime": 1542469884247,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/LinkedList.js",
    "relPath": "enyo/LinkedList",
    "requires": [
      "enyo",
      "./kind",
      "./LinkedListNode"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./ObserverChainNode",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/ObserverChainNode",
    "name": "enyo/ObserverChainNode",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/ObserverChainNode~ObserverChainNode} kind.\n* @module enyo/ObserverChainNode\n*/\n\nvar\n\tkind = require('./kind');\n\nvar\n\tLinkedListNode = require('./LinkedListNode');\n\nfunction get (base, prop) {\n\treturn base && /*isObject(base)*/ (typeof base == 'object')? (\n\t\tbase.get? base.get(prop): base[prop]\n\t): undefined;\n}\n\n/**\n* An internally used {@glossary kind}.\n*\n* @class ObserverChainNode\n* @extends module:enyo/LinkedListNode~LinkedListNode\n* @private\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/ObserverChainNode~ObserverChainNode.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tkind: LinkedListNode,\n\n\t/**\n\t* @private\n\t*/\n\n\t\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tconstructor: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.connect();\n\t\t};\n\t}),\n\t\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.disconnect();\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.observer = null;\n\t\t\tthis.list = null;\n\t\t\tthis.object = null;\n\t\t};\n\t}),\n\t\n\t/**\n\t* @private\n\t*/\n\tconnect: function () {\n\t\tvar obj = this.object\n\t\t\t, obs = this._changed\n\t\t\t, prop = this.property;\n\t\tif (obj) {\n\t\t\tif (obj.observe) obj.observe(prop, obs, this, {noChain: true, priority: true});\n\t\t\tthis.connected = true;\n\t\t\tthis.list.connected++;\n\t\t}\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tdisconnect: function () {\n\t\tvar obj = this.object\n\t\t\t, obs = this._changed\n\t\t\t, prop = this.property\n\t\t\t, was = this.connected;\n\t\tobj && obj.unobserve && obj.unobserve(prop, obs, this);\n\t\tthis.connected = null;\n\t\tif (was) this.list.connected--;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tsetObject: function (object) {\n\t\tvar cur = this.object\n\t\t\t, prop = this.property\n\t\t\t, was, is;\n\t\t\n\t\tif (cur !== object) {\n\t\t\tthis.disconnect();\n\t\t\tthis.object = object;\n\t\t\tthis.connect();\n\t\t\t\n\t\t\tif (this.list.tail === this) {\n\t\t\t\twas = get(cur, prop);\n\t\t\t\tis = get(object, prop);\n\t\t\t\t// @TODO: It would be better to somehow cache values\n\t\t\t\t// such that it could intelligently derive the difference\n\t\t\t\t// without needing to continuously look it up with get\n\t\t\t\twas !== is && this.list.observed(this, was, is);\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\t_changed: function (was, is) {\n\t\tthis.list.observed(this, was, is);\n\t}\n});\n",
    "mtime": 1542469884323,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ObserverChainNode.js",
    "relPath": "enyo/ObserverChainNode",
    "requires": [
      "enyo",
      "./kind",
      "./LinkedListNode"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./BindingSupport",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/BindingSupport",
    "name": "enyo/BindingSupport",
    "isFile": true,
    "contents": "/**\n* Exports the {@link module:enyo/BindingSupport~BindingSupport} mixin\n* @module enyo/BindingSupport\n*/\n\nrequire('enyo');\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils');\n\nvar\n\tBinding = require('./Binding');\n\nkind.concatenated.push('bindings');\n\n/**\n* An internally-used {@glossary mixin} that is added to {@link module:enyo/CoreObject~Object}\n* and its [subkinds]{@glossary subkind}. It includes public and protected API\n* methods for working with [bindings]{@link module:enyo/Binding~Binding}.\n*\n* @mixin\n* @protected\n*/\nvar BindingSupport = {\n\t\n\t/**\n\t* @private\n\t*/\n\tname: 'BindingSupport',\n\t\n\t/**\n\t* @private\n\t*/\n\t_bindingSupportInitialized: false,\n\t\n\t/**\n\t* Imperatively creates a [binding]{@link module:enyo/Binding~Binding}. Merges a variable\n\t* number of [hashes]{@glossary Object} and instantiates a binding that\n\t* will have its [owner]{@link module:enyo/Binding~Binding#owner} property set to the callee\n\t* (the current {@link module:enyo/CoreObject~Object}). Bindings created in this way will be\n\t* [destroyed]{@link module:enyo/Binding~Binding#destroy} when their `owner` is\n\t* [destroyed]{@link module:enyo/CoreObject~Object#destroy}.\n\t*\n\t* @param {...Object} props A variable number of [hashes]{@glossary Object} that will\n\t*\tbe merged into the properties applied to the {@link module:enyo/Binding~Binding} instance.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tbinding: function () {\n\t\tvar args = utils.toArray(arguments)\n\t\t\t, props = utils.mixin(args)\n\t\t\t, bindings = this.bindings || (this.bindings = [])\n\t\t\t, passiveBindings = this.passiveBindings || (this.passiveBindings = [])\n\t\t\t, PBCtor = Binding.PassiveBinding\n\t\t\t, Ctor, bnd;\n\t\t\t\n\t\tprops.owner = props.owner || this;\n\t\tCtor = props.kind = props.kind || this.defaultBindingKind || Binding.defaultBindingKind;\n\t\t\n\t\tif (this._bindingSupportInitialized) {\n\t\t\tutils.isString(Ctor) && (Ctor = props.kind = kind.constructorForKind(Ctor));\n\t\t\tbnd = new Ctor(props);\n\t\t\tbindings.push(bnd);\n\t\t\tif (Ctor === PBCtor) {\n\t\t\t\tpassiveBindings.push(bnd);\n\t\t\t}\n\t\t\treturn bnd;\n\t\t} else bindings.push(props);\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* Removes and [destroys]{@link module:enyo/Binding~Binding#destroy} all of, or a subset of,\n\t* the [bindings]{@link module:enyo/Binding~Binding} belonging to the callee.\n\t*\n\t* @param {module:enyo/Binding~Binding[]} [subset] - The optional [array]{@glossary Array} of\n\t*\t[bindings]{@link module:enyo/Binding~Binding} to remove.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tclearBindings: function (subset) {\n\t\tvar bindings = subset || (this.bindings && this.bindings.slice());\n\t\tbindings.forEach(function (bnd) {\n\t\t\tbnd.destroy();\n\t\t});\n\t\t\n\t\treturn this;\n\t},\n\n\tsyncBindings: function (opts) {\n\t\tvar all = opts && opts.all,\n\t\t\tforce = opts && opts.force,\n\t\t\tbindings = all ? this.bindings : this.passiveBindings;\n\n\t\tbindings.forEach(function (b) {\n\t\t\tb.sync(force);\n\t\t});\n\t},\n\t\n\t/**\n\t* Removes a single {@link module:enyo/Binding~Binding} from the callee. (This does not\n\t* [destroy]{@link module:enyo/Binding~Binding#destroy} the binding.) Also removes the\n\t* [owner]{@link module:enyo/Binding~Binding#owner} reference if it is the callee.\n\t*\n\t* It should be noted that when a binding is destroyed, it is automatically\n\t* removed from its owner.\n\t*\n\t* @param {module:enyo/Binding~Binding} binding - The {@link module:enyo/Binding~Binding} instance to remove.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tremoveBinding: function (binding) {\n\t\tutils.remove(binding, this.bindings);\n\t\tif (binding.ctor === Binding.PassiveBinding) {\n\t\t\tutils.remove(binding, this.passiveBindings);\n\t\t}\n\t\t\n\t\tif (binding.owner === this) binding.owner = null;\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tconstructed: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tvar bindings = this.bindings;\n\t\t\tthis._bindingSupportInitialized = true;\n\t\t\tif (bindings) {\n\t\t\t\tthis.bindings = [];\n\t\t\t\tthis.passiveBindings = [];\n\t\t\t\tbindings.forEach(function (def) {\n\t\t\t\t\tthis.binding(def);\n\t\t\t\t}, this);\n\t\t\t}\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\t\n\t/**\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.bindings && this.bindings.length && this.clearBindings();\n\t\t\tthis.bindings = null;\n\t\t\tthis.passiveBindings = null;\n\t\t};\n\t})\n};\n\nmodule.exports = BindingSupport;\n\n/**\n\tHijack the original so we can add additional default behavior.\n*/\nvar sup = kind.concatHandler\n\t, flags = {ignore: true};\n\n/**\n* @private\n*/\nkind.concatHandler = function (ctor, props, instance) {\n\tvar proto = ctor.prototype || ctor\n\t\t, kind = props && (props.defaultBindingKind || Binding.defaultBindingKind)\n\t\t, defaults = props && props.bindingDefaults;\n\t\n\tsup.call(this, ctor, props, instance);\n\tif (props.bindings) {\n\t\tprops.bindings.forEach(function (bnd) {\n\t\t\tdefaults && utils.mixin(bnd, defaults, flags);\n\t\t\tbnd.kind || (bnd.kind = kind); \n\t\t});\n\t\t\n\t\tproto.bindings = proto.bindings? proto.bindings.concat(props.bindings): props.bindings;\n\t\tdelete props.bindings;\n\t}\n};\n",
    "mtime": 1542469884039,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/BindingSupport.js",
    "relPath": "enyo/BindingSupport",
    "requires": [
      "enyo",
      "./kind",
      "./utils",
      "./Binding"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./ObserverChain",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/ObserverChain",
    "name": "enyo/ObserverChain",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/ObserverChain~ObserverChain} kind.\n* @module enyo/ObserverChain\n*/\n\nvar\n\tkind = require('./kind');\n\nvar\n\tLinkedList = require('./LinkedList'),\n\tObserverChainNode = require('./ObserverChainNode');\n\nfunction get (base, prop) {\n\treturn base && /*isObject(base)*/ (typeof base == 'object')? (\n\t\tbase.get? base.get(prop): base[prop]\n\t): undefined;\n}\n\n/**\n* An internally used {@glossary kind}.\n*\n* @class ObserverChain\n* @extends module:enyo/LinkedList~LinkedList\n* @private\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/ObserverChain~ObserverChain.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tkind: LinkedList,\n\n\t/**\n\t* @private\n\t*/\n\tnodeKind: ObserverChainNode,\n\n\t/**\n\t* @private\n\t*/\n\n\t\n\t/**\n\t* @private\n\t*/\n\tconnected: 0,\n\t\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tconstructor: function (path, object) {\n\t\tthis.object = object;\n\t\tthis.path = path;\n\t\tthis.parts = path.split('.');\n\t\tthis.createChain();\n\t},\n\t\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.object = null;\n\t\t\tthis.parts = null;\n\t\t\tthis.path = null;\n\t\t};\n\t}),\n\t\n\t/**\n\t* @private\n\t*/\n\trebuild: function (target) {\n\t\tif (!this.rebuilding) {\n\t\t\tthis.rebuilding = true;\n\t\t\tthis.forward(function (node) {\n\t\t\t\tif (node !== this.head) {\n\t\t\t\t\tvar src = node.prev.object\n\t\t\t\t\t\t, prop = node.prev.property;\n\t\t\t\t\tnode.setObject(get(src, prop));\n\t\t\t\t}\n\t\t\t}, this, target);\n\t\t\tthis.rebuilding = false;\n\t\t}\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tisConnected: function () {\n\t\treturn !! (this.connected === this.length && this.length);\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tbuildPath: function (target) {\n\t\tvar str = '';\n\t\t\n\t\tthis.backward(function (node) {\n\t\t\tstr = node.property + (str? ('.' + str): str);\n\t\t}, this, target);\n\t\t\n\t\treturn str;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tcreateChain: function () {\n\t\tvar parts = this.parts\n\t\t\t, next = this.object\n\t\t\t, $ = false\n\t\t\t, node, prop;\n\t\t\t\n\t\tfor (var i=0; (prop=parts[i]); ++i) {\n\t\t\t\n\t\t// forEach(parts, function (prop, idx) {\n\t\t\t// we create a special case for the $ hash property\n\t\t\tif (prop == '$') {\n\t\t\t\t$ = true;\n\t\t\t} else {\n\t\t\t\t// in cases where the chain has the $ property we arbitrarily\n\t\t\t\t// force it onto our current nodes property and let the special handling\n\t\t\t\t// in ObserverChainNode and ObserverSupport handle the rest\n\t\t\t\t$ && (prop = '$.' + prop);\n\t\t\t\tnode = this.createNode({property: prop, object: next, list: this});\n\t\t\t\tthis.appendNode(node);\n\t\t\t\tnext = get(next, prop);\n\t\t\t\t$ = false;\n\t\t\t}\n\t\t// }, this);\n\t\t}\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tobserved: function (node, was, is) {\n\t\tthis.object.stopNotifications();\n\t\t// @NOTE: About the following two cases, they are mutually exclusive and this seems perfect\n\t\t// that we don't see double notifications\n\t\t// @TODO: Only notify if it was the full property path? This is far more efficient after\n\t\t// testing but not as flexible...\n\t\tnode === this.tail /*&& was !== is*/ && this.object.notify(this.buildPath(node), was, is);\n\t\t// @TODO: It seems the same case across the board that the rebuild only needs to take place\n\t\t// from the beginning to the second-to-last elem\n\t\tnode !== this.tail && was !== is && this.rebuild(node);\n\t\tthis.object.startNotifications();\n\t}\n});\n",
    "mtime": 1542469884319,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ObserverChain.js",
    "relPath": "enyo/ObserverChain",
    "requires": [
      "enyo",
      "./kind",
      "./LinkedList",
      "./ObserverChainNode"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./ObserverSupport",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/ObserverSupport",
    "name": "enyo/ObserverSupport",
    "isFile": true,
    "contents": "/**\n* Exports the {@link module:enyo/ObserverSupport~ObserverSupport} mixin\n* @module enyo/ObserverSupport\n*/\nrequire('enyo');\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils');\n\nvar\n\tObserverChain = require('./ObserverChain');\n\nvar observerTable = {};\n\t\nkind.concatenated.push(\"observers\");\n\n/**\n* Responds to changes in one or more properties.\n* [Observers]{@link module:enyo/ObserverSupport~ObserverSupport#observers} may be registered in\n* several different ways. See the {@link module:enyo/ObserverSupport} documentation\n* for more details. Also note that, while observers should not be called\n* directly, if defined on a [kind]{@glossary kind}, they may be\n* overloaded for special behavior.\n*\n* @see {@link module:enyo/ObserverSupport}\n* @see {@link module:enyo/ObserverSupport~ObserverSupport#observe}\n* @callback module:enyo/ObserverSupport~ObserverSupport~Observer\n* @param {*} was - The previous value of the property that has changed.\n* @param {*} is - The current value of the property that has changed.\n* @param {String} prop - The name of the property that has changed.\n* @public\n*/\n\nfunction addObserver (path, fn, ctx, opts) {\n\t\n\tvar observers = this.getObservers(),\n\t\tchains = this.getChains(),\n\t\tparts = path.split('.'),\n\t\tprio = opts && opts.priority,\n\t\tentries,\n\t\tnoChain;\n\t\t\n\tnoChain = (opts && opts.noChain) ||\n\t\t\tchains[path] ||\n\t\t\tparts.length < 2 ||\n\t\t\t(parts.length === 2 && path[0] == '$');\n\t\n\tif (observers[path] && !observers.hasOwnProperty(path)) {\n\t\tobservers[path] = observers[path].slice();\n\t}\n\t\n\tentries = observers[path] || (observers[path] = []);\n\tentries[prio ? 'unshift' : 'push']({method: fn, ctx: ctx || this});\n\t\n\tif (!noChain) {\n\t\tthis.getChains()[path] = new ObserverChain(path, this);\n\t}\n\t\n\treturn this;\n}\n\nfunction removeObserver (obj, path, fn, ctx) {\n\tvar observers = obj.getObservers(path)\n\t\t, chains = obj.getChains()\n\t\t, idx, chain;\n\t\t\n\tif (observers && observers.length) {\n\t\tidx = observers.findIndex(function (ln) {\n\t\t\treturn ln.method === fn && (ctx? ln.ctx === ctx: true);\n\t\t});\n\t\tidx > -1 && observers.splice(idx, 1);\n\t}\n\t\n\tif ((chain = chains[path]) && !observers.length) {\n\t\tchain.destroy();\n\t}\n\t\n\treturn obj;\n}\n\nfunction notifyObservers (obj, path, was, is, opts) {\n\tif (obj.isObserving()) {\n\t\tvar observers = obj.getObservers(path);\n\t\t\n\t\tif (observers && observers.length) {\n\t\t\tfor (var i=0, ln; (ln=observers[i]); ++i) {\n\t\t\t\tif (typeof ln.method == \"string\") obj[ln.method](was, is, path, opts);\n\t\t\t\telse ln.method.call(ln.ctx || obj, was, is, path, opts);\n\t\t\t}\n\t\t}\n\t} else enqueue(obj, path, was, is, opts);\n\t\n\treturn obj;\n}\n\nfunction enqueue (obj, path, was, is, opts) {\n\tif (obj._notificationQueueEnabled) {\n\t\tvar queue = obj._notificationQueue || (obj._notificationQueue = {})\n\t\t\t, ln = queue[path] || (queue[path] = {});\n\t\n\t\tln.was = was;\n\t\tln.is = is;\n\t\tln.opts = opts;\n\t}\n}\n\nfunction flushQueue (obj) {\n\tvar queue = obj._notificationQueue\n\t\t, path, ln;\n\t\n\tif (queue) {\n\t\tobj._notificationQueue = null;\n\t\t\n\t\tfor (path in queue) {\n\t\t\tln = queue[path];\n\t\t\tobj.notify(path, ln.was, ln.is, ln.opts);\n\t\t}\n\t}\n}\n\t\n/**\n* Adds support for notifications on property changes. Most\n* [kinds]{@glossary kind} (including all kinds that inherit from\n* {@link module:enyo/CoreObject~Object}) already have this {@glossary mixin} applied.\n* This allows for\n* [observers]{@link module:enyo/ObserverSupport~ObserverSupport~Observer} to be\n* [declared]{@link module:enyo/ObserverSupport~ObserverSupport#observers} or \"implied\" (see below).\n*\n* Implied observers are not declared, but derived from their `name`. They take\n* the form `<property>Changed`, where `<property>` is the property to\n* [observe]{@link module:enyo/ObserverSupport~ObserverSupport#observe}. For example:\n*\n* ```javascript\n* var\n* \tkind = require('enyo/kind');\n*\n* module.exports = kind({\n* \tname: 'MyKind',\n*\n* \t// some local property\n* \tvalue: true,\n*\n* \t// and the implied observer of that property\n* \tvalueChanged: function (was, is) {\n* \t\t// do something now that it has changed\n* \t\tenyo.log('value was \"' + was + '\" but now it is \"' + is + '\"');\n* \t}\n* });\n*\n* var mine = new MyKind();\n* mine.set('value', false); // -> value was \"true\" but now it is \"false\"\n* ```\n*\n* Using the `observers` property for its declarative syntax, an observer may\n* observe any property (or properties), regardless of its `name`. For example:\n*\n* ```javascript\n* var\n* \tkind = require('enyo/kind');\n*\n* module.exports = kind({\n* \tname: 'MyKind',\n*\n* \t// some local property\n* \tvalue: true,\n*\n* \t// another local property\n* \tcount: 1,\n*\n* \t// declaring the observer\n* \tobservers: [\n* \t\t// the path can be a single string or an array of strings\n* \t\t{method: 'myObserver', path: ['value', 'count']}\n* \t],\n*\n* \t// now this observer will be notified of changes to both properties\n* \tmyObserver: function (was, is, prop) {\n* \t\t// do something now that it changed\n* \t\tenyo.log(prop + ' was \"' + was + '\" but now it is \"' + is + '\"');\n* \t}\n* });\n*\n* var mine = new MyKind();\n* mine.set('value', false); // -> value was \"true\" but now it is \"false\"\n* mine.set('count', 2); // -> count was \"1\" but now it is \"2\"\n* ```\n*\n* While observers may be [notified]{@link module:enyo/ObserverSupport~ObserverSupport#notify} of\n* changes to multiple properties, this is not a typical use case for implied\n* observers, since, by convention, they are only registered for the named\n* property.\n*\n* There is one additional way to use observers, if necessary. You may use the\n* API methods [observe()]{@link module:enyo/ObserverSupport~ObserverSupport#observe} and\n* [unobserve()]{@link module:enyo/ObserverSupport~ObserverSupport#unobserve} to dynamically\n* register and unregister observers as needed. For example:\n*\n* ```javascript\n* var\n* \tObject = require('enyo/CoreObject').Object;\n*\n* var object = new Object({value: true});\n* var observer = function (was, is) {\n* \tenyo.log('value was \"' + was + '\" but now it is \"' + is + '\"');\n* };\n*\n* object.observe('value', observer);\n* object.set('value', false); // -> value was \"true\" but now it is \"false\"\n* object.unobserve('value', observer);\n* object.set('value', true); // no output because there is no observer\n* ```\n*\n* Be sure to read the documentation for these API methods; proper usage of\n* these methods is important for avoiding common pitfalls and memory leaks.\n*\n* @mixin\n* @public\n*/\nvar ObserverSupport = {\n\t\n\t/**\n\t* @private\n\t*/\n\tname: \"ObserverSupport\",\n\t\n\t/**\n\t* @private\n\t*/\n\t_observing: true,\n\t\n\t/**\n\t* @private\n\t*/\n\t_observeCount: 0,\n\t\n\t/**\n\t* @private\n\t*/\n\t_notificationQueue: null,\n\t\n\t/**\n\t* @private\n\t*/\n\t_notificationQueueEnabled: true,\n\t\n\t/**\n\t* Determines whether `_observing` is enabled. If\n\t* [stopNotifications()]{@link module:enyo/ObserverSupport~ObserverSupport#stopNotifications} has\n\t* been called, then this will return `false`.\n\t*\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#stopNotifications}\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#startNotifications}\n\t* @returns {Boolean} Whether or not the callee is observing.\n\t*/\n\tisObserving: function () {\n\t\treturn this._observing;\n\t},\n\t\n\t/**\n\t* Returns an immutable list of [observers]{@link module:enyo/ObserverSupport~ObserverSupport~Observer}\n\t* for the given `path`, or all observers for the callee.\n\t*\n\t* @param {String} [path] - Path or property path for which\n\t* [observers]{@link module:enyo/ObserverSupport~ObserverSupport~Observer} will be returned. If not\n\t* specified, all observers for the callee will be returned.\n\t*\n\t* @returns {module:enyo/ObserverSupport~ObserverSupport~Observer[]} The immutable\n\t* [array]{@glossary Array} of observers.\n\t* @public\n\t*/\n\tgetObservers: function (path) {\n\t\tvar euid = this.euid || (this.euid = utils.uid('o')),\n\t\t\tret,\n\t\t\tloc;\n\t\t\t\n\t\tloc = observerTable[euid] || (observerTable[euid] = (\n\t\t\tthis._observers? Object.create(this._observers): {}\n\t\t));\n\t\t\n\t\tif (!path) return loc;\n\t\t\n\t\tret = loc[path];\n\t\t\n\t\t// if the special property exists...\n\t\tif (loc['*']) ret = ret ? ret.concat(loc['*']) : loc['*'].slice();\n\t\treturn ret;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tgetChains: function () {\n\t\treturn this._observerChains || (this._observerChains = {});\n\t},\n\t\n\t/**\n\t* @deprecated\n\t* @alias {@link module:enyo/ObserverSupport~ObserverSupport#observe}\n\t* @public\n\t*/\n\taddObserver: function () {\n\t\t// @NOTE: In this case we use apply because of internal variable use of parameters\n\t\treturn addObserver.apply(this, arguments);\n\t},\n\t\n\t/**\n\t* Registers an [observer]{@link module:enyo/ObserverSupport~ObserverSupport~Observer} to be\n\t* [notified]{@link module:enyo/ObserverSupport~ObserverSupport#notify} when the given property has\n\t* been changed. It is important to note that it is possible to register the\n\t* same observer multiple times (although this is never the intention), so\n\t* care should be taken to avoid that scenario. It is also important to\n\t* understand how observers are stored and unregistered\n\t* ([unobserved]{@link module:enyo/ObserverSupport~ObserverSupport#unobserve}). The `ctx` (context)\n\t* parameter is stored with the observer reference. **If used when\n\t* registering, it should also be used when unregistering.**\n\t*\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#unobserve}\n\t* @param {String} path - The property or property path to observe.\n\t* @param {module:enyo/ObserverSupport~ObserverSupport~Observer} fn - The\n\t*\t[observer]{@link module:enyo/ObserverSupport~ObserverSupport~Observer} method that responds to changes.\n\t* @param {*} [ctx] - The `this` (context) under which to execute the observer.\n\t*\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tobserve: function () {\n\t\t// @NOTE: In this case we use apply because of internal variable use of parameters\n\t\treturn addObserver.apply(this, arguments);\n\t},\n\t\n\t/**\n\t* @deprecated\n\t* @alias {@link module:enyo/ObserverSupport~ObserverSupport#unobserve}\n\t* @public\n\t*/\n\tremoveObserver: function (path, fn, ctx) {\n\t\treturn removeObserver(this, path, fn);\n\t},\n\t\n\t/**\n\t* Unregisters an [observer]{@link module:enyo/ObserverSupport~ObserverSupport~Observer}. If a `ctx`\n\t* (context) was supplied to [observe()]{@link module:enyo/ObserverSupport~ObserverSupport#observe},\n\t* then it should also be supplied to this method.\n\t*\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#observe}\n\t* @param {String} path - The property or property path to unobserve.\n\t* @param {module:enyo/ObserverSupport~ObserverSupport~Observer} fn - The\n\t*\t[observer]{@link module:enyo/ObserverSupport~ObserverSupport~Observer} method that responds to changes.\n\t* @param {*} [ctx] - The `this` (context) under which to execute the observer.\n\t*\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tunobserve: function (path, fn, ctx) {\n\t\treturn removeObserver(this, path, fn, ctx);\n\t},\n\t\n\t/**\n\t* Removes all [observers]{@link module:enyo/ObserverSupport~ObserverSupport~Observer} from the\n\t* callee. If a `path` parameter is provided, observers will only be removed\n\t* from that path (or property).\n\t*\n\t* @param {String} [path] - A property or property path from which to remove all\n\t*\t[observers]{@link module:enyo/ObserverSupport~ObserverSupport~Observer}.\n\t* @returns {this} The callee for chaining.\n\t*/\n\tremoveAllObservers: function (path) {\n\t\tvar euid = this.euid\n\t\t\t, loc = euid && observerTable[euid];\n\t\t\n\t\tif (loc) {\n\t\t\tif (path) {\n\t\t\t\tloc[path] = null;\n\t\t\t} else {\n\t\t\t\tdelete observerTable[euid];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* @deprecated\n\t* @alias module:enyo/ObserverSupport~ObserverSupport#notify\n\t* @public\n\t*/\n\tnotifyObservers: function (path, was, is, opts) {\n\t\treturn notifyObservers(this, path, was, is, opts);\n\t},\n\t\n\t/**\n\t* Triggers any [observers]{@link module:enyo/ObserverSupport~ObserverSupport~Observer} for the\n\t* given `path`. The previous and current values must be supplied. This\n\t* method is typically called automatically, but it may also be called\n\t* forcibly by [setting]{@link module:enyo/CoreObject~Object#set} a value with the\n\t* `force` option.\n\t*\n\t* @param {String} path - The property or property path to notify.\n\t* @param {*} was - The previous value.\n\t* @param {*} is - The current value.\n\t* @returns {this} The callee for chaining.\n\t*/\n\tnotify: function (path, was, is, opts) {\n\t\treturn notifyObservers(this, path, was, is, opts);\n\t},\n\t\n\t/**\n\t* Stops all [notifications]{@link module:enyo/ObserverSupport~ObserverSupport#notify} from\n\t* propagating. By default, all notifications will be queued and flushed once\n\t* [startNotifications()]{@link module:enyo/ObserverSupport~ObserverSupport#startNotifications}\n\t* has been called. Setting the optional `noQueue` flag will also disable the\n\t* queue, or you can use the\n\t* [disableNotificationQueue()]{@link module:enyo/ObserverSupport~ObserverSupport#disableNotificationQueue} and\n\t* [enableNotificationQueue()]{@link module:enyo/ObserverSupport~ObserverSupport#enableNotificationQueue}\n\t* API methods. `startNotifications()` will need to be called the same number\n\t* of times that this method has been called.\n\t*\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#startNotifications}\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#disableNotificationQueue}\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#enableNotificationQueue}\n\t* @param {Boolean} [noQueue] - If `true`, this will also disable the notification queue.\n\t* @returns {this} The callee for chaining.\n\t*/\n\tstopNotifications: function (noQueue) {\n\t\tthis._observing = false;\n\t\tthis._observeCount++;\n\t\tnoQueue && this.disableNotificationQueue();\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* Starts [notifications]{@link module:enyo/ObserverSupport~ObserverSupport#notify} if they have\n\t* been [disabled]{@link module:enyo/ObserverSupport~ObserverSupport#stopNotifications}. If the\n\t* notification queue was not disabled, this will automatically flush the\n\t* queue of all notifications that were encountered while stopped. This\n\t* method must be called the same number of times that\n\t* [stopNotifications()]{@link module:enyo/ObserverSupport~ObserverSupport#stopNotifications} was\n\t* called.\n\t*\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#stopNotifications}\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#disableNotificationQueue}\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#enableNotificationQueue}\n\t* @param {Boolean} [queue] - If `true` and the notification queue is disabled,\n\t* the queue will be re-enabled.\n\t* @returns {this} The callee for chaining.\n\t*/\n\tstartNotifications: function (queue) {\n\t\tthis._observeCount && this._observeCount--;\n\t\tthis._observeCount === 0 && (this._observing = true);\n\t\tqueue && this.enableNotificationQueue();\n\t\tthis.isObserving() && flushQueue(this);\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* Re-enables the notification queue, if it was disabled.\n\t*\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#disableNotificationQueue}\n\t* @returns {this} The callee for chaining.\n\t*/\n\tenableNotificationQueue: function () {\n\t\tthis._notificationQueueEnabled = true;\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* If the notification queue is enabled (the default), it will be disabled\n\t* and any notifications in the queue will be removed.\n\t*\n\t* @see {@link module:enyo/ObserverSupport~ObserverSupport#enableNotificationQueue}\n\t* @returns {this} The callee for chaining.\n\t*/\n\tdisableNotificationQueue: function () {\n\t\tthis._notificationQueueEnabled = false;\n\t\tthis._notificationQueue = null;\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tconstructor: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tvar chains, chain, path, entries, i;\n\t\t\t\n\t\t\t// if there are any observers that need to create dynamic chains\n\t\t\t// we look for and instance those now\n\t\t\tif (this._observerChains) {\n\t\t\t\tchains = this._observerChains;\n\t\t\t\tthis._observerChains = {};\n\t\t\t\tfor (path in chains) {\n\t\t\t\t\tentries = chains[path];\n\t\t\t\t\tfor (i = 0; (chain = entries[i]); ++i) this.observe(path, chain.method);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\t\n\t/**\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tvar chains = this._observerChains,\n\t\t\t\tpath,\n\t\t\t\tchain;\n\t\t\t\n\t\t\tsup.apply(this, arguments);\n\n\t\t\tthis.removeAllObservers();\n\t\t\tif (chains) {\n\t\t\t\tfor (path in chains) {\n\t\t\t\t\tchain = chains[path];\n\t\t\t\t\tchain.destroy();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis._observerChains = null;\n\t\t\t}\n\t\t};\n\t})\n\t\n};\n\nmodule.exports = ObserverSupport;\n\n/**\n* Hijack the original so we can add additional default behavior.\n*\n* @private\n*/\nvar sup = kind.concatHandler;\n\n// @NOTE: It seems like a lot of work but it really won't happen that much and the more\n// we push to kind-time the better for initialization time\n\n/** @private */\nkind.concatHandler = function (ctor, props, instance) {\n\t\n\tsup.call(this, ctor, props, instance);\n\t\n\tif (props === ObserverSupport) return;\n\n\tvar proto = ctor.prototype || ctor\n\t\t, observers = proto._observers? Object.create(proto._observers): null\n\t\t, incoming = props.observers\n\t\t, chains = proto._observerChains && Object.create(proto._observerChains);\n\t\t\n\tif (!observers) {\n\t\tif (proto.kindName) observers = {};\n\t\telse return;\n\t}\n\t\t\n\tif (incoming && !(incoming instanceof Array)) {\n\t\t(function () {\n\t\t\tvar tmp = [], deps, name;\n\t\t\t// here is the slow iteration over the properties...\n\t\t\tfor (name in props.observers) {\n\t\t\t\t// points to the dependencies of the computed method\n\t\t\t\tdeps = props.observers[name];\n\t\t\t\t// create a single entry now for the method/computed with all dependencies\n\t\t\t\ttmp.push({method: name, path: deps});\n\t\t\t}\n\t\t\tincoming = tmp;\n\t\t}());\n\t\t// we need to ensure we don't modify the fixed array of a mixin or reused object\n\t\t// because it could wind up inadvertantly adding the same entry multiple times\n\t} else if (incoming) incoming = incoming.slice();\n\t\n\t// this scan is required to figure out what auto-observers might be present\n\tfor (var key in props) {\n\t\tif (key.slice(-7) == \"Changed\") {\n\t\t\tincoming || (incoming = []);\n\t\t\tincoming.push({method: key, path: key.slice(0, -7)});\n\t\t}\n\t}\n\t\n\tvar addObserverEntry = function (path, method) {\n\t\tvar obs;\n\t\t// we have to make sure that the path isn't a chain because if it is we add it\n\t\t// to the chains instead\n\t\tif (path.indexOf(\".\") > -1) {\n\t\t\tif (!chains) chains = {};\n\t\t\tobs = chains[path] || (chains[path] = []);\n\t\t\tobs.push({method: method});\n\t\t} else {\n\t\t\tif (observers[path] && !observers.hasOwnProperty(path)) observers[path] = observers[path].slice();\n\t\t\tobs = observers[path] || (observers[path] = []);\n\t\t\tif (!obs.find(function (ln) { return ln.method == method; })) obs.push({method: method});\n\t\t}\n\t};\n\t\n\tif (incoming) {\n\t\tincoming.forEach(function (ln) {\n\t\t\t// first we determine if the path itself is an array of paths to observe\n\t\t\tif (ln.path && ln.path instanceof Array) ln.path.forEach(function (en) { addObserverEntry(en, ln.method); });\n\t\t\telse addObserverEntry(ln.path, ln.method);\n\t\t});\n\t}\n\t\n\t// we clear the key so it will not be added to the prototype\n\t// delete props.observers;\n\t// we update the properties to whatever their new values may be\n\tproto._observers = observers;\n\tproto._observerChains = chains;\n};\n",
    "mtime": 1542469884327,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ObserverSupport.js",
    "relPath": "enyo/ObserverSupport",
    "requires": [
      "enyo",
      "./kind",
      "./utils",
      "./ObserverChain"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./CoreObject",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/CoreObject",
    "name": "enyo/CoreObject",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/CoreObject~Object} kind.\n* @module enyo/CoreObject\n*/\n\nvar\n\tkind = require('./kind'),\n\tlogger = require('./logger'),\n\tutils = require('./utils');\n\nvar\n\tMixinSupport = require('./MixinSupport'),\n\tObserverSupport = require('./ObserverSupport'),\n\tBindingSupport = require('./BindingSupport');\n\n// ComputedSupport is applied to all kinds at creation time but must be require()'d somewhere to be\n// included in builds. This is that somewhere.\nrequire('./ComputedSupport');\n\n/**\n* Used by all [objects]{@link module:enyo/CoreObject~Object} and [subkinds]{@glossary subkind} when using the\n* {@link module:enyo/CoreObject~Object#log}, {@link module:enyo/CoreObject~Object#warn} and {@link module:enyo/CoreObject~Object#error} methods.\n*\n* @private\n*/\nfunction log (method, args) {\n\tif (logger.shouldLog(method)) {\n\t\ttry {\n\t\t\tthrow new Error();\n\t\t} catch(err) {\n\t\t\tlogger._log(method, [args.callee.caller.displayName + ': ']\n\t\t\t\t.concat(utils.cloneArray(args)));\n\t\t\tlogger.log(err.stack);\n\t\t}\n\t}\n}\n\n/**\n* {@link module:enyo/CoreObject~Object} lies at the heart of the Enyo framework's implementations of property\n* publishing, computed properties (via the [ComputedSupport]{@link module:enyo/ComputedSupport}\n* {@glossary mixin}), and data binding (via the {@link module:enyo/BindingSupport~BindingSupport} mixin and\n* {@link module:enyo/Binding~Binding} object). It also provides several utility [functions]{@glossary Function}\n* for its [subkinds]{@glossary subkind}.\n*\n* @class Object\n* @mixes module:enyo/MixinSupport\n* @mixes module:enyo/ObserverSupport\n* @mixes module:enyo/BindingSupport\n* @public\n*/\nvar CoreObject = module.exports = kind(\n\t/** @lends module:enyo/CoreObject~Object.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.Object',\n\n\t/**\n\t* @private\n\t*/\n\tkind: null,\n\n\t/**\n\t* @private\n\t*/\n\n\n\t/**\n\t* Will be `true` if the [destroy()]{@link module:enyo/CoreObject~Object#destroy} method has been called;\n\t* otherwise, `false`.\n\t*\n\t* @readonly\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\tdestroyed: false,\n\n\t/**\n\t* @private\n\t*/\n\tmixins: [MixinSupport, ObserverSupport, BindingSupport],\n\n\t/**\n\t* @private\n\t*/\n\tconstructor: function (props) {\n\t\tthis.importProps(props);\n\t},\n\n\t/**\n\t* Imports the values from the given [object]{@glossary Object}. Automatically called\n\t* from the [constructor]{@link module:enyo/CoreObject~Object#constructor}.\n\t*\n\t* @param {Object} props - If provided, the [object]{@glossary Object} from which to\n\t*\tretrieve [keys/values]{@glossary Object.keys} to mix in.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\timportProps: function (props) {\n\t\tvar key;\n\n\t\tif (props) {\n\t\t\tkind.concatHandler(this, props, true);\n\t\t\t// if props is a default hash this is significantly faster than\n\t\t\t// requiring the hasOwnProperty check every time\n\t\t\tif (!props.kindName) {\n\t\t\t\tfor (key in props) {\n\t\t\t\t\tkind.concatenated.indexOf(key) === -1 && (this[key] = props[key]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (key in props) {\n\t\t\t\t\tif (kind.concatenated.indexOf(key) === -1 && props.hasOwnProperty(key)) {\n\t\t\t\t\t\tthis[key] = props[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* Calls the [destroy()]{@link module:enyo/CoreObject~Object#destroy} method for the named {@link module:enyo/CoreObject~Object} \n\t* property.\n\t*\n\t* @param {String} name - The name of the property to destroy, if possible.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tdestroyObject: function (name) {\n\t\tif (this[name] && this[name].destroy) {\n\t\t\tthis[name].destroy();\n\t\t}\n\t\tthis[name] = null;\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* Sends a log message to the [console]{@glossary console}, prepended with the name\n\t* of the {@glossary kind} and method from which `log()` was invoked. Multiple\n\t* {@glossary arguments} are coerced to {@glossary String} and\n\t* [joined with spaces]{@glossary Array.join}.\n\t*\n\t* ```javascript\n\t* var kind = require('enyo/kind'),\n\t*     Object = require('enyo/CoreObject');\n\t* kind({\n\t*\tname: 'MyObject',\n\t*\tkind: Object,\n\t*\thello: function() {\n\t*\t\tthis.log('says', 'hi');\n\t*\t\t// shows in the console: MyObject.hello: says hi\n\t*\t}\n\t* });\n\t* ```\n\t* @public\n\t*/\n\tlog: function () {\n\t\tvar acc = arguments.callee.caller,\n\t\t\tnom = ((acc ? acc.displayName : '') || '(instance method)') + ':',\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\targs.unshift(nom);\n\t\tlogger.log('log', args);\n\t},\n\t\n\t/**\n\t* Same as [log()]{@link module:enyo/CoreObject~Object#log}, except that it uses the \n\t* console's [warn()]{@glossary console.warn} method (if it exists).\n\t*\n\t* @public\n\t*/\n\twarn: function () {\n\t\tlog('warn', arguments);\n\t},\n\t\n\t/**\n\t* Same as [log()]{@link module:enyo/CoreObject~Object#log}, except that it uses the \n\t* console's [error()]{@glossary console.error} method (if it exists).\n\t*\n\t* @public\n\t*/\n\terror: function () {\n\t\tlog('error', arguments);\n\t},\n\n\t/**\n\t* Retrieves the value for the given path. The value may be retrieved as long as the given \n\t* path is resolvable relative to the given {@link module:enyo/CoreObject~Object}. See\n\t* [getPath()]{@link module:enyo/utils#getPath} for complete details.\n\t*\n\t* This method is backwards-compatible and will automatically call any existing getter\n\t* method that uses the \"getProperty\" naming convention. (Moving forward, however, Enyo code\n\t* should use [computed properties]{@link module:enyo/ComputedSupport} instead of relying on the\n\t* getter naming convention.)\n\t*\n\t* @param {String} path - The path from which to retrieve a value.\n\t* @returns {*} The value for the given path or [undefined]{@glossary undefined} if \n\t*\tthe path could not be completely resolved.\n\t* @public\n\t*/\n\tget: function () {\n\t\treturn utils.getPath.apply(this, arguments);\n\t},\n\t\n\t/**\n\t* Updates the value for the given path. The value may be set as long as the\n\t* given path is resolvable relative to the given {@link module:enyo/CoreObject~Object}. See\n\t* [setPath()]{@link module:enyo/utils#setPath} for complete details.\n\t*\n\t* @param {String} path - The path for which to set the given value.\n\t* @param {*} value - The value to set.\n\t* @param {Object} [opts] - An options hash.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tset: function () {\n\t\treturn utils.setPath.apply(this, arguments);\n\t},\n\n\t/**\n\t* Binds a [callback]{@glossary callback} to this [object]{@link module:enyo/CoreObject~Object}.\n\t* If the object has been destroyed, the bound method will be aborted cleanly,\n\t* with no value returned.\n\t*\n\t* This method should generally be used instead of {@link module:enyo/utils#bind} for running\n\t* code in the context of an instance of {@link module:enyo/CoreObject~Object} or one of its\n\t* [subkinds]{@glossary subkind}.\n\t*\n\t* @public\n\t*/\n\tbindSafely: function () {\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\targs.unshift(this);\n\t\treturn utils.bindSafely.apply(null, args);\n\t},\n\t\n\t/**\n\t* An abstract method (primarily) that sets the [destroyed]{@link module:enyo/CoreObject~Object#destroyed} \n\t* property to `true`.\n\t*\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tdestroy: function () {\n\t\t\n\t\t// Since JS objects are never truly destroyed (GC'd) until all references are\n\t\t// gone, we might have some delayed action on this object that needs access\n\t\t// to this flag.\n\t\t// Using this.set to make the property observable\n\t\treturn this.set('destroyed', true);\n\t}\n});\n\n/**\n* @private\n*/\nCoreObject.concat = function (ctor, props) {\n\tvar pubs = props.published,\n\t\tcpy,\n\t\tprop;\n\t\t\n\tif (pubs) {\n\t\tcpy = ctor.prototype || ctor;\n\t\tfor (prop in pubs) {\n\t\t\t// need to make sure that even though a property is 'published'\n\t\t\t// it does not overwrite any computed properties\n\t\t\tif (props[prop] && typeof props[prop] == 'function') continue;\n\t\t\taddGetterSetter(prop, pubs[prop], cpy);\n\t\t}\n\t}\n};\n\n/**\n* This method creates a getter/setter for a published property of an {@link module:enyo/CoreObject~Object}, but is\n* deprecated. It is maintained for purposes of backwards compatibility. The preferred method is \n* to mark public and protected (private) methods and properties using documentation or other \n* means and rely on the [get]{@link module:enyo/CoreObject~Object#get} and [set]{@link module:enyo/CoreObject~Object#set} methods of\n* {@link module:enyo/CoreObject~Object} instances.\n*\n* @private\n*/\nfunction addGetterSetter (prop, value, proto) {\n\t\n\t// so we don't need to re-execute this over and over and over...\n\tvar cap = utils.cap(prop),\n\t\tgetName = 'get' + cap,\n\t\tsetName = 'set' + cap,\n\t\tgetters = proto._getters || (proto._getters = {}),\n\t\tsetters = proto._setters || (proto._setters = {}),\n\t\tfn;\n\t\n\t// we assign the default value from the published block to the prototype\n\t// so it will be initialized properly\n\tproto[prop] = value;\n\t\n\t// check for a supplied getter and if there isn't one we create one otherwise\n\t// we mark the supplied getter in the tracking object so the global getPath will\n\t// know about it\n\tif (!(fn = proto[getName]) || typeof fn != 'function') {\n\t\tfn = proto[getName] = function () {\n\t\t\treturn utils.getPath.fast.call(this, prop);\n\t\t};\n\t\t\n\t\t// and we mark it as generated\n\t\tfn.generated = true;\n\t} else if (fn && typeof fn == 'function' && !fn.generated) getters[prop] = getName;\n\t\n\t// we need to do the same thing for the setters\n\tif (!(fn = proto[setName]) || typeof fn != 'function') {\n\t\tfn = proto[setName] = function (val) {\n\t\t\treturn utils.setPath.fast.call(this, prop, val);\n\t\t};\n\t\t\n\t\t// and we mark it as generated\n\t\tfn.generated = true;\n\t} else if (fn && typeof fn == 'function' && !fn.generated) setters[prop] = setName;\n}\n",
    "mtime": 1542469884115,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/CoreObject.js",
    "relPath": "enyo/CoreObject",
    "requires": [
      "enyo",
      "./kind",
      "./logger",
      "./utils",
      "./MixinSupport",
      "./ObserverSupport",
      "./BindingSupport",
      "./ComputedSupport"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./jobs",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/jobs",
    "name": "enyo/jobs",
    "isFile": true,
    "contents": "require('enyo');\n\nvar\n\tutils = require('./utils'),\n\tkind = require('./kind');\n\t\nvar CoreObject = require('./CoreObject');\n\n/**\n* The {@link module:enyo/jobs} singleton provides a mechanism for queueing tasks\n* (i.e., functions) for execution in order of priority. The execution of the\n* current job stack may be blocked programmatically by setting a priority\n* level (run level) below which no jobs are executed.\n*\n* At the moment, only {@link module:enyo/Animator~Animator} uses this interface, setting a\n* priority of 4, which blocks all low priority tasks from executing during\n* animations. To maintain backward compatibility, jobs are assigned a priority\n* of 5 by default; thus they are not blocked by animations.\n*\n* Normally, application code will not use `enyo/jobs` directly, but will\n* instead use the [job()]{@link module:enyo/Component~Component#job} method of\n* {@link module:enyo/Component~Component}.\n*\n* @module enyo/jobs\n* @public\n*/\nmodule.exports = kind.singleton(\n\t/** @lends module:enyo/jobs */ {\n\t\n\tkind: CoreObject,\n\t\n\t/**\n\t* @private\n\t*/\n\tpublished: /** @lends module:enyo/jobs~jobs */ {\n\t\t\n\t\t/**\n\t\t* The current priority level.\n\t\t*\n\t\t* @type {Number}\n\t\t* @default 0\n\t\t* @public\n\t\t*/\n\t\tpriorityLevel: 0\n\t},\n\t\n\t/**\n\t* Prioritized by index.\n\t*\n\t* @private\n\t*/\n\t_jobs: [ [], [], [], [], [], [], [], [], [], [] ],\n\t\n\t/**\n\t* @private\n\t*/\n\t_priorities: {},\n\t\n\t/**\n\t* @private\n\t*/\n\t_namedJobs: {},\n\t\n\t/**\n\t* @private\n\t*/\n\t_magicWords: {\n\t\t'low': 3,\n\t\t'normal': 5,\n\t\t'high': 7\n\t},\n\t\n\t/**\n\t* Adds a [job]{@link module:enyo/job} to the job queue. If the current priority\n\t* level is higher than this job's priority, this job gets deferred until the\n\t* job level drops; if it is lower, this job is run immediately.\n\t*\n\t* @param {Function} job - The actual {@glossary Function} to execute as the\n\t* [job]{@link module:enyo/job}.\n\t* @param {Number} priority - The priority of the job.\n\t* @param {String} nom - The name of the job for later reference.\n\t* @public\n\t*/\n\tadd: function (job, priority, nom) {\n\t\tpriority = priority || 5;\n\n\t\t// magic words: low = 3, normal = 5, high = 7\n\t\tpriority = utils.isString(priority) ? this._magicWords[priority] : priority;\n\n\t\t// if a job of the same name exists, remove it first (replace it)\n\t\tif(nom){\n\t\t\tthis.remove(nom);\n\t\t\tthis._namedJobs[nom] = priority;\n\t\t}\n\n\t\t// if the job is of higher priority than the current priority level then\n\t\t// there's no point in queueing it\n\t\tif(priority >= this.priorityLevel){\n\t\t\tjob();\n\t\t} else {\n\t\t\tthis._jobs[priority - 1].push({fkt: job, name: nom});\n\t\t}\n\t},\n\t\n\t/**\n\t* Will remove the named [job]{@link module:enyo/job} from the queue.\n\t*\n\t* @param {String} nom - The name of the [job]{@link module:enyo/job} to remove.\n\t* @returns {Array} An {@glossary Array} that will contain the removed job if\n\t* it was found, or empty if it was not found.\n\t* @public\n\t*/\n\tremove: function (nom) {\n\t\tvar jobs = this._jobs[this._namedJobs[nom] - 1];\n\t\tif(jobs){\n\t\t\tfor(var j = jobs.length-1; j >= 0; j--){\n\t\t\t\tif(jobs[j].name === nom){\n\t\t\t\t\treturn jobs.splice(j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t* Adds a new priority level at which jobs will be executed. If it is higher than the\n\t* highest current priority, the priority level rises. Newly added jobs below that priority\n\t* level are deferred until the priority is removed (i.e., unregistered).\n\t*\n\t* @param {Number} priority - The priority value to register.\n\t* @param {String} id - The name of the priority.\n\t* @public\n\t*/\n\tregisterPriority: function(priority, id) {\n\t\tthis._priorities[id] = priority;\n\t\tthis.setPriorityLevel( Math.max(priority, this.priorityLevel) );\n\t},\n\t\n\t/**\n\t* Removes a priority level. If the removed priority was previously the\n\t* highest priority, the priority level drops to the next highest priority\n\t* and queued jobs with a higher priority are executed.\n\t*\n\t* @param {String} id - The name of the priority level to remove.\n\t* @public\n\t*/\n\tunregisterPriority: function (id) {\n\t\tvar highestPriority = 0;\n\n\t\t// remove priority\n\t\tdelete this._priorities[id];\n\n\t\t// find new highest current priority\n\t\tfor( var i in this._priorities ){\n\t\t\thighestPriority = Math.max(highestPriority, this._priorities[i]);\n\t\t}\n\n\t\tthis.setPriorityLevel( highestPriority );\n\t},\n\t\n\t/**\n\t* Tries to run next job if priority level has dropped.\n\t*\n\t* @type {module:enyo/ObserverSupport~ObserverSupport~Observer}\n\t* @private\n\t*/\n\tpriorityLevelChanged: function (was) {\n\t\tif(was > this.priorityLevel){\n\t\t\tthis._doJob();\n\t\t}\n\t},\n\t\n\t/**\n\t* Finds and executes the job of highest priority; in this way, all jobs with priority\n\t* greater than or equal to the current level are run, in order of their priority (highest\n\t* to lowest).\n\t*\n\t* @private\n\t*/\n\t_doJob: function () {\n\t\tvar job;\n\t\t// find the job of highest priority above the current priority level\n\t\t// and remove from the job list\n\t\tfor (var i = 9; i >= this.priorityLevel; i--){\n\t\t\tif (this._jobs[i].length) {\n\t\t\t\tjob = this._jobs[i].shift();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// allow other events to pass through\n\t\tif (job) {\n\t\t\tjob.fkt();\n\t\t\tdelete this._namedJobs[job.name];\n\t\t\tsetTimeout(utils.bind(this, '_doJob'), 10);\n\t\t}\n\t}\n});\n",
    "mtime": 1542469884667,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/jobs.js",
    "relPath": "enyo/jobs",
    "requires": [
      "enyo",
      "./utils",
      "./kind",
      "./CoreObject"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./Component",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/Component",
    "name": "enyo/Component",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/Component~Component} kind.\n* @module enyo/Component\n*/\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils'),\n\tlogger = require('./logger');\n\nvar\n\tCoreObject = require('./CoreObject'),\n\tApplicationSupport = require('./ApplicationSupport'),\n\tComponentBindingSupport = require('./ComponentBindingSupport'),\n\tJobs = require('./jobs');\n\nvar\n\tkindPrefix = {},\n\tunnamedCounter = 0;\n\t\n/**\n* @callback module:enyo/Component~Component~EventHandler\n* @param {module:enyo/Component~Component} sender - The [component]{@link module:enyo/Component~Component} that most recently\n*\tpropagated the {@glossary event}.\n* @param {Object} event - An [object]{@glossary Object} containing\n*\tevent information.\n* @returns {Boolean} A value indicating whether the event has been\n*\thandled or not. If `true`, then bubbling is stopped.\n*/\n\n/**\n* A [hash]{@glossary Object} of references to all the [components]{@link module:enyo/Component~Component}\n* owned by this component. This property is updated whenever a new\n* component is added; the new component may be accessed via its\n* [name]{@link module:enyo/Component~Component#name} property. We may also observe changes on\n* properties of components referenced by the `$` property.\n*\n* Component access via the `$` hash:\n* ```javascript\n* var Component = require('enyo/Component');\n* var c = new Component({\n*\tname: 'me',\n*\tcomponents: [\n*\t\t{kind: Component, name: 'other'}\n*\t]\n* });\n*\n* // We can now access 'other' on the $ hash of 'c', via c.$.other\n* ```\n*\n* Observing changes on a component referenced by the `$` property:\n* ```javascript\n* var c = new Component({\n*\tname: 'me',\n*\tcomponents: [\n*\t\t{kind: Component, name: 'other'}\n*\t]\n* });\n*\n* c.addObserver('$.other.active', function() {\n*\t// do something to respond to the \"active\" property of \"other\" changing\n* })\n*\n* c.$.other.set('active', true); // this will trigger the observer to run its callback\n* ```\n*\n* @name $\n* @type {Object}\n* @default null\n* @memberof module:enyo/Component~Component.prototype\n* @readonly\n* @public\n*/\n\n/**\n* If `true`, this [component's]{@link module:enyo/Component~Component} [owner]{@link module:enyo/Component~Component#owner} will\n* have a direct name reference to the owned component.\n*\n* @example\n* var Component = require('enyo/Component');\n* var c = new Component({\n*\tname: 'me',\n*\tcomponents: [\n*\t\t{kind: Component, name: 'other', publish: true}\n*\t]\n* });\n*\n* // We can now access 'other' directly, via c.other\n*\n* @name publish\n* @type {Boolean}\n* @default undefined\n* @memberOf module:enyo/Component~Component.prototype\n* @public\n*/\n\n/**\n* If `true`, the [layout]{@glossary layout} strategy will adjust the size of this\n* [component]{@link module:enyo/Component~Component} to occupy the remaining available space.\n*\n* @name fit\n* @type {Boolean}\n* @default undefined\n* @memberOf module:enyo/Component~Component.prototype\n* @public\n*/\n\n/**\n* {@link module:enyo/Component~Component} is the fundamental building block for Enyo applications.\n* Components are designed to fit together, allowing complex behaviors to\n* be fashioned from smaller bits of functionality.\n*\n* Component [constructors]{@glossary constructor} take a single\n* argument (sometimes called a [component configuration]{@glossary configurationBlock}),\n* a JavaScript [object]{@glossary Object} that defines various properties to be initialized on the\n* component.  For example:\n*\n* ```javascript\n* // create a new component, initialize its name property to 'me'\n* var Component = require('enyo/Component');\n* var c = new Component({\n*\tname: 'me'\n* });\n* ```\n*\n* When a component is instantiated, items configured in its\n* `components` property are instantiated, too:\n*\n* ```javascript\n* // create a new component, which itself has a component\n* var c = new Component({\n*\tname: 'me',\n*\tcomponents: [\n*\t\t{kind: Component, name: 'other'}\n*\t]\n* });\n* ```\n*\n* In this case, when `me` is created, `other` is also created, and we say that `me` owns `other`.\n* In other words, the [owner]{@link module:enyo/Component~Component#owner} property of `other` equals `me`.\n* Notice that you can specify the [kind]{@glossary kind} of `other` explicitly in its\n* configuration block, to tell `me` what constructor to use to create `other`.\n*\n* To move a component, use the `setOwner()` method to change the\n* component's owner. If you want a component to be unowned, use `setOwner(null)`.\n*\n* If you make changes to `Component`, be sure to add or update the appropriate\n* {@linkplain https://github.com/enyojs/enyo/tree/master/tools/test/core/tests unit tests}.\n*\n* For more information, see the documentation on\n* [Components]{@linkplain $dev-guide/key-concepts/components.html} in the\n* Enyo Developer Guide.\n*\n* @class Component\n* @extends module:enyo/CoreObject~Object\n* @mixes module:enyo/ApplicationSupport~ApplicationSupport\n* @mixes module:enyo/ComponentBindingSupport~ComponentBindingSupport\n* @public\n*/\nvar Component = module.exports = kind(\n\t/** @lends module:enyo/Component~Component.prototype */ {\n\n\tname: 'enyo.Component',\n\n\t/**\n\t* @private\n\t*/\n\tkind: CoreObject,\n\n\t/**\n\t* @private\n\t*/\n\n\n\t/**\n\t* @private\n\t*/\n\tcachedBubble: true,\n\n\t/**\n\t* @private\n\t*/\n\tcachePoint: false,\n\n\t/**\n\t* @private\n\t*/\n\tpublished:\n\t\t/** @lends module:enyo/Component~Component.prototype */ {\n\n\t\t/**\n\t\t* A unique name for the [component]{@link module:enyo/Component~Component} within its\n\t\t* [owner]{@link module:enyo/Component~Component#owner}. This is used to set the access name in the\n\t\t* owner's [$ hash]{@link module:enyo/Component~Component#$}. If not\n\t\t* specified, a default name will be provided based on the name of the\n\t\t* [object's]{@link module:enyo/CoreObject~Object} [kind]{@glossary kind}, with a numeric\n\t\t* suffix appended if more than one instance exists in the owner.\n\t\t*\n\t\t* @type {String}\n\t\t* @default ''\n\t\t* @public\n\t\t*/\n\t\tname: '',\n\n\t\t/**\n\t\t* A unique id for the [component]{@link module:enyo/Component~Component}, usually automatically generated\n\t\t* based on its position within the component hierarchy, although\n\t\t* it may also be directly specified. {@link module:enyo/Control~Control} uses this `id` value for the\n\t\t* DOM [id]{@link module:enyo/Control~Control#id} attribute.\n\t\t*\n\t\t* @type {String}\n\t\t* @default ''\n\t\t* @public\n\t\t*/\n\t\tid: '',\n\n\t\t/**\n\t\t* The [component]{@link module:enyo/Component~Component} that owns this component.\n\t\t* It is usually defined implicitly at creation time based on the\n\t\t* [createComponent()]{@link module:enyo/Component~Component#createComponent} call or\n\t\t* the `components` hash.\n\t\t*\n\t\t* @type {module:enyo/Component~Component}\n\t\t* @default null\n\t\t* @public\n\t\t*/\n\t\towner: null,\n\n\t\t/**\n\t\t* This can be a [hash]{@glossary Object} of features to apply to\n\t\t* [chrome]{@glossary chrome} [components]{@link module:enyo/Component~Component} of the base\n\t\t* [kind]{@glossary kind}. They are matched by [name]{@link module:enyo/Component~Component#name}\n\t\t* (if the component you wish to modify does not have a name, this will not work).\n\t\t* You can modify any properties of the component except for methods. Setting a\n\t\t* value for `componentOverrides` at runtime will have no effect.\n\t\t*\n\t\t* @type {Object}\n\t\t* @default null\n\t\t* @public\n\t\t*/\n\t\tcomponentOverrides: null\n\t},\n\n\t/**\n\t* @private\n\t*/\n\thandlers: {},\n\n\t/**\n\t* @private\n\t*/\n\tmixins: [ApplicationSupport, ComponentBindingSupport],\n\n\t/**\n\t* @private\n\t*/\n\ttoString: function () {\n\t\treturn this.id + ' [' + this.kindName + ']';\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tconstructor: kind.inherit(function (sup) {\n\t\treturn function (props) {\n\t\t\t// initialize instance objects\n\t\t\tthis._componentNameMap = {};\n\t\t\tthis.$ = {};\n\t\t\tthis.cachedBubbleTarget = {};\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tconstructed: kind.inherit(function (sup) {\n\t\treturn function (props) {\n\t\t\t// perform initialization\n\t\t\tthis.create(props);\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tcreate: function () {\n\t\t// stop and queue all of the notifications happening synchronously to allow\n\t\t// responders to only do single passes on work traversing the tree\n\t\tthis.stopNotifications();\n\t\tthis.ownerChanged();\n\t\tthis.initComponents();\n\t\t// release the kraken!\n\t\tthis.startNotifications();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tinitComponents: function () {\n\t\t// The _components_ property in kind declarations is renamed to\n\t\t// _kindComponents_ by the Component subclass mechanism.  This makes it\n\t\t// easy for the developer to distinguish kindComponents from the components\n\t\t// in _this.components_, without having to worry about the actual difference.\n\t\t//\n\t\t// Specifically, the difference is that kindComponents are constructed as\n\t\t// owned by this control (whereas components in _this.components_ are not).\n\t\t// In addition, kindComponents are marked with the _isChrome: true_ flag.\n\t\tthis.createChrome(this.kindComponents);\n\t\tthis.createClientComponents(this.components);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcreateChrome: function (comps) {\n\t\tthis.createComponents(comps, {isChrome: true});\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcreateClientComponents: function (comps) {\n\t\tthis.createComponents(comps, {owner: this.getInstanceOwner()});\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetInstanceOwner: function () {\n\t\treturn (!this.owner || this.owner.notInstanceOwner) ? this : this.owner;\n\t},\n\n\t/**\n\t* Removes this [component]{@link module:enyo/Component~Component} from its\n\t* [owner]{@link module:enyo/Component~Component#owner} (setting `owner` to `null`)\n\t* and does any necessary cleanup. The component is flagged with\n\t* `destroyed: true`. Usually, the component will be suitable for garbage\n\t* collection after being destroyed, unless user code keeps a reference\n\t* to it.\n\t*\n\t* @returns {this} The callee for chaining.\n\t* @method\n\t* @public\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.destroyComponents();\n\t\t\tthis.setOwner(null);\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.stopAllJobs();\n\t\t\treturn this;\n\t\t};\n\t}),\n\n\t/**\n\t* Destroys all owned [components]{@link module:enyo/Component~Component}.\n\t*\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tdestroyComponents: function () {\n\t\tvar comps = this.getComponents(),\n\t\t\tcomp,\n\t\t\ti;\n\n\t\tfor (i = 0; i < comps.length; ++i) {\n\t\t\tcomp = comps[i];\n\t\t\t// @todo: previous comment said list might be stale and ownership may have caused\n\t\t\t// components to be destroyed as a result of some inner-container...look into this\n\t\t\t// because that seems incorrect or avoidable\n\t\t\tif (!comp.destroyed) comp.destroy();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmakeId: function() {\n\t\tvar delim = '_', pre = this.owner && this.owner.getId(),\n\t\t\tbaseName = this.name || ('@@' + (++unnamedCounter));\n\t\treturn (pre ? pre + delim : '') + baseName;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\townerChanged: function (was) {\n\t\tif (was && was.removeComponent) was.removeComponent(this);\n\t\tif (this.owner && this.owner.addComponent) this.owner.addComponent(this);\n\t\tif (!this.id) this.id = this.makeId();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tnameComponent: function (comp) {\n\t\tvar pre = prefixFromKindName(comp.kindName),\n\t\t\tlast = this._componentNameMap[pre] || 0,\n\t\t\tnom;\n\n\t\tdo {\n\t\t\tnom = pre + (++last > 1 ? String(last) : '');\n\t\t} while (this.$[nom]);\n\n\t\tthis._componentNameMap[pre] = Number(last);\n\t\t/*jshint -W093 */\n\t\treturn (comp.name = nom);\n\t},\n\n\t/**\n\t* Adds a [component]{@link module:enyo/Component~Component} to the list of components\n\t* owned by the current component (i.e., [this.$]{@link module:enyo/Component~Component#$}).\n\t*\n\t* @param {module:enyo/Component~Component} comp - The [component]{@link module:enyo/Component~Component} to add.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\taddComponent: function (comp) {\n\t\tvar nom = comp.get('name');\n\n\t\t// if there is no name we have to come up with a generic name\n\t\tif (!nom) nom = this.nameComponent(comp);\n\n\t\t// if there already was a component by that name we issue a warning\n\t\t// @todo: if we're going to name rules being violated we need to normalize this approach\n\t\t// and ensure we have one for every warning/error we throw\n\t\tif (this.$[nom]) this.warn(\n\t\t\t'Duplicate component name ' + nom + ' in owner ' + this.id + ' violates ' +\n\t\t\t'unique-name-under-owner rule, replacing existing component in the hash and ' +\n\t\t\t'continuing, but this is an error condition and should be fixed.'\n\t\t);\n\n\t\tthis.$[nom] = comp;\n\t\tthis.notify('$.' + nom, null, comp);\n\n\t\t// if the component has the `publish` true property then we also create a reference to\n\t\t// it directly on the owner (this)\n\t\tif (comp.publish) {\n\t\t\tthis[nom] = comp;\n\n\t\t\t// and to ensure that bindings are aware we have to notify them as well\n\t\t\tthis.notify(nom, null, comp);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* Removes the passed-in [component]{@link module:enyo/Component~Component} from those known\n\t* to be owned by this component. The component will be removed from the\n\t* [$ hash]{@link module:enyo/Component~Component#$}, and from the [owner]{@link module:enyo/Component~Component#owner}\n\t* directly if [publish]{@link module:enyo/Component~Component#publish} is set to `true`.\n\t*\n\t* @param {module:enyo/Component~Component} comp - The component to remove.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tremoveComponent: function (comp) {\n\t\tvar nom = comp.get('name');\n\n\t\t// remove it from the hash if it existed\n\t\tdelete this.$[nom];\n\n\t\t// if it was published remove it from the component proper\n\t\tif (comp.publish) delete this[nom];\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* Returns an [array]{@glossary Array} of owned [components]{@link module:enyo/Component~Component}; in\n\t* other words, converts the [$ hash]{@link module:enyo/Component~Component#$} into an array\n\t* and returns the array.\n\t*\n\t* @returns {module:enyo/Component~Component[]} The [components]{@link module:enyo/Component~Component} found in the\n\t*\t[$ hash]{@link module:enyo/Component~Component#$}.\n\t* @public\n\t*/\n\tgetComponents: function () {\n\t\treturn utils.values(this.$);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tadjustComponentProps: function (props) {\n\t\tif (this.defaultProps) utils.mixin(props, this.defaultProps, {ignore: true});\n\t\tprops.kind = props.kind || props.isa || this.defaultKind;\n\t\tprops.owner = props.owner || this;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\t_createComponent: function (props, ext) {\n\t\tvar def = ext ? utils.mixin({}, [ext, props]) : utils.clone(props);\n\n\t\t// always adjust the properties according to the needs of the kind and parent kinds\n\t\tthis.adjustComponentProps(def);\n\n\t\t// pass along for the final stage\n\t\treturn Component.create(def);\n\t},\n\n\t/**\n\t* Creates and returns a [component]{@link module:enyo/Component~Component} as defined by the combination of\n\t* a base and an additional property [hash]{@glossary Object}. The properties provided\n\t* in the standard property hash override those provided in the\n\t* additional property hash.\n\t*\n\t* The created component passes through initialization machinery\n\t* provided by the creating component, which may supply special\n\t* handling. Unless the [owner]{@link module:enyo/Component~Component#owner} is explicitly specified, the new\n\t* component will be owned by the instance on which this method is called.\n\t*\n\t* @example\n\t* // Create a new component named 'dynamic', owned by 'this'\n\t* // (will be available as this.$.dynamic).\n\t* this.createComponent({name: 'dynamic'});\n\t*\n\t* @example\n\t* // Create a new component named 'another' owned by 'other'\n\t* // (will be available as other.$.another).\n\t* this.createComponent({name: 'another'}, {owner: other});\n\t*\n\t* @param {Object} props - The declarative [kind]{@glossary kind} definition.\n\t* @param {Object} ext - Additional properties to be applied (defaults).\n\t* @returns {module:enyo/Component~Component} The instance created with the given parameters.\n\t* @public\n\t*/\n\tcreateComponent: function (props, ext) {\n\t\t// createComponent and createComponents both delegate to the protected method\n\t\t// (_createComponent), allowing overrides to customize createComponent and\n\t\t// createComponents separately.\n\t\treturn this._createComponent(props, ext);\n\t},\n\n\t/**\n\t* Creates [components]{@link module:enyo/Component~Component} as defined by the [arrays]{@glossary Array}\n\t* of base and additional property [hashes]{@glossary Object}. The standard and\n\t* additional property hashes are combined as described in\n\t* [createComponent()]{@link module:enyo/Component~Component#createComponent}.\n\t*\n\t* @example\n\t* // ask foo to create components 'bar' and 'zot', but set the owner of\n\t* // both components to 'this'.\n\t* this.$.foo.createComponents([\n\t*\t{name: 'bar'},\n\t*\t{name: 'zot'}\n\t* ], {owner: this});\n\t*\n\t* @param {Object[]} props The array of {@link module:enyo/Component~Component} definitions to be created.\n\t* @param {Object} ext - Additional properties to be supplied as defaults for each.\n\t* @returns {module:enyo/Component~Component[]} The array of [components]{@link module:enyo/Component~Component} that were\n\t*\tcreated.\n\t* @public\n\t*/\n\tcreateComponents: function (props, ext) {\n\t\tvar comps = [],\n\t\t\tcomp,\n\t\t\ti;\n\n\t\tif (props) {\n\t\t\tfor (i = 0; i < props.length; ++i) {\n\t\t\t\tcomp = props[i];\n\t\t\t\tcomps.push(this._createComponent(comp, ext));\n\t\t\t}\n\t\t}\n\n\t\treturn comps;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetBubbleTarget: function (nom, event) {\n\t\tif (event.delegate) return this.owner;\n\t\telse {\n\t\t\treturn (\n\t\t\t\tthis.bubbleTarget\n\t\t\t\t|| (this.cachedBubble && this.cachedBubbleTarget[nom])\n\t\t\t\t|| this.owner\n\t\t\t);\n\t\t}\n\t},\n\n\t/**\n\t* Bubbles an {@glossary event} up an [object]{@glossary Object} chain,\n\t* starting with `this`.\n\t*\n\t* A handler for an event may be specified. See {@link module:enyo/Component~Component~EventHandler}\n\t* for complete details.\n\t*\n\t* @param {String} nom - The name of the {@glossary event} to bubble.\n\t* @param {Object} [event] - The event [object]{@glossary Object} to be passed along\n\t* while bubbling.\n\t* @param {module:enyo/Component~Component} [sender=this] - The {@link module:enyo/Component~Component} responsible for\n\t*\tbubbling the event.\n\t* @returns {Boolean} `false` if unhandled or uninterrupted; otherwise, `true`.\n\t* @public\n\t*/\n\tbubble: function (nom, event, sender) {\n\t\tif (!this._silenced) {\n\t\t\tevent = event || {};\n\t\t\tevent.lastHandledComponent = null;\n\t\t\tevent.bubbling = true;\n\t\t\t// deliberately done this way\n\t\t\tif (event.originator == null) event.originator = sender || this;\n\t\t\treturn this.dispatchBubble(nom, event, sender || this);\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t* Bubbles an {@glossary event} up an [object]{@glossary Object} chain,\n\t* starting **above** `this`.\n\t*\n\t* A handler for an event may be specified. See {@link module:enyo/Component~Component~EventHandler}\n\t* for complete details.\n\t*\n\t* @param {String} nom - The name of the {@glossary event}.\n\t* @param {Object} [event] - The event properties to pass along while bubbling.\n\t* @returns {Boolean} `false` if unhandled or uninterrupted; otherwise, `true`.\n\t* @public\n\t*/\n\tbubbleUp: function (nom, event) {\n\t\tvar next;\n\n\t\tif (!this._silenced) {\n\t\t\tevent = event || {};\n\t\t\tevent.bubbling = true;\n\t\t\tnext = this.getBubbleTarget(nom, event);\n\t\t\tif (next) {\n\t\t\t\t// use delegate as sender if it exists to preserve illusion\n\t\t\t\t// that event is dispatched directly from that, but we still\n\t\t\t\t// have to bubble to get decorations\n\t\t\t\treturn next.dispatchBubble(nom, event, event.delegate || this);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t* Sends an {@glossary event} to a named [delegate]{@glossary delegate}.\n\t* This [object]{@glossary Object} may dispatch an event to\n\t* itself via a [handler]{@link module:enyo/Component~Component~EventHandler}, or to its\n\t* [owner]{@link module:enyo/Component~Component#owner} via an event property, e.g.:\n\t*\n\t*\thandlers {\n\t*\t\t// 'tap' events dispatched to this.tapHandler\n\t*\t\tontap: 'tapHandler'\n\t*\t}\n\t*\n\t*\t// 'tap' events dispatched to 'tapHandler' delegate in this.owner\n\t*\tontap: 'tapHandler'\n\t*\n\t* @private\n\t*/\n\tdispatchEvent: function (nom, event, sender) {\n\t\tvar delegate,\n\t\t\tret;\n\n\t\tif (!this._silenced) {\n\t\t\t// if the event has a delegate associated with it we grab that\n\t\t\t// for reference\n\t\t\t// NOTE: This is unfortunate but we can't use a pooled object here because\n\t\t\t// we don't know where to release it\n\t\t\tdelegate = (event || (event = {})).delegate;\n\n\t\t\t// bottleneck event decoration w/ optimization to avoid call to empty function\n\t\t\tif (this.decorateEvent !== Component.prototype.decorateEvent) {\n\t\t\t\tthis.decorateEvent(nom, event, sender);\n\t\t\t}\n\n\t\t\t// first, handle any delegated events intended for this object\n\t\t\tif (delegate && delegate.owner === this) {\n\t\t\t\t// the most likely case is that we have a method to handle this\n\t\t\t\tif (this[nom] && 'function' === typeof this[nom]) {\n\t\t\t\t\treturn this.dispatch(nom, event, sender);\n\t\t\t\t}\n\t\t\t\t// but if we don't, just stop the event from going further\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// for non-delgated events, try the handlers block if possible\n\t\t\tif (!delegate) {\n\t\t\t\tvar bHandler = this.handlers && this.handlers[nom];\n\t\t\t\tvar bDelegatedFunction = this[nom] && utils.isString(this[nom]);\n\t\t\t\tvar cachePoint = this.cachePoint || bHandler || bDelegatedFunction || this.id === \"master\" ;\n\n\t\t\t\tif (event.bubbling) {\n\t\t\t\t\tif (event.lastHandledComponent && cachePoint) {\n\t\t\t\t\t\tevent.lastHandledComponent.cachedBubbleTarget[nom] = this;\n\t\t\t\t\t\tevent.lastHandledComponent = null;\n\t\t\t\t\t}\n\t\t\t\t\tif (!event.lastHandledComponent && this.id !== \"master\") {\n\t\t\t\t\t\tevent.lastHandledComponent = this;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bHandler && this.dispatch(bHandler, event, sender)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (bDelegatedFunction) {\n\t\t\t\t\t// we dispatch it up as a special delegate event with the\n\t\t\t\t\t// component that had the delegation string property stored in\n\t\t\t\t\t// the 'delegate' property\n\t\t\t\t\tevent.delegate = this;\n\t\t\t\t\tret = this.bubbleUp(this[nom], event, sender);\n\t\t\t\t\tdelete event.delegate;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t* Internal - try dispatching {@glossary event} to self; if that fails,\n\t* [bubble it up]{@link module:enyo/Component~Component#bubbleUp} the tree.\n\t*\n\t* @private\n\t*/\n\tdispatchBubble: function (nom, event, sender) {\n\t\tif (!this._silenced) {\n\t\t\t// Try to dispatch from here, stop bubbling on truthy return value\n\t\t\tif (this.dispatchEvent(nom, event, sender)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// Bubble to next target\n\t\t\treturn this.bubbleUp(nom, event, sender);\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdecorateEvent: function (nom, event, sender) {\n\t\t// an event may float by us as part of a dispatchEvent chain\n\t\t// both call this method so intermediaries can decorate inEvent\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstopAllJobs: function () {\n\t\tvar job;\n\n\t\tif (this.__jobs) for (job in this.__jobs) this.stopJob(job);\n\t},\n\n\t/**\n\t* Dispatches the {@glossary event} to named [delegate]{@glossary delegate} `nom`,\n\t* if it exists. [Subkinds]{@glossary subkind} may re-route dispatches. Note that\n\t* both 'handlers' events and events delegated from owned controls arrive here.\n\t* If you need to handle these types of events differently, you may also need to\n\t* override [dispatchEvent()]{@link module:enyo/Component~Component#dispatchEvent}.\n\t*\n\t* @param {String} nom - The method name to dispatch the {@glossary event}.\n\t* @param {Object} [event] - The event [object]{@glossary Object} to pass along.\n\t* @param {module:enyo/Component~Component} [sender=this] - The originator of the event.\n\t* @public\n\t*/\n\tdispatch: function (nom, event, sender) {\n\t\tvar fn;\n\n\t\tif (!this._silenced) {\n\t\t\tfn = nom && this[nom];\n\t\t\tif (fn && typeof fn == 'function') {\n\t\t\t\t// @todo: deprecate sender\n\t\t\t\treturn fn.call(this, sender || this, event);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t* Triggers the [handler]{@link module:enyo/Component~Component~EventHandler} for a given\n\t* {@glossary event} type.\n\t*\n\t* @example\n\t* myControl.triggerHandler('ontap');\n\t*\n\t* @param {String} nom - The name of the {@glossary event} to trigger.\n\t* @param {Object} [event] - The event object to pass along.\n\t* @param {module:enyo/Component~Component} [sender=this] - The originator of the event.\n\t* @returns {Boolean} `false` if unhandled or uninterrupted, `true` otherwise.\n\t* @public\n\t*/\n\ttriggerHandler: function () {\n\t\treturn this.dispatchEvent.apply(this, arguments);\n\t},\n\n\t/**\n\t* Sends a message to myself and all of my [components]{@link module:enyo/Component~Component}.\n\t* You can stop a waterfall into components owned by a receiving object\n\t* by returning a truthy value from the {@glossary event}\n\t* [handler]{@link module:enyo/Component~Component~EventHandler}.\n\t*\n\t* @param {String} nom - The name of the {@glossary event} to waterfall.\n\t* @param {Object} [event] - The event [object]{@glossary Object} to pass along.\n\t* @param {module:enyo/Component~Component} [sender=this] - The originator of the event.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\twaterfall: function(nom, event, sender) {\n\t\tif (!this._silenced) {\n\t\t\tevent = event || {};\n\t\t\tevent.bubbling = false;\n\n\t\t\t// give the locals an opportunity to interrupt the event\n\t\t\tif (this.dispatchEvent(nom, event, sender)) return true;\n\n\t\t\t// otherwise carry on\n\t\t\tthis.waterfallDown(nom, event, sender || this);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* Sends a message to all of my [components]{@link module:enyo/Component~Component}, but not myself. You can\n\t* stop a [waterfall]{@link module:enyo/Component~Component#waterfall} into [components]{@link module:enyo/Component~Component}\n\t* owned by a receiving [object]{@glossary Object} by returning a truthy value from the\n\t* {@glossary event} [handler]{@link module:enyo/Component~Component~EventHandler}.\n\t*\n\t* @param {String} nom - The name of the {@glossary event}.\n\t* @param {Object} [event] - The event [object]{@glossary Object} to pass along.\n\t* @param {module:enyo/Component~Component} [sender=this] - The event originator.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\twaterfallDown: function(nom, event, sender) {\n\t\tvar comp;\n\t\tevent = event || {};\n\t\tevent.bubbling = false;\n\n\t\tif (!this._silenced) {\n\t\t\tfor (comp in this.$) this.$[comp].waterfall(nom, event, sender || this);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\t_silenced: false,\n\n\t/**\n\t* @private\n\t*/\n\t_silenceCount: 0,\n\n\t/**\n\t* Sets a flag that disables {@glossary event} propagation for this\n\t* [component]{@link module:enyo/Component~Component}. Also increments an internal counter that tracks\n\t* the number of times the [unsilence()]{@link module:enyo/Component~Component#unsilence} method must\n\t* be called before event propagation will continue.\n\t*\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tsilence: function () {\n\t\tthis._silenced = true;\n\t\tthis._silenceCount += 1;\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* Determines if the [object]{@glossary Object} is currently\n\t* [silenced]{@link module:enyo/Component~Component#_silenced}, which will prevent propagation of\n\t* [events]{@glossary event} (of any kind).\n\t*\n\t* @returns {Boolean} `true` if silenced; otherwise, `false`.\n\t* @public\n\t*/\n\tisSilenced: function () {\n\t\treturn this._silenced;\n\t},\n\n\t/**\n\t* Allows {@glossary event} propagation for this [component]{@link module:enyo/Component~Component}\n\t* if the internal silence counter is `0`; otherwise, decrements the counter by one.\n\t* For event propagation to resume, this method must be called one time each call to\n\t* [silence()]{@link module:enyo/Component~Component#silence}.\n\t*\n\t* @returns {Boolean} `true` if the {@link module:enyo/Component~Component} is now unsilenced completely;\n\t*\t`false` if it remains silenced.\n\t* @public\n\t*/\n\tunsilence: function () {\n\t\tif (0 !== this._silenceCount) --this._silenceCount;\n\t\tif (0 === this._silenceCount) this._silenced = false;\n\t\treturn !this._silenced;\n\t},\n\n\t/**\n\t* Creates a new [job]{@link module:enyo/job} tied to this instance of the\n\t* [component]{@link module:enyo/Component~Component}. If the component is\n\t* [destroyed]{@link module:enyo/Component~Component#destroy}, any jobs associated with it\n\t* will be stopped.\n\t*\n\t* If you start a job with the same name as a pending job,\n\t* the original job will be stopped; this can be useful for resetting\n\t* timeouts.\n\t*\n\t* You may supply a priority level (1-10) at which the job should be\n\t* executed. The default level is `5`. Setting the priority lower than `5` (or setting it to\n\t* the string `\"low\"`) will defer the job if an animation is in progress,\n\t* which can help to avoid stuttering.\n\t*\n\t* @param {String} nom - The name of the [job]{@link module:enyo/job} to start.\n\t* @param {(Function|String)} job - Either the name of a method or a\n\t*\t[function]{@glossary Function} to execute as the requested job.\n\t* @param {Number} wait - The number of milliseconds to wait before starting\n\t*\tthe job.\n\t* @param {Number} [priority=5] The priority value to be associated with this\n\t*\tjob.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tstartJob: function (nom, job, wait, priority) {\n\t\tvar jobs = (this.__jobs = this.__jobs || {});\n\t\tpriority = priority || 5;\n\t\t// allow strings as job names, they map to local method names\n\t\tif (typeof job == 'string') job = this[job];\n\t\t// stop any existing jobs with same name\n\t\tthis.stopJob(nom);\n\t\tjobs[nom] = setTimeout(this.bindSafely(function() {\n\t\t\tJobs.add(this.bindSafely(job), priority, nom);\n\t\t}), wait);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* Stops a [component]{@link module:enyo/Component~Component}-specific [job]{@link module:enyo/job} before it has\n\t* been activated.\n\t*\n\t* @param {String} nom - The name of the [job]{@link module:enyo/job} to be stopped.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tstopJob: function (nom) {\n\t\tvar jobs = (this.__jobs = this.__jobs || {});\n\t\tif (jobs[nom]) {\n\t\t\tclearTimeout(jobs[nom]);\n\t\t\tdelete jobs[nom];\n\t\t}\n\t\tJobs.remove(nom);\n\t},\n\n\t/**\n\t* Executes the specified [job]{@link module:enyo/job} immediately, then prevents\n\t* any other calls to `throttleJob()` with the same job name from running for\n\t* the specified amount of time.\n\t*\n\t* @param {String} nom - The name of the [job]{@link module:enyo/job} to throttle.\n\t* @param {(Function|String)} job - Either the name of a method or a\n\t*\t[function]{@glossary Function} to execute as the requested job.\n\t* @param {Number} wait - The number of milliseconds to wait before executing the\n\t*\tjob again.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tthrottleJob: function (nom, job, wait) {\n\t\tvar jobs = (this.__jobs = this.__jobs || {});\n\t\t// if we still have a job with this name pending, return immediately\n\t\tif (!jobs[nom]) {\n\t\t\t// allow strings as job names, they map to local method names\n\t\t\tif (typeof job == 'string') job = this[job];\n\t\t\tjob.call(this);\n\t\t\tjobs[nom] = setTimeout(this.bindSafely(function() {\n\t\t\t\tthis.stopJob(nom);\n\t\t\t}), wait);\n\t\t}\n\t\treturn this;\n\t}\n});\n\nComponent.prototype.defaultKind = Component;\n\n/**\n* @private\n*/\nkind.setDefaultCtor(Component);\n\n/**\n* Creates new instances from [config]{@glossary configurationBlock}\n* [objects]{@glossary Object}. This method looks up the proper\n* [constructor]{@glossary constructor} based on the provided [kind]{@glossary kind}\n* attribute.\n*\n* @name module:enyo/Compoment~Component.create\n* @param {Object} props - The properties that define the [kind]{@glossary kind}.\n* @returns {*} An instance of the requested [kind]{@glossary kind}.\n* @public\n*/\nComponent.create = function (props) {\n\tvar theKind,\n\t\tCtor;\n\n\tif (!props.kind && props.hasOwnProperty('kind')) throw new Error(\n\t\t'enyo.create: Attempt to create a null kind. Check dependencies for [' + props.name + ']'\n\t);\n\n\ttheKind = props.kind || props.isa || kind.getDefaultCtor();\n\tCtor = kind.constructorForKind(theKind);\n\n\tif (!Ctor) {\n\t\tlogger.error('No constructor found for kind ' + theKind);\n\t\tCtor = Component;\n\t}\n\n\treturn new Ctor(props);\n};\n\n/**\n* @name module:enyo/Component~Component.subclass\n* @static\n* @private\n*/\nComponent.subclass = function (ctor, props) {\n\t// Note: To reduce API surface area, sub-components are declared only as\n\t// 'components' in both kind and instance declarations.\n\t//\n\t// However, 'components' from kind declarations must be handled separately\n\t// at creation time.\n\t//\n\t// We rename the property here to avoid having\n\t// to interrogate the prototype at creation time.\n\t//\n\tvar proto = ctor.prototype;\n\t//\n\tif (props.components) {\n\t\tproto.kindComponents = props.components;\n\t\tdelete proto.components;\n\t} else {\n\t\t// Feature to mixin overrides of super-kind component properties from named hash\n\t\t// (only applied when the sub-kind doesn't supply its own components block)\n\t\tif (props.componentOverrides) {\n\t\t\tproto.kindComponents = Component.overrideComponents(\n\t\t\t\tproto.kindComponents,\n\t\t\t\tprops.componentOverrides,\n\t\t\t\tproto.defaultKind\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n* @name module:enyo/Component~Component.concat\n* @static\n* @private\n*/\nComponent.concat = function (ctor, props) {\n\tvar proto = ctor.prototype || ctor,\n\t\thandlers;\n\tif (props.handlers) {\n\t\thandlers = proto.handlers ? utils.clone(proto.handlers) : {};\n\t\tproto.handlers = utils.mixin(handlers, props.handlers);\n\t\tdelete props.handlers;\n\t}\n\tif (props.events) Component.publishEvents(proto, props);\n};\n\n/**\n* @name module:enyo/Component~Component.overrideComponents\n* @static\n* @private\n*/\nComponent.overrideComponents = function (components, overrides, defaultKind) {\n\tvar omitMethods = function (k, v) {\n\t\tvar isMethod = \n\t\t\t// If it's a function, then it's a method (unless it's\n\t\t\t// a constructor passed as value for 'kind')\n\t\t\t(utils.isFunction(v) && (k !== 'kind')) ||\n\t\t\t// If it isInherited(), then it's also a method (since\n\t\t\t// Inherited is an object wrapper for a function)\n\t\t\tkind.isInherited(v);\n\n\t\treturn !isMethod;\n\t};\n\tcomponents = utils.clone(components);\n\tfor (var i=0; i<components.length; i++) {\n\t\tvar c = utils.clone(components[i]);\n\t\tvar o = overrides[c.name];\n\t\tvar ctor = kind.constructorForKind(c.kind || defaultKind);\n\t\tif (o) {\n\n\t\t\t// NOTE: You cannot overload mixins, observers or computed properties from\n\t\t\t// component overrides\n\t\t\tkind.concatHandler(c, o);\n\t\t\tvar b = (c.kind && ((typeof c.kind == 'string' && utils.getPath(c.kind)) || (typeof c.kind == 'function' && c.kind))) || kind.getDefaultCtor();\n\t\t\twhile (b) {\n\t\t\t\tif (b.concat) { b.concat(c, o, true); }\n\t\t\t\tb = b.prototype.base;\n\t\t\t}\n\t\t\t// All others just mix in\n\t\t\tutils.mixin(c, o, {filter: omitMethods});\n\t\t}\n\t\tif (c.components) {\n\t\t\tc.components = Component.overrideComponents(c.components, overrides, ctor.prototype.defaultKind);\n\t\t}\n\t\tcomponents[i] = c;\n\t}\n\treturn components;\n};\n\n/**\n* @name module:enyo/Component~Component.publishEvents\n* @static\n* @private\n*/\nComponent.publishEvents = function (ctor, props) {\n\tvar events = props.events,\n\t\tevent,\n\t\tproto;\n\tif (events) {\n\t\tproto = ctor.prototype || ctor;\n\t\tfor (event in events) Component.addEvent(event, events[event], proto);\n\t}\n};\n\n/**\n* @name module:enyo/Component~Component.addEvent\n* @static\n* @private\n*/\nComponent.addEvent = function (nom, val, proto) {\n\tvar v, fn;\n\tif (!utils.isString(val)) {\n\t\tv = val.value;\n\t\tfn = val.caller;\n\t} else {\n\t\tif (nom.slice(0, 2) != 'on') {\n\t\t\tlogger.warn('enyo/Component.addEvent: event names must start with \"on\". ' + proto.kindName + ' ' +\n\t\t\t\t'event \"' + nom + '\" was auto-corrected to \"on' + nom + '\".');\n\t\t\tnom = 'on' + nom;\n\t\t}\n\t\tv = val;\n\t\tfn = 'do' + utils.cap(nom.slice(2));\n\t}\n\tproto[nom] = v;\n\tif (!proto[fn]) {\n\t\tproto[fn] = function(payload, other) {\n\t\t\t// bubble this event\n\n\t\t\t// if the second parameter exists then we use that - this is for a single case\n\t\t\t// where a named event delegates happent to point to an auto generated event\n\t\t\t// bubbler like this one - in that case the first parameter is actually the\n\t\t\t// sender\n\t\t\tvar e = other || payload;\n\t\t\tif (!e) {\n\t\t\t\te = {};\n\t\t\t}\n\t\t\tvar d = e.delegate;\n\t\t\t// delete payload.delegate;\n\t\t\te.delegate = undefined;\n\t\t\tif (!utils.exists(e.type)) {\n\t\t\t\te.type = nom;\n\t\t\t}\n\t\t\tthis.bubble(nom, e);\n\t\t\tif (d) {\n\t\t\t\te.delegate = d;\n\t\t\t}\n\t\t};\n\t}\n};\n\n/**\n* @private\n*/\nfunction prefixFromKindName (nom) {\n\tvar pre = kindPrefix[nom],\n\t\tlast;\n\n\tif (!pre) {\n\t\tlast = nom.lastIndexOf('.');\n\t\tpre = (last >= 0) ? nom.slice(last+1) : nom;\n\t\tpre = pre.charAt(0).toLowerCase() + pre.slice(1);\n\t\tkindPrefix[nom] = pre;\n\t}\n\n\treturn pre;\n}\n",
    "mtime": 1542469884075,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/Component.js",
    "relPath": "enyo/Component",
    "requires": [
      "enyo",
      "./kind",
      "./utils",
      "./logger",
      "./CoreObject",
      "./ApplicationSupport",
      "./ComponentBindingSupport",
      "./jobs"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./Signals",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/Signals",
    "name": "enyo/Signals",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/Signals~Signals} kind.\n* @module enyo/Signals\n*/\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils');\n\nvar\n\tComponent = require('./Component');\n\n/**\n* {@link module:enyo/Signals~Signals} is a [component]{@link module:enyo/Component~Component} used to listen\n* to global messages.\n* \n* An object with a Signals component can listen to messages sent from anywhere\n* by declaring handlers for them.\n* \n* DOM [events]{@glossary event} that have no node targets are broadcast as\n* signals. These events include Window events, such as `onload` and\n* `onbeforeunload`, as well as events that occur directly on `document`, such\n* as `onkeypress` if `document` has the focus.\n* \n* For more information, see the documentation on [Event\n* Handling]{@linkplain $dev-guide/key-concepts/event-handling.html} in the\n* Enyo Developer Guide.\n*\n* @class Signals\n* @extends module:enyo/Component~Component\n* @public\n*/\nvar Signals = module.exports = kind(\n\t/** @lends module:enyo/Signals~Signals.prototype */ {\n\n\tname: 'enyo.Signals',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Component,\n\n\t/**\n\t* Needed because of early calls to bind DOM {@glossary event} listeners\n\t* to the [enyo.Signals.send()]{@link module:enyo/Signals~Signals#send} call.\n\t* \n\t* @private\n\t*/\n\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tSignals.addListener(this);\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tSignals.removeListener(this);\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tnotify: function (msg, load) {\n\t\tthis.dispatchEvent(msg, load);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tprotectedStatics: {\n\t\tlisteners: [],\n\t\taddListener: function(listener) {\n\t\t\tthis.listeners.push(listener);\n\t\t},\n\t\tremoveListener: function(listener) {\n\t\t\tutils.remove(listener, this.listeners);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstatics: \n\t\t/** @lends module:enyo/Signals~Signals.prototype */ {\n\n\t\t/**\n\t\t* Broadcasts a global message to be consumed by subscribers.\n\t\t* \n\t\t* @param {String} msg - The message to send; usually the name of the\n\t\t*\t{@glossary event}.\n\t\t* @param {Object} load - An [object]{@glossary Object} containing any\n\t\t*\tassociated event properties to be accessed by subscribers.\n\t\t* @public\n\t\t*/\n\t\tsend: function (msg, load) {\n\t\t\tutils.forEach(this.listeners, function(l) {\n\t\t\t\tl.notify(msg, load);\n\t\t\t});\n\t\t}\n\t}\n});\n",
    "mtime": 1542469884463,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/Signals.js",
    "relPath": "enyo/Signals",
    "requires": [
      "enyo",
      "./kind",
      "./utils",
      "./Component"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./MultipleDispatchComponent",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/MultipleDispatchComponent",
    "name": "enyo/MultipleDispatchComponent",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/MultipleDispatchComponent~MultipleDispatchComponent} kind.\n* @module enyo/MultipleDispatchComponent\n*/\n\nvar\n\tkind = require('./kind');\n\nvar\n\tComponent = require('./Component'),\n\tMultipleDispatchSupport = require('./MultipleDispatchSupport');\n\n/**\n* {@link module:enyo/MultipleDispatchComponent~MultipleDispatchComponent} is a purely abstract\n* {@glossary kind} that simply provides a common ancestor for\n* {@link module:enyo/Component~Component} [objects]{@glossary Object} that need \n* the [MultipleDispatchSupport]{@link module:enyo/MultipleDispatchSupport~MultipleDispatchSupport}\n* {@glossary mixin}.\n*\n* @class MultipleDispatchComponent\n* @extends module:enyo/Component~Component\n* @mixes module:enyo/MultipleDispatchSupport~MultipleDispatchSupport\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/MultipleDispatchComponent~MultipleDispatchComponent */ {\n\n\t/**\n\t* @private\n\t*/\n\tkind: Component,\n\n\t/**\n\t* @private\n\t*/\n\tmixins: [MultipleDispatchSupport]\n});\n",
    "mtime": 1542469884291,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/MultipleDispatchComponent.js",
    "relPath": "enyo/MultipleDispatchComponent",
    "requires": [
      "enyo",
      "./kind",
      "./Component",
      "./MultipleDispatchSupport"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./ScrollMath",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/ScrollMath",
    "name": "enyo/ScrollMath",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/ScrollMath~ScrollMath} kind.\n* @module enyo/ScrollMath\n*/\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils'),\n\tplatform = require('./platform'),\n\tanimation = require('./animation');\n\nvar\n\tComponent = require('./Component');\n\n/**\n* Fires when a scrolling action starts.\n*\n* @event module:enyo/ScrollMath~ScrollMath#onScrollStart\n* @type {Object}\n* @property {Object} sender - The [component]{@link module:enyo/Component~Component} that most recently\n*\tpropagated the {@glossary event}.\n* @property {module:enyo/Scroller~Scroller~ScrollEvent} event - An [object]{@glossary Object} containing\n*\tevent information.\n* @private\n*/\n\n/**\n* Fires while a scrolling action is in progress.\n*\n* @event module:enyo/ScrollMath~ScrollMath#onScroll\n* @type {Object}\n* @property {Object} sender - The [component]{@link module:enyo/Component~Component} that most recently\n*\tpropagated the {@glossary event}.\n* @property {module:enyo/Scroller~Scroller~ScrollEvent} event - An [object]{@glossary Object} containing\n*\tevent information.\n* @private\n*/\n\n/**\n* Fires when a scrolling action stops.\n*\n* @event module:enyo/ScrollMath~ScrollMath#onScrollStop\n* @type {Object}\n* @property {Object} sender - The [component]{@link module:enyo/Component~Component} that most recently\n*\tpropagated the {@glossary event}.\n* @property {module:enyo/Scroller~Scroller~ScrollEvent} event - An [object]{@glossary Object} containing\n*\tevent information.\n* @private\n*/\n\n/**\n* {@link module:enyo/ScrollMath~ScrollMath} implements a scrolling dynamics simulation. It is a\n* helper [kind]{@glossary kind} used by other [scroller]{@link module:enyo/Scroller~Scroller}\n* kinds, such as {@link module:enyo/TouchScrollStrategy~TouchScrollStrategy}.\n*\n* `enyo/ScrollMath` is not typically created in application code.\n*\n* @class ScrollMath\n* @protected\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/ScrollMath~ScrollMath.prototype */ {\n\n\tname: 'enyo.ScrollMath',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Component,\n\n\t/**\n\t* @private\n\t*/\n\tpublished:\n\t\t/** @lends module:enyo/ScrollMath~ScrollMath.prototype */ {\n\n\t\t/**\n\t\t* Set to `true` to enable vertical scrolling.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default true\n\t\t* @private\n\t\t*/\n\t\tvertical: true,\n\n\t\t/**\n\t\t* Set to `true` to enable horizontal scrolling.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default true\n\t\t* @private\n\t\t*/\n\t\thorizontal: true\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tevents: {\n\t\tonScrollStart: '',\n\t\tonScroll: '',\n\t\tonScrollStop: '',\n\t\tonStabilize: ''\n\t},\n\n\t/**\n\t* \"Spring\" damping returns the scroll position to a value inside the boundaries. Lower\n\t* values provide faster snapback.\n\t*\n\t* @private\n\t*/\n\tkSpringDamping: 0.93,\n\n\t/**\n\t* \"Drag\" damping resists dragging the scroll position beyond the boundaries. Lower values\n\t* provide more resistance.\n\t*\n\t* @private\n\t*/\n\tkDragDamping: 0.5,\n\n\t/**\n\t* \"Friction\" damping reduces momentum over time. Lower values provide more friction.\n\t*\n\t* @private\n\t*/\n\tkFrictionDamping: 0.97,\n\n\t/**\n\t* Additional \"friction\" damping applied when momentum carries the viewport into overscroll.\n\t* Lower values provide more friction.\n\t*\n\t* @private\n\t*/\n\tkSnapFriction: 0.9,\n\n\t/**\n\t* Scalar applied to `flick` event velocity.\n\t*\n\t* @private\n\t*/\n\tkFlickScalar: 15,\n\n\t/**\n\t* Limits the maximum allowable flick. On Android > 2, we limit this to prevent compositing\n\t* artifacts.\n\t*\n\t* @private\n\t*/\n\tkMaxFlick: platform.android > 2 ? 2 : 1e9,\n\n\t/**\n\t* The value used in [friction()]{@link module:enyo/ScrollMath~ScrollMath#friction} to determine if the delta\n\t* (e.g., y - y0) is close enough to zero to consider as zero.\n\t*\n\t* @private\n\t*/\n\tkFrictionEpsilon: platform.webos >= 4 ? 1e-1 : 1e-2,\n\n\t/**\n\t* Top snap boundary, generally `0`.\n\t*\n\t* @private\n\t*/\n\ttopBoundary: 0,\n\n\t/**\n\t* Right snap boundary, generally `(viewport width - content width)`.\n\t*\n\t* @private\n\t*/\n\trightBoundary: 0,\n\n\t/**\n\t* Bottom snap boundary, generally `(viewport height - content height)`.\n\t*\n\t* @private\n\t*/\n\tbottomBoundary: 0,\n\n\t/**\n\t* Left snap boundary, generally `0`.\n\t*\n\t* @private\n\t*/\n\tleftBoundary: 0,\n\n\t/**\n\t* Animation time step.\n\t*\n\t* @private\n\t*/\n\tinterval: 20,\n\n\t/**\n\t* Flag to enable frame-based animation; if `false`, time-based animation is used.\n\t*\n\t* @private\n\t*/\n\tfixedTime: true,\n\n\t/**\n\t* Simulation state.\n\t*\n\t* @private\n\t*/\n\tx0: 0,\n\n\t/**\n\t* Simulation state.\n\t*\n\t* @private\n\t*/\n\tx: 0,\n\n\t/**\n\t* Simulation state.\n\t*\n\t* @private\n\t*/\n\ty0: 0,\n\n\t/**\n\t* Simulation state.\n\t*\n\t* @private\n\t*/\n\ty: 0,\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.boundarySnapshot = {};\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tthis.stop();\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* Simple Verlet integrator for simulating Newtonian motion.\n\t*\n\t* @private\n\t*/\n\tverlet: function () {\n\t\tvar x = this.x;\n\t\tthis.x += x - this.x0;\n\t\tthis.x0 = x;\n\t\t//\n\t\tvar y = this.y;\n\t\tthis.y += y - this.y0;\n\t\tthis.y0 = y;\n\t},\n\n\t/**\n\t* Boundary damping function. Returns damped `value` based on `coeff` on one side of\n\t* `origin`.\n\t*\n\t* @private\n\t*/\n\tdamping: function (val, origin, coeff, sign) {\n\t\tvar kEpsilon = 0.5;\n\t\t//\n\t\t// this is basically just value *= coeff (generally, coeff < 1)\n\t\t//\n\t\t// 'sign' and the conditional is to force the damping to only occur\n\t\t// on one side of the origin.\n\t\t//\n\t\tvar dv = val - origin;\n\t\t// Force close-to-zero to zero\n\t\tif (Math.abs(dv) < kEpsilon) {\n\t\t\treturn origin;\n\t\t}\n\t\treturn val*sign > origin*sign ? coeff * dv + origin : val;\n\t},\n\n\t/**\n\t* Dual-boundary damping function. Returns damped `value` based on `coeff` when exceeding\n\t* either boundary.\n\t*\n\t* @private\n\t*/\n\tboundaryDamping: function (val, aBoundary, bBoundary, coeff) {\n\t\treturn this.damping(this.damping(val, aBoundary, coeff, 1), bBoundary, coeff, -1);\n\t},\n\n\t/**\n\t* Simulation constraints (spring damping occurs here).\n\t*\n\t* @private\n\t*/\n\tconstrain: function () {\n\t\tvar b = this.getDampingBoundaries(),\n\t\t\ty = this.boundaryDamping(this.y, b.top, b.bottom, this.kSpringDamping),\n\t\t\tx = this.boundaryDamping(this.x, b.left, b.right, this.kSpringDamping);\n\n\t\tif (y != this.y) {\n\t\t\t// ensure snapping introduces no velocity, add additional friction\n\t\t\tthis.y0 = y - (this.y - this.y0) * this.kSnapFriction;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tif (x != this.x) {\n\t\t\tthis.x0 = x - (this.x - this.x0) * this.kSnapFriction;\n\t\t\tthis.x = x;\n\t\t}\n\t},\n\n\t/**\n\t* The friction function.\n\t*\n\t* @private\n\t*/\n\tfriction: function (ex, ex0, coeff) {\n\t\t// implicit velocity\n\t\tvar dp = this[ex] - this[ex0];\n\t\t// let close-to-zero collapse to zero (i.e. smaller than epsilon is considered zero)\n\t\tvar c = Math.abs(dp) > this.kFrictionEpsilon ? coeff : 0;\n\t\t// reposition using damped velocity\n\t\tthis[ex] = this[ex0] + c * dp;\n\t},\n\n\t/**\n\t* One unit of time for simulation.\n\t*\n\t* @private\n\t*/\n\tframe: 10,\n\t// piece-wise constraint simulation\n\tsimulate: function (t) {\n\t\twhile (t >= this.frame) {\n\t\t\tt -= this.frame;\n\t\t\tif (!this.dragging) {\n\t\t\t\tthis.constrain();\n\t\t\t}\n\t\t\tthis.verlet();\n\t\t\tthis.friction('y', 'y0', this.kFrictionDamping);\n\t\t\tthis.friction('x', 'x0', this.kFrictionDamping);\n\t\t}\n\t\treturn t;\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tgetDampingBoundaries: function() {\n\t\treturn this.haveBoundarySnapshot ?\n\t\t\tthis.boundarySnapshot :\n\t\t\t{\n\t\t\t\ttop : this.topBoundary,\n\t\t\t\tbottom : this.bottomBoundary,\n\t\t\t\tleft : this.leftBoundary,\n\t\t\t\tright : this.rightBoundary\n\t\t\t};\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\ttakeBoundarySnapshot: function () {\n\t\tvar s;\n\n\t\tif (!this.haveBoundarySnapshot) {\n\t\t\ts = this.boundarySnapshot;\n\n\t\t\ts.top = this.topBoundary;\n\t\t\ts.bottom = this.bottomBoundary;\n\t\t\ts.left = this.leftBoundary;\n\t\t\ts.right = this.rightBoundary;\n\n\t\t\tthis.haveBoundarySnapshot = true;\n\t\t}\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tdiscardBoundarySnapshot: function() {\n\t\tthis.haveBoundarySnapshot = false;\n\t},\n\n\t/**\n\t* @fires module:enyo/ScrollMath~ScrollMath#onScrollStop\n\t* @private\n\t*/\n\tanimate: function () {\n\t\tthis.stop();\n\t\t// time tracking\n\t\tvar t0 = utils.perfNow(), t = 0;\n\t\t// delta tracking\n\t\tvar x0, y0;\n\t\t// animation handler\n\t\tvar fn = this.bindSafely(function() {\n\t\t\t// wall-clock time\n\t\t\tvar t1 = utils.perfNow();\n\t\t\t// schedule next frame\n\t\t\tthis.job = animation.requestAnimationFrame(fn);\n\t\t\t// delta from last wall clock time\n\t\t\tvar dt = t1 - t0;\n\t\t\t// record the time for next delta\n\t\t\tt0 = t1;\n\t\t\t// user drags override animation\n\t\t\tif (this.dragging) {\n\t\t\t\tthis.y0 = this.y = this.uy;\n\t\t\t\tthis.x0 = this.x = this.ux;\n\t\t\t\tthis.endX = this.endY = null;\n\t\t\t}\n\t\t\t// frame-time accumulator\n\t\t\t// min acceptable time is 16ms (60fps)\n\t\t\tt += Math.max(16, dt);\n\t\t\t// prevent snapping to originally desired scroll position if we are in overscroll\n\t\t\tif (this.isInOverScroll()) {\n\t\t\t\tthis.endX = null;\n\t\t\t\tthis.endY = null;\n\n\t\t\t\tthis.takeBoundarySnapshot();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.discardBoundarySnapshot();\n\n\t\t\t\t// alternate fixed-time step strategy:\n\t\t\t\tif (this.fixedTime) {\n\t\t\t\t\tt = this.interval;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// consume some t in simulation\n\t\t\tt = this.simulate(t);\n\t\t\t// scroll if we have moved, otherwise the animation is stalled and we can stop\n\t\t\tif (y0 != this.y || x0 != this.x) {\n\t\t\t\tthis.scroll();\n\t\t\t} else if (!this.dragging) {\n\t\t\t\t// set final values\n\t\t\t\tif (this.endX != null) {\n\t\t\t\t\tthis.x = this.x0 = this.endX;\n\t\t\t\t}\n\t\t\t\tif (this.endY != null) {\n\t\t\t\t\tthis.y = this.y0 = this.endY;\n\t\t\t\t}\n\n\t\t\t\tthis.stop();\n\t\t\t\tthis.scroll();\n\t\t\t\tthis.doScrollStop();\n\n\t\t\t\tthis.endX = null;\n\t\t\t\tthis.endY = null;\n\t\t\t}\n\t\t\ty0 = this.y;\n\t\t\tx0 = this.x;\n\t\t});\n\t\tthis.job = animation.requestAnimationFrame(fn);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstart: function () {\n\t\tif (!this.job) {\n\t\t\tthis.doScrollStart();\n\t\t\tthis.animate();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstop: function (fire) {\n\t\tvar job = this.job;\n\t\tif (job) {\n\t\t\tthis.job = animation.cancelAnimationFrame(job);\n\t\t}\n\t\tif (fire) {\n\t\t\tthis.doScrollStop();\n\n\t\t\tthis.endX = undefined;\n\t\t\tthis.endY = undefined;\n\t\t}\n\t},\n\n\t/**\n\t* Adjusts the scroll position to be valid, if necessary (e.g., after the scroll contents\n\t* have changed).\n\t*\n\t* @private\n\t*/\n\tstabilize: function (opts) {\n\t\tvar fire = !opts || opts.fire === undefined || opts.fire;\n\t\tvar y = Math.min(this.topBoundary, Math.max(this.bottomBoundary, this.y));\n\t\tvar x = Math.min(this.leftBoundary, Math.max(this.rightBoundary, this.x));\n\t\tif (y != this.y || x != this.x) {\n\t\t\tthis.y = this.y0 = y;\n\t\t\tthis.x = this.x0 = x;\n\t\t\tif (fire) {\n\t\t\t\tthis.doStabilize();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstartDrag: function (e) {\n\t\tthis.dragging = true;\n\t\t//\n\t\tthis.my = e.pageY;\n\t\tthis.py = this.uy = this.y;\n\t\t//\n\t\tthis.mx = e.pageX;\n\t\tthis.px = this.ux = this.x;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdrag: function (e) {\n\t\tvar dy, dx, v, h;\n\t\tif (this.dragging) {\n\t\t\tv = this.canScrollY();\n\t\t\th = this.canScrollX();\n\n\t\t\tdy = v ? e.pageY - this.my : 0;\n\t\t\tthis.uy = dy + this.py;\n\t\t\t// provides resistance against dragging into overscroll\n\t\t\tthis.uy = this.boundaryDamping(this.uy, this.topBoundary, this.bottomBoundary, this.kDragDamping);\n\t\t\t//\n\t\t\tdx = h ? e.pageX - this.mx : 0;\n\t\t\tthis.ux = dx + this.px;\n\t\t\t// provides resistance against dragging into overscroll\n\t\t\tthis.ux = this.boundaryDamping(this.ux, this.leftBoundary, this.rightBoundary, this.kDragDamping);\n\t\t\t//\n\t\t\tthis.start();\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdragDrop: function () {\n\t\tif (this.dragging && !window.PalmSystem) {\n\t\t\tvar kSimulatedFlickScalar = 0.5;\n\t\t\tthis.y = this.uy;\n\t\t\tthis.y0 = this.y - (this.y - this.y0) * kSimulatedFlickScalar;\n\t\t\tthis.x = this.ux;\n\t\t\tthis.x0 = this.x - (this.x - this.x0) * kSimulatedFlickScalar;\n\t\t}\n\t\tthis.dragFinish();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdragFinish: function () {\n\t\tthis.dragging = false;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tflick: function (e) {\n\t\tvar v;\n\t\tif (this.canScrollY()) {\n\t\t\tv = e.yVelocity > 0 ? Math.min(this.kMaxFlick, e.yVelocity) : Math.max(-this.kMaxFlick, e.yVelocity);\n\t\t\tthis.y = this.y0 + v * this.kFlickScalar;\n\t\t}\n\t\tif (this.canScrollX()) {\n\t\t\tv = e.xVelocity > 0 ? Math.min(this.kMaxFlick, e.xVelocity) : Math.max(-this.kMaxFlick, e.xVelocity);\n\t\t\tthis.x = this.x0 + v * this.kFlickScalar;\n\t\t}\n\t\tthis.start();\n\t},\n\n\t/**\n\t* TODO: Refine and test newMousewheel, remove this\n\t* @private\n\t*/\n\tmousewheel: function (e) {\n\t\tvar dy = this.vertical ? e.wheelDeltaY || (!e.wheelDeltaX ? e.wheelDelta : 0) : 0,\n\t\t\tdx = this.horizontal ? e.wheelDeltaX : 0,\n\t\t\tshouldScroll = false;\n\t\tif ((dy > 0 && this.y < this.topBoundary) || (dy < 0 && this.y > this.bottomBoundary)) {\n\t\t\tthis.y = this.y0 = this.y0 + dy;\n\t\t\tshouldScroll = true;\n\t\t}\n\t\tif ((dx > 0 && this.x < this.leftBoundary) || (dx < 0 && this.x > this.rightBoundary)) {\n\t\t\tthis.x = this.x0 = this.x0 + dx;\n\t\t\tshouldScroll = true;\n\t\t}\n\t\tthis.stop(!shouldScroll);\n\t\tif (shouldScroll) {\n\t\t\tthis.start();\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tnewMousewheel: function (e, opts) {\n\t\tvar rtl = opts && opts.rtl,\n\t\t\twdY = (e.wheelDeltaY === undefined) ? e.wheelDelta : e.wheelDeltaY,\n\t\t\tdY = wdY,\n\t\t\tdX = rtl ? -e.wheelDeltaX : e.wheelDeltaX,\n\t\t\tcanY = this.canScrollY(),\n\t\t\tcanX = this.canScrollX(),\n\t\t\tshouldScroll = false,\n\t\t\tm = 2,\n\t\t\t// TODO: Figure out whether we need to port the configurable\n\t\t\t// max / multiplier feature from Moonstone's implementation,\n\t\t\t// and (if so) how\n\t\t\t// max = 100,\n\t\t\tscr = this.isScrolling(),\n\t\t\tovr = this.isInOverScroll(),\n\t\t\trefY = (scr && this.endY !== null) ? this.endY : this.y,\n\t\t\trefX = (scr && this.endX !== null) ? this.endX : this.x,\n\t\t\ttY = refY,\n\t\t\ttX = refX;\n\n\t\tif (ovr) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If we're getting strictly vertical mousewheel events over a scroller that\n\t\t// can only move horizontally, the user is probably using a one-dimensional\n\t\t// mousewheel and would like us to scroll horizontally instead\n\t\tif (dY && !dX && canX && !canY) {\n\t\t\tdX = dY;\n\t\t\tdY = 0;\n\t\t}\n\n\t\tif (dY && canY) {\n\t\t\ttY = -(refY + (dY * m));\n\t\t\tshouldScroll = true;\n\t\t}\n\t\tif (dX && canX) {\n\t\t\ttX = -(refX + (dX * m));\n\t\t\tshouldScroll = true;\n\t\t}\n\n\t\tif (shouldScroll) {\n\t\t\tthis.scrollTo(tX, tY, {allowOverScroll: true});\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t/**\n\t* @fires module:enyo/ScrollMath~ScrollMath#onScroll\n\t* @private\n\t*/\n\tscroll: function () {\n\t\tthis.doScroll();\n\t},\n\n\t// NOTE: Yip/Orvell method for determining scroller instantaneous velocity\n\t// FIXME: incorrect if called when scroller is in overscroll region\n\t// because does not account for additional overscroll damping.\n\n\t/**\n\t* Scrolls to the specified position.\n\t*\n\t* @param {Number} x - The `x` position in pixels.\n\t* @param {Number} y - The `y` position in pixels.\n\t* @param {Object} opts - TODO: Document. When behavior == 'instant', we skip animation.\n\t* @private\n\t*/\n\tscrollTo: function (x, y, opts) {\n\t\tvar animate = !opts || opts.behavior !== 'instant',\n\t\t\txSnap = this.xSnapIncrement,\n\t\t\tySnap = this.ySnapIncrement,\n\t\t\tallowOverScroll = opts && opts.allowOverScroll,\n\t\t\tmaxX = Math.abs(Math.min(0, this.rightBoundary)),\n\t\t\tmaxY = Math.abs(Math.min(0, this.bottomBoundary));\n\n\t\tif (typeof xSnap === 'number') {\n\t\t\tx = xSnap * Math.round(x / xSnap);\n\t\t}\n\n\t\tif (typeof ySnap === 'number') {\n\t\t\ty = ySnap * Math.round(y / ySnap);\n\t\t}\n\n\t\tif (!animate || !allowOverScroll) {\n\t\t\tx = Math.max(0, Math.min(x, maxX));\n\t\t\ty = Math.max(0, Math.min(y, maxY));\n\t\t}\n\n\t\tif (-x == this.x && -y == this.y) return;\n\n\t\tif (!animate) {\n\t\t\tthis.doScrollStart();\n\t\t\tthis.setScrollX(-x);\n\t\t\tthis.setScrollY(-y);\n\t\t\tthis.doScroll();\n\t\t\tthis.doScrollStop();\n\t\t}\n\t\telse {\n\t\t\tif (y !== null) {\n\t\t\t\tthis.endY = -y;\n\t\t\t\tthis.y = this.y0 - (y + this.y0) * (1 - this.kFrictionDamping);\n\t\t\t}\n\t\t\tif (x !== null) {\n\t\t\t\tthis.endX = -x;\n\t\t\t\tthis.x = this.x0 - (x + this.x0) * (1 - this.kFrictionDamping);\n\t\t\t}\n\t\t\tthis.start();\n\t\t}\n\t},\n\n\t/**\n\t* Sets the scroll position along the x-axis.\n\t*\n\t* @param {Number} x - The x-axis scroll position in pixels.\n\t* @method\n\t* @private\n\t*/\n\tsetScrollX: function (x) {\n\t\tthis.x = this.x0 = x;\n\t},\n\n\t/**\n\t* Sets the scroll position along the y-axis.\n\t*\n\t* @param {Number} y - The y-axis scroll position in pixels.\n\t* @method\n\t* @private\n\t*/\n\tsetScrollY: function (y) {\n\t\tthis.y = this.y0 = y;\n\t},\n\n\t/**\n\t* Sets the scroll position; defaults to setting this position along the y-axis.\n\t*\n\t* @param {Number} pos - The scroll position in pixels.\n\t* @method\n\t* @private\n\t*/\n\tsetScrollPosition: function (pos) {\n\t\tthis.setScrollY(pos);\n\t},\n\n\tcanScrollX: function() {\n\t\treturn this.horizontal && this.rightBoundary < 0;\n\t},\n\n\tcanScrollY: function() {\n\t\treturn this.vertical && this.bottomBoundary < 0;\n\t},\n\n\n\t/**\n\t* Determines whether or not the [scroller]{@link module:enyo/Scroller~Scroller} is actively moving.\n\t*\n\t* @return {Boolean} `true` if actively moving; otherwise, `false`.\n\t* @private\n\t*/\n\tisScrolling: function () {\n\t\treturn Boolean(this.job);\n\t},\n\n\t/**\n\t* Determines whether or not the [scroller]{@link module:enyo/Scroller~Scroller} is in overscroll.\n\t*\n\t* @return {Boolean} `true` if in overscroll; otherwise, `false`.\n\t* @private\n\t*/\n\tisInOverScroll: function () {\n\t\treturn this.job && (this.x > this.leftBoundary || this.x < this.rightBoundary ||\n\t\t\tthis.y > this.topBoundary || this.y < this.bottomBoundary);\n\t}\n});\n",
    "mtime": 1542469884419,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ScrollMath.js",
    "relPath": "enyo/ScrollMath",
    "requires": [
      "enyo",
      "./kind",
      "./utils",
      "./platform",
      "./animation",
      "./Component"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./master",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/master",
    "name": "enyo/master",
    "isFile": true,
    "contents": "require('enyo');\n\nvar\n\tutils = require('./utils');\nvar\n\tComponent = require('./Component'),\n\tSignals = require('./Signals');\n\n/**\n* Default owner assigned to ownerless [UiComponents]{@link module:enyo/UiComponent~UiComponent},\n* to allow such UiComponents to be notified of important system events like window resize.\n*\n* NOTE: Ownerless [UiComponents]{@link module:enyo/UiComponent~UiComponent} will not be garbage collected unless \n* explicitly destroyed, as they will be referenced by `master`.\n*\n* @module enyo/master\n* @private\n*/\nvar master = module.exports = new Component({\n\tname: 'master',\n\tnotInstanceOwner: true,\n\teventFlags: {showingOnly: true}, // don't waterfall these events into hidden controls\n\tgetId: function () {\n\t\treturn '';\n\t},\n\tisDescendantOf: utils.nop,\n\tbubble: function (nom, event) {\n\t\t//enyo.log('master event: ' + nom);\n\t\tif (nom == 'onresize') {\n\t\t\t// Resize is special; waterfall this message.\n\t\t\t// This works because master is a Component, so it waterfalls\n\t\t\t// to its owned Components (i.e., master has no children).\n\t\t\tmaster.waterfallDown('onresize', this.eventFlags);\n\t\t\tmaster.waterfallDown('onpostresize', this.eventFlags);\n\t\t} else {\n\t\t\t// All other top-level events are sent only to interested Signal\n\t\t\t// receivers.\n\t\t\tSignals.send(nom, event);\n\t\t}\n\t}\n});\n",
    "mtime": 1542469884687,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/master.js",
    "relPath": "enyo/master",
    "requires": [
      "enyo",
      "./utils",
      "./Component",
      "./Signals"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./Controller",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/Controller",
    "name": "enyo/Controller",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/Controller~Controller} kind.\n* @module enyo/Controller\n*/\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils');\n\nvar\n\tMultipleDispatchComponent = require('./MultipleDispatchComponent');\n\n/**\n* {@link module:enyo/Controller~Controller} is the base [kind]{@glossary kind} for all\n* controllers in Enyo. An abstract kind, `enyo/Controller` is a\n* [delegate]{@glossary delegate}/[component]{@link module:enyo/Component~Component} that\n* is designed to be a proxy for information.\n*\n* @class Controller\n* @extends module:enyo/MultipleDispatchComponent~MultipleDispatchComponent\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/Controller~Controller.prototype */ {\n\n\tname: 'enyo.Controller',\n\n\t/**\n\t* @private\n\t*/\n\tkind: MultipleDispatchComponent,\n\n\t/**\n\t* Set this flag to `true` to make this [controller]{@link module:enyo/Controller~Controller}\n\t* available globally, when instanced. When set to `true`, even the\n\t* [owner]{@link module:enyo/Component~Component#owner} (if any) cannot\n\t* [destroy]{@link module:enyo/Component~Component#destroy} it.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\tglobal: false,\n\n\t/**\n\t* The default source of information for all instances of {@link module:enyo/Controller~Controller}\n\t* and its [subkinds]{@glossary subkind}. In some cases, this will be a\n\t* [computed property]{@link module:enyo/ComputedSupport} to facilitate overloading.\n\t* It may contain any type of data.\n\t*\n\t* @type {*}\n\t* @default null\n\t* @public\n\t*/\n\tdata: null,\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tconstructor: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\t// don't attempt to set a controller globally without a name\n\t\t\tif (this.global && this.name) {\n\t\t\t\tutils.setPath.call(global, this.name, this);\n\t\t\t}\n\t\t};\n\t}),\n\t_isController: true\n});\n",
    "mtime": 1542469884111,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/Controller.js",
    "relPath": "enyo/Controller",
    "requires": [
      "enyo",
      "./kind",
      "./utils",
      "./MultipleDispatchComponent"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "../dispatcher",
    "base": "/home/udo/git/NCPV/lib/enyo/src/Control",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/dispatcher",
    "name": "enyo/dispatcher",
    "isFile": true,
    "contents": "/**\n* Contains dispatcher methods\n* @module enyo/dispatcher\n* @private\n*/\nrequire('enyo');\n\nvar\n\tlogger = require('./logger'),\n\tmaster = require('./master'),\n\tutils = require('./utils');\n\nvar\n\tDom = require('./dom');\n\n/**\n * An [object]{@glossary Object} describing the the last known coordinates of the cursor or\n * user-interaction point in touch environments.\n *\n * @typedef {Object} module:enyo/dispatcher~CursorCoordinates\n * @property {Number} clientX - The horizontal coordinate within the application's client area.\n * @property {Number} clientY - The vertical coordinate within the application's client area.\n * @property {Number} pageX - The X coordinate of the cursor relative to the viewport, including any\n *   scroll offset.\n * @property {Number} pageY - The Y coordinate of the cursor relative to the viewport, including any\n *   scroll offset.\n * @property {Number} screenX - The X coordinate of the cursor relative to the screen, not including\n *   any scroll offset.\n * @property {Number} screenY - The Y coordinate of the cursor relative to the screen, not including\n *   any scroll offset.\n */\n\n/**\n* @private\n*/\nvar dispatcher = module.exports = dispatcher = {\n\n\t$: {},\n\n\t/**\n\t* These events come from document\n\t*\n\t* @private\n\t*/\n\tevents: ['mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'mousewheel',\n\t\t'click', 'dblclick', 'change', 'keydown', 'keyup', 'keypress', 'input',\n\t\t'paste', 'copy', 'cut', 'webkitTransitionEnd', 'transitionend', 'webkitAnimationEnd', 'animationend',\n\t\t'webkitAnimationStart', 'animationstart', 'webkitAnimationIteration', 'animationiteration'],\n\n\t/**\n\t* These events come from window\n\t*\n\t* @private\n\t*/\n\twindowEvents: ['resize', 'load', 'unload', 'message', 'hashchange', 'popstate', 'focus', 'blur'],\n\n\t/**\n\t* Feature plugins (aka filters)\n\t*\n\t* @private\n\t*/\n\tfeatures: [],\n\n\t/**\n\t* @private\n\t*/\n\tconnect: function() {\n\t\tvar d = dispatcher, i, n;\n\t\tfor (i=0; (n=d.events[i]); i++) {\n\t\t\td.listen(document, n);\n\t\t}\n\t\tfor (i=0; (n=d.windowEvents[i]); i++) {\n\t\t\t// Chrome Packaged Apps don't like \"unload\"\n\t\t\tif(n === 'unload' &&\n\t\t\t\t(typeof global.chrome === 'object') &&\n\t\t\t\tglobal.chrome.app) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\td.listen(window, n);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tlisten: function(inListener, inEventName, inHandler) {\n\t\tinListener.addEventListener(inEventName, inHandler || dispatch, false);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstopListening: function(inListener, inEventName, inHandler) {\n\t\tinListener.removeEventListener(inEventName, inHandler || dispatch, false);\n\t},\n\n\t/**\n\t* Fires an event for Enyo to listen for.\n\t*\n\t* @private\n\t*/\n\tdispatch: function(e) {\n\t\t// Find the control who maps to e.target, or the first control that maps to an ancestor of e.target.\n\t\tvar c = this.findDispatchTarget(e.target) || this.findDefaultTarget();\n\t\t// Cache the original target\n\t\te.dispatchTarget = c;\n\t\t// support pluggable features return true to abort immediately or set e.preventDispatch to avoid processing.\n\t\tfor (var i=0, fn; (fn=this.features[i]); i++) {\n\t\t\tif (fn.call(this, e) === true) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (c && !e.preventDispatch) {\n\t\t\treturn this.dispatchBubble(e, c);\n\t\t}\n\t},\n\n\t/**\n\t* Takes an event target and finds the corresponding Enyo control.\n\t*\n\t* @private\n\t*/\n\tfindDispatchTarget: function(inNode) {\n\t\tvar t, n = inNode;\n\t\t// FIXME: Mozilla: try/catch is here to squelch \"Permission denied to access property xxx from a non-chrome context\"\n\t\t// which appears to happen for scrollbar nodes in particular. It's unclear why those nodes are valid targets if\n\t\t// it is illegal to interrogate them. Would like to trap the bad nodes explicitly rather than using an exception block.\n\t\ttry {\n\t\t\twhile (n) {\n\t\t\t\tif ((t = this.$[n.id])) {\n\t\t\t\t\t// there could be multiple nodes with this id, the relevant node for this event is n\n\t\t\t\t\t// we don't push this directly to t.node because sometimes we are just asking what\n\t\t\t\t\t// the target 'would be' (aka, calling findDispatchTarget from handleMouseOverOut)\n\t\t\t\t\tt.eventNode = n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn = n.parentNode;\n\t\t\t}\n\t\t} catch(x) {\n\t\t\tlogger.log(x, n);\n\t\t}\n\t\treturn t;\n\t},\n\n\t/**\n\t* Returns the default Enyo control for events.\n\t*\n\t* @private\n\t*/\n\tfindDefaultTarget: function() {\n\t\treturn master;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdispatchBubble: function(e, c) {\n\t\tvar type = e.type;\n\t\ttype = e.customEvent ? type : 'on' + type;\n\t\treturn c.bubble(type, e, c);\n\t}\n};\n\n/**\n* Called in the context of an event.\n*\n* @name module:enyo/dispatcher.iePreventDefault\n* @static\n* @method\n* @private\n*/\ndispatcher.iePreventDefault = function() {\n\ttry {\n\t\tthis.returnValue = false;\n\t}\n\tcatch(e) {\n\t\t// do nothing\n\t}\n};\n\n/**\n* @private\n*/\nfunction dispatch (inEvent) {\n\treturn dispatcher.dispatch(inEvent);\n}\n\n/**\n* @name module:enyo/dispatcher.bubble\n* @static\n* @method\n* @private\n*/\ndispatcher.bubble = function(inEvent) {\n\tif (inEvent) {\n\t\tdispatcher.dispatch(inEvent);\n\t}\n};\n\n// This string is set on event handlers attributes for DOM elements that\n// don't normally bubble (like onscroll) so that they can participate in the\n// Enyo event system.\ndispatcher.bubbler = 'enyo.bubble(arguments[0])';\n\n// The code below helps make Enyo compatible with Google Packaged Apps\n// Content Security Policy(http://developer.chrome.com/extensions/contentSecurityPolicy.html),\n// which, among other things, forbids the use of inline scripts.\n// We replace online scripting with equivalent means, leaving dispatcher.bubbler\n// for backward compatibility.\n(function() {\n\tvar bubbleUp = function() {\n\t\tdispatcher.bubble(arguments[0]);\n\t};\n\n\t/**\n\t* Makes given events bubble on a specified Enyo control.\n\t*\n\t* @name: module:enyo/dispatcher.makeBubble\n\t* @method\n\t* @private\n\t*/\n\tdispatcher.makeBubble = function() {\n\t\tvar args = Array.prototype.slice.call(arguments, 0),\n\t\t\tcontrol = args.shift();\n\n\t\tif((typeof control === 'object') && (typeof control.hasNode === 'function')) {\n\t\t\tutils.forEach(args, function(event) {\n\t\t\t\tif(this.hasNode()) {\n\t\t\t\t\tdispatcher.listen(this.node, event, bubbleUp);\n\t\t\t\t}\n\t\t\t}, control);\n\t\t}\n\t};\n\n\t/**\n\t* Removes the event listening and bubbling initiated by\n\t* [makeBubble()]{@link module:enyo/dispatcher.makeBubble} on a specific control.\n\t*\n\t* @name: module:enyo/dispatcher.unmakeBubble\n\t* @method\n\t* @private\n\t*/\n\tdispatcher.unmakeBubble = function() {\n\t\tvar args = Array.prototype.slice.call(arguments, 0),\n\t\t\tcontrol = args.shift();\n\n\t\tif((typeof control === 'object') && (typeof control.hasNode === 'function')) {\n\t\t\tutils.forEach(args, function(event) {\n\t\t\t\tif(this.hasNode()) {\n\t\t\t\t\tdispatcher.stopListening(this.node, event, bubbleUp);\n\t\t\t\t}\n\t\t\t}, control);\n\t\t}\n\t};\n})();\n\n/**\n* @private\n*/\n// FIXME: we need to create and initialize dispatcher someplace else to allow overrides\nDom.requiresWindow(dispatcher.connect);\n\n/**\n* Generates a tapped event for a raw-click event.\n*\n* @private\n*/\ndispatcher.features.push(\n\tfunction (e) {\n\t\tif ('click' === e.type) {\n\t\t\tif (e.clientX === 0 && e.clientY === 0 && !e.detail) {\n\t\t\t\t// this allows the click to dispatch as well\n\t\t\t\t// but note the tap event will fire first\n\t\t\t\tvar cp = utils.clone(e);\n\t\t\t\tcp.type = 'tap';\n\t\t\t\tcp.preventDefault = utils.nop;\n\t\t\t\tdispatcher.dispatch(cp);\n\t\t\t}\n\t\t}\n\t}\n);\n\n/**\n* Instead of having multiple `features` pushed and handled in separate methods\n* for these events, we handle them uniformly here to expose the last known\n* interaction coordinates as accurately as possible.\n*\n* @private\n*/\nvar _xy = {};\ndispatcher.features.push(\n\tfunction (e) {\n\t\tif (\n\t\t\t(e.type == 'mousemove')  ||\n\t\t\t(e.type == 'tap')        ||\n\t\t\t(e.type == 'click')      ||\n\t\t\t(e.type == 'touchmove')\n\t\t) {\n\t\t\tvar evt = (e.type == 'touchmove') ? e.touches[0] : e;\n\t\t\t_xy.clientX = evt.clientX;\n\t\t\t_xy.clientY = evt.clientY;\n\t\t\t// note only ie8 does not support pageX/pageY\n\t\t\t_xy.pageX   = evt.pageX;\n\t\t\t_xy.pageY   = evt.pageY;\n\t\t\t// note ie8 and opera report these values incorrectly\n\t\t\t_xy.screenX = evt.screenX;\n\t\t\t_xy.screenY = evt.screenY;\n\t\t}\n\t}\n);\n\n/**\n* Retrieves the last known coordinates of the cursor or user-interaction point\n* in touch environments. Returns an immutable object with the `clientX`,\n* `clientY`, `pageX`, `pageY`, `screenX`, and `screenY` properties. It is\n* important to note that IE8 and Opera have improper reporting for the\n* `screenX` and `screenY` properties (they both use CSS pixels as opposed to\n* device pixels).\n*\n* @returns {module:enyo/dispatcher~CursorCoordinates} An [object]{@glossary Object} describing the\n*\tthe last known coordinates of the cursor or user-interaction point in touch environments.\n* @public\n*/\ndispatcher.getPosition = function () {\n\treturn utils.clone(_xy);\n};\n\n\n/**\n* Key mapping feature: Adds a `keySymbol` property to key [events]{@glossary event},\n* based on a global key mapping. Use\n* [registerKeyMap()]{@link module:enyo/dispatcher.registerKeyMap} to add\n* keyCode-to-keySymbol mappings via a simple hash. This method may be called\n* multiple times from different libraries to mix different maps into the global\n* mapping table; if conflicts arise, the last-in wins.\n*\n* ```\n* dispatcher.registerKeyMap({\n* \t415 : 'play',\n* \t413 : 'stop',\n* \t19  : 'pause',\n* \t412 : 'rewind',\n* \t417 : 'fastforward'\n* });\n* ```\n*\n* @private\n*/\ndispatcher.features.push(function(e) {\n\tif ((e.type === 'keydown') || (e.type === 'keyup') || (e.type === 'keypress')) {\n\t\te.keySymbol = this.keyMap[e.keyCode];\n\t\t// Dispatch key events to be sent via Signals\n\t\tvar c = this.findDefaultTarget();\n\t\tif (e.dispatchTarget !== c) {\n\t\t\tthis.dispatchBubble(e, c);\n\t\t}\n\t}\n});\n\nutils.mixin(dispatcher, {\n\tkeyMap: {},\n\tregisterKeyMap: function(map) {\n\t\tutils.mixin(this.keyMap, map);\n\t}\n});\n\n\n/**\n* Event modal capture feature. Capture events to a specific control via\n* [capture(inControl, inShouldForward)]{@linkcode module:enyo/dispatcher.capture};\n* release events via [release()]{@link module:enyo/dispatcher.release}.\n*\n* @private\n*/\ndispatcher.features.push(function(e) {\n\tif (this.captureTarget) {\n\t\tvar c = e.dispatchTarget;\n\t\tvar eventName = (e.customEvent ? '' : 'on') + e.type;\n\t\tvar handlerName = this.captureEvents[eventName];\n\t\tvar handlerScope = this.captureHandlerScope || this.captureTarget;\n\t\tvar handler = handlerName && handlerScope[handlerName];\n\t\tvar shouldCapture = handler && !(c && c.isDescendantOf && c.isDescendantOf(this.captureTarget));\n\t\tif (shouldCapture) {\n\t\t\tvar c1 = e.captureTarget = this.captureTarget;\n\t\t\t// NOTE: We do not want releasing capture while an event is being processed to alter\n\t\t\t// the way the event propagates. Therefore decide if the event should forward\n\t\t\t// before the capture target receives the event (since it may release capture).\n\t\t\te.preventDispatch = handler && handler.apply(handlerScope, [c1, e]) && !this.autoForwardEvents[e.type];\n\t\t}\n\t}\n});\n\n//\n//        NOTE: This object is a plug-in; these methods should\n//        be called on `enyo/dispatcher`, and not on the plug-in itself.\n//\nutils.mixin(dispatcher, {\n\n\t/**\n\t* @private\n\t*/\n\tautoForwardEvents: {leave: 1, resize: 1},\n\n\t/**\n\t* @private\n\t*/\n\tcaptures: [],\n\n\t/**\n\t* Captures [events]{@glossary event} for `inTarget`, where `inEvents` is specified as a\n\t* hash of event names mapped to callback handler names to be called on `inTarget` (or,\n\t* optionally, `inScope`). The callback is called when any of the captured events are\n\t* dispatched outside of the capturing control. Returning `true` from the callback stops\n\t* dispatch of the event to the original `dispatchTarget`.\n\t*\n\t* @private\n\t*/\n\tcapture: function(inTarget, inEvents, inScope) {\n\t\tvar info = {target: inTarget, events: inEvents, scope: inScope};\n\t\tthis.captures.push(info);\n\t\tthis.setCaptureInfo(info);\n\t},\n\n\t/**\n\t* Removes the specified target from the capture list.\n\t*\n\t* @private\n\t*/\n\trelease: function(inTarget) {\n\t\tfor (var i = this.captures.length - 1; i >= 0; i--) {\n\t\t\tif (this.captures[i].target === inTarget) {\n\t\t\t\tthis.captures.splice(i,1);\n\t\t\t\tthis.setCaptureInfo(this.captures[this.captures.length-1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Sets the information for a captured {@glossary event}.\n\t*\n\t* @private\n\t*/\n\tsetCaptureInfo: function(inInfo) {\n\t\tthis.captureTarget = inInfo && inInfo.target;\n\t\tthis.captureEvents = inInfo && inInfo.events;\n\t\tthis.captureHandlerScope = inInfo && inInfo.scope;\n\t}\n});\n\n\n(function () {\n\t/**\n\t* Dispatcher preview feature\n\t*\n\t* Allows {@link module:enyo/Control~Control} ancestors of the {@glossary event} target\n\t* a chance (eldest first) to react by implementing `previewDomEvent`.\n\t*\n\t* @todo Revisit how/if we document this\n\t* @private\n\t*/\n\tvar fn = 'previewDomEvent';\n\tvar preview = {\n\n\t\tfeature: function(e) {\n\t\t\tpreview.dispatch(e, e.dispatchTarget);\n\t\t},\n\n\t\t/*\n\t\t* @returns {(Boolean|undefined)} Handlers return `true` to abort preview and prevent default\n\t\t*\tevent processing.\n\t\t*/\n\t\tdispatch: function(evt, control) {\n\t\t\tvar i, l,\n\t\t\tlineage = this.buildLineage(control);\n\t\t\tfor (i=0; (l=lineage[i]); i++) {\n\t\t\t\tif (l[fn] && l[fn](evt) === true) {\n\t\t\t\t\tevt.preventDispatch = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\t* We ascend, making a list of Enyo [controls]{@link module:enyo/Control~Control}.\n\t\t*\n\t\t* Note that a control is considered to be its own ancestor.\n\t\t*/\n\t\tbuildLineage: function(control) {\n\t\t\tvar lineage = [],\n\t\t\t\tc = control;\n\t\t\twhile (c) {\n\t\t\t\tlineage.unshift(c);\n\t\t\t\tc = c.parent;\n\t\t\t}\n\t\t\treturn lineage;\n\t\t}\n\t};\n\n\tdispatcher.features.push(preview.feature);\n})();\n",
    "mtime": 1542469884635,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/dispatcher.js",
    "relPath": "enyo/dispatcher",
    "requires": [
      "enyo",
      "./logger",
      "./master",
      "./utils",
      "./dom"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "../UiComponent",
    "base": "/home/udo/git/NCPV/lib/enyo/src/Control",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/UiComponent",
    "name": "enyo/UiComponent",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/UiComponent~UiComponent} kind.\n* @module enyo/UiComponent\n*/\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils'),\n\tmaster = require('./master');\n\nvar\n\tComponent = require('./Component');\n\n/**\n* The configurable options used by {@link module:enyo/UiComponent~UiComponent} when updating\n* components.\n*\n* @typedef {Object} enyo/UiComponent~UiComponent~UpdateComponentsOptions\n* @property {Boolean} [silent] - If `true`, component properties will be updated silently i.e. they\n*\twill be set directly, rather than via the generic `set` method.\n*/\n\n/**\n* {@link module:enyo/UiComponent~UiComponent} implements a container strategy suitable for presentation layers.\n*\n* `UiComponent` itself is abstract. Concrete [subkinds]{@glossary subkind} include\n* {@link module:enyo/Control~Control} (for HTML/DOM) and\n* {@link module:canvas/Control~Control} (for Canvas contexts).\n*\n* @class UiComponent\n* @extends module:enyo/Component~Component\n* @public\n*/\nvar UiComponent = module.exports = kind(\n\t/** @lends module:enyo/UiComponent~UiComponent.prototype */ {\n\n\tname: 'enyo.UiComponent',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Component,\n\n\tstatics:\n\t\t/** @lends module:enyo/UiComponent~UiComponent */ {\n\n\t\t/**\n\t\t* The default set of keys which are effectively \"ignored\" when determining whether or not\n\t\t* the this control has changed in such a way that warrants a complete re-render. When\n\t\t* {@link module:enyo/UiComponent~UiComponent#updateComponents} is invoked on a parent\n\t\t* component, this set of stateful keys is utilized by default, if no stateful keys are\n\t\t* provided by us.\n\t\t*\n\t\t* @type {String[]}\n\t\t* @default ['content', active', 'disabled']\n\t\t* @private\n\t\t*/\n\t\tstatefulKeys: [\n\t\t\t'content',\n\t\t\t'active',\n\t\t\t'disabled'\n\t\t],\n\n\t\t/**\n\t\t* Finds static properties by walking up the inheritance chain, until the property is found.\n\t\t* By default this will return the property from {@link module:enyo/UiComponent} if the\n\t\t* property is not found anywhere along the chain.\n\t\t*\n\t\t* @param {module:enyo/kind} kind - The kind which we are attempting to retrieve the property\n\t\t*\tfrom; if the property is not found on this kind, its parent kind will be examined.\n\t\t* @param {String} prop - The property we are trying to retrieve.\n\t\t* @returns {String[]} The array of stateful key strings.\n\t\t* @public\n\t\t*/\n\t\tfindStatic: function (kind, prop) {\n\t\t\tif (kind) {\n\t\t\t\tif (kind[prop]) return kind[prop];\n\t\t\t\treturn UiComponent.findStatic(kind.kind, prop);\n\t\t\t} else {\n\t\t\t\treturn UiComponent[prop];\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tpublished:\n\t\t/** @lends module:enyo/UiComponent~UiComponent.prototype */ {\n\n\t\t/**\n\t\t* The [UiComponent]{@link module:enyo/UiComponent~UiComponent} that physically contains this\n\t\t* [component]{@link module:enyo/Component~Component} in the DOM.\n\t\t*\n\t\t* @type {module:enyo/UiComponent~UiComponent}\n\t\t* @default null\n\t\t* @public\n\t\t*/\n\t\tcontainer: null,\n\n\t\t/**\n\t\t* The [UiComponent]{@link module:enyo/UiComponent~UiComponent} that owns this\n\t\t* [component]{@link module:enyo/Component~Component} for purposes of {@glossary event}\n\t\t* propagation.\n\t\t*\n\t\t* @type {module:enyo/UiComponent~UiComponent}\n\t\t* @default null\n\t\t* @public\n\t\t*/\n\t\tparent: null,\n\n\t\t/**\n\t\t* The [UiComponent]{@link module:enyo/UiComponent~UiComponent} that will physically contain new items added\n\t\t* by calls to [createComponent()]{@link module:enyo/UiComponent~UiComponent#createComponent}.\n\t\t*\n\t\t* @type {String}\n\t\t* @default 'client'\n\t\t* @public\n\t\t*/\n\t\tcontrolParentName: 'client',\n\n\t\t/**\n\t\t* A {@glossary kind} used to manage the size and placement of child\n\t\t* [components]{@link module:enyo/Component~Component}.\n\t\t*\n\t\t* @type {String}\n\t\t* @default ''\n\t\t* @public\n\t\t*/\n\t\tlayoutKind: ''\n\t},\n\n\t/**\n\t* @private\n\t*/\n\thandlers: {\n\t\tonresize: 'handleResize'\n\t},\n\n\t/**\n\t* When set, provides a [control]{@link module:enyo/Control~Control} reference used to indicate where a\n\t* newly-created [component]{@link module:enyo/Component~Component} should be added in the\n\t* [UiComponent's]{@link module:enyo/UiComponent~UiComponent} [array]{@glossary Array} of children. This is\n\t* typically used when creating children dynamically (rather than at design time). If set\n\t* to `null`, the new control will be added at the beginning of the array; if set to a\n\t* specific existing control, the new control will be added before the specified\n\t* control. If left as `undefined`, the default behavior is to add the new control\n\t* at the end of the array.\n\t*\n\t* @type {module:enyo/Control~Control}\n\t* @default undefined\n\t* @public\n\t*/\n\taddBefore: undefined,\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tthis.controls = this.controls || [];\n\t\t\tthis.children = this.children || [];\n\t\t\tthis.containerChanged();\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.layoutKindChanged();\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\t// Destroys all non-chrome controls (regardless of owner).\n\t\t\tthis.destroyClientControls();\n\t\t\t// Removes us from our container.\n\t\t\tthis.setContainer(null);\n\t\t\t// Destroys chrome controls owned by this.\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\timportProps: kind.inherit(function (sup) {\n\t\treturn function(inProps) {\n\t\t\tsup.apply(this, arguments);\n\t\t\tif (!this.owner) {\n\t\t\t\tthis.owner = master;\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* Creates [components]{@link module:enyo/Component~Component} as defined by the [arrays]{@glossary Array}\n\t* of base and additional property [hashes]{@glossary Object}. The standard and\n\t* additional property hashes are combined as described in\n\t* {@link module:enyo/Component~Component#createComponent}.\n\t*\n\t* ```\n\t* // ask foo to create components 'bar' and 'zot', but set the owner of\n\t* // both components to 'this'.\n\t* this.$.foo.createComponents([\n\t*\t{name: 'bar'},\n\t*\t{name: 'zot'}\n\t* ], {owner: this});\n\t* ```\n\t*\n\t* As implemented, [controlParentName]{@link module:enyo/UiComponent~UiComponent#controlParentName} only works\n\t* to identify an owned control created via `createComponents()`\n\t* (i.e., usually in our `components` block). To attach a `controlParent` via other means,\n\t* one must call [discoverControlParent()]{@link module:enyo/UiComponent~UiComponent#discoverControlParent} or\n\t* set `controlParent` directly.\n\t*\n\t* We could call `discoverControlParent()` in\n\t* [addComponent()]{@link module:enyo/Component~Component#addComponent}, but that would\n\t* cause a lot of useless checking.\n\t*\n\t* @param {Object[]} props The array of {@link module:enyo/Component~Component} definitions to be created.\n\t* @param {Object} ext - Additional properties to be supplied as defaults for each.\n\t* @returns {module:enyo/Component~Component[]} The array of components that were created.\n\t* @method\n\t* @public\n\t*/\n\t//\n\tcreateComponents: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tvar results = sup.apply(this, arguments);\n\t\t\tthis.discoverControlParent();\n\t\t\treturn results;\n\t\t};\n\t}),\n\n\t/**\n\t* An alternative component update path that attempts to intelligently update only the\n\t* relevant portions of the component which have changed.\n\t*\n\t* @param {Object[]} props - An array of kind definitions to be set as the child components of\n\t*\tthis component.\n\t* @param {Object} [ext] - Additional properties to be supplied as defaults for components, when\n\t*\tbeing created or recreated. These properties have no bearing on the diff computation of the\n\t*\tchild components.\n\t* @param {module:enyo/UiComponent~UpdateComponentsOptions} [opts] - Additional options for how\n\t*\tthe update operation should behave.\n\t* @returns {Boolean} - Whether or not the component should be re-rendered.\n\t* @wip\n\t* @public\n\t*/\n\tupdateComponents: function (props, ext, opts) {\n\t\tvar allStatefulKeys = {},\n\t\t\tisChanged = this.computeComponentsDiff(props, allStatefulKeys),\n\t\t\tprop, controls, control, keys, key, idxKey, idxProp, kind;\n\n\t\tif (isChanged) {\n\t\t\tthis.destroyClientControls();\n\t\t\tthis.createComponents(props, ext);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tcontrols = this.getClientControls();\n\t\t\tfor (idxProp = 0; idxProp < props.length; idxProp++) {\n\t\t\t\tprop = props[idxProp];\n\t\t\t\tcontrol = controls[idxProp];\n\t\t\t\tkind = prop.kind || this.defaultKind;\n\t\t\t\tkeys = allStatefulKeys[idxProp];\n\n\t\t\t\tfor (idxKey = 0; idxKey < keys.length; idxKey++) { // for each key, determine if there is a change\n\t\t\t\t\tkey = keys[idxKey];\n\t\t\t\t\tif (prop[key] != control[key]) {\n\t\t\t\t\t\tif (opts && opts.silent) control[key] = prop[key];\n\t\t\t\t\t\telse control.set(key, prop[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcomputeComponentsDiff: function (comps, allStatefulKeys) {\n\t\tvar hash = this.computeComponentsHash(comps, allStatefulKeys),\n\t\t\tisChanged = false;\n\n\t\tif (this._compHash) isChanged = this._compHash != hash;\n\t\telse isChanged = true;\n\n\t\tthis._compHash = hash;\n\n\t\treturn isChanged;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcomputeComponentsHash: function (comps, allStatefulKeys) {\n\t\tvar keyCount = 0,\n\t\t\thash, str, filtered, chr, len, idx;\n\n\t\t// http://jsperf.com/json-parse-and-iteration-vs-array-map\n\t\tfiltered = comps.map(this.bindSafely(function (comp, itemIdx) {\n\t\t\tvar kind = comp.kind || this.defaultKind,\n\t\t\t\tkeys = UiComponent.findStatic(kind, 'statefulKeys'),\n\t\t\t\tobjKeys = Object.keys(comp),\n\t\t\t\tobj = {},\n\t\t\t\tidx, key, value;\n\n\t\t\tallStatefulKeys[itemIdx] = keys; // cache statefulKeys\n\n\t\t\tfor (idx = 0; idx < objKeys.length; idx++) {\n\t\t\t\tkey = objKeys[idx];\n\n\t\t\t\tif (keys.indexOf(key) == -1) { // ignore stateful keys\n\t\t\t\t\tvalue = comp[key];\n\t\t\t\t\tif (typeof value == 'function') value = (value.prototype && value.prototype.kindName) || value.toString();\n\t\t\t\t\tobj[key] = value;\n\t\t\t\t\tkeyCount++;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t}));\n\n\t\t// Adapted from http://stackoverflow.com/a/7616484\n\t\tstr = JSON.stringify(filtered) + keyCount;\n\t\thash = 0;\n\n\t\tfor (idx = 0, len = str.length; idx < len; idx++) {\n\t\t\tchr = str.charCodeAt(idx);\n\t\t\thash = ((hash << 5) - hash) + chr;\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn hash;\n\t},\n\n\t/**\n\t* Determines and sets the current [control's]{@link module:enyo/Control~Control} parent.\n\t*\n\t* @protected\n\t*/\n\tdiscoverControlParent: function () {\n\t\tthis.controlParent = this.$[this.controlParentName] || this.controlParent;\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tadjustComponentProps: kind.inherit(function (sup) {\n\t\treturn function(inProps) {\n\t\t\t// Components we create have us as a container by default.\n\t\t\tinProps.container = inProps.container || this;\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* Containment\n\t*\n\t* @method\n\t* @private\n\t*/\n\tcontainerChanged: function (container) {\n\t\tif (container) {\n\t\t\tcontainer.removeControl(this);\n\t\t}\n\t\tif (this.container) {\n\t\t\tthis.container.addControl(this, this.addBefore);\n\t\t}\n\t},\n\n\t/**\n\t* Parentage\n\t*\n\t* @method\n\t* @private\n\t*/\n\tparentChanged: function (oldParent) {\n\t\tif (oldParent && oldParent != this.parent) {\n\t\t\toldParent.removeChild(this);\n\t\t}\n\t},\n\n\t/**\n\t* Determines whether the [control]{@link module:enyo/Control~Control} is a descendant of\n\t* another control.\n\t*\n\t* Note: Oddly, a control is considered to be a descendant of itself.\n\t*\n\t* @method\n\t* @param {module:enyo/Control~Control} ancestor - The [control]{@link module:enyo/Control~Control} whose lineage\n\t*\twill be checked to determine whether the current control is a descendant.\n\t* @public\n\t*/\n\tisDescendantOf: function (ancestor) {\n\t\tvar p = this;\n\t\twhile (p && p!=ancestor) {\n\t\t\tp = p.parent;\n\t\t}\n\t\treturn ancestor && (p === ancestor);\n\t},\n\n\t/**\n\t* Returns all controls.\n\t*\n\t* @method\n\t* @returns {module:enyo/Control~Control[]} An [array]{@glossary Array} of [controls]{@link module:enyo/Control~Control}.\n\t* @public\n\t*/\n\tgetControls: function () {\n\t\treturn this.controls;\n\t},\n\n\t/**\n\t* Returns all non-chrome controls.\n\t*\n\t* @method\n\t* @returns {module:enyo/Control~Control[]} An [array]{@glossary Array} of [controls]{@link module:enyo/Control~Control}.\n\t* @public\n\t*/\n\tgetClientControls: function () {\n\t\tvar results = [];\n\t\tfor (var i=0, cs=this.controls, c; (c=cs[i]); i++) {\n\t\t\tif (!c.isChrome) {\n\t\t\t\tresults.push(c);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t},\n\n\t/**\n\t* Destroys \"client controls\", the same set of [controls]{@link module:enyo/Control~Control} returned by\n\t* [getClientControls()]{@link module:enyo/UiComponent~UiComponent#getClientControls}.\n\t*\n\t* @method\n\t* @public\n\t*/\n\tdestroyClientControls: function () {\n\t\tvar c$ = this.getClientControls();\n\t\tfor (var i=0, c; (c=c$[i]); i++) {\n\t\t\tc.destroy();\n\t\t}\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\taddControl: function (ctl, before) {\n\t\t// Called to add an already created control to the object's control list. It is\n\t\t// not used to create controls and should likely not be called directly.\n\t\t// It can be overridden to detect when controls are added.\n\t\tif (before !== undefined) {\n\t\t\tvar idx = (before === null) ? 0 : this.indexOfControl(before);\n\t\t\tthis.controls.splice(idx, 0, ctl);\n\t\t} else {\n\t\t\tthis.controls.push(ctl);\n\t\t}\n\t\t// When we add a Control, we also establish a parent.\n\t\tthis.addChild(ctl, before);\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tremoveControl: function (ctl) {\n\t\t// Called to remove a control from the object's control list. As with addControl it\n\t\t// can be overridden to detect when controls are removed.\n\t\t// When we remove a Control, we also remove it from its parent.\n\t\tctl.setParent(null);\n\t\treturn utils.remove(ctl, this.controls);\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tindexOfControl: function (ctl) {\n\t\treturn utils.indexOf(ctl, this.controls);\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tindexOfClientControl: function (ctl) {\n\t\treturn utils.indexOf(ctl, this.getClientControls());\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tindexInContainer: function () {\n\t\treturn this.container.indexOfControl(this);\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tclientIndexInContainer: function () {\n\t\treturn this.container.indexOfClientControl(this);\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcontrolAtIndex: function (idx) {\n\t\treturn this.controls[idx];\n\t},\n\n\t/**\n\t* Determines what the following sibling [control]{@link module:enyo/Control~Control} is for the current\n\t* [control]{@link module:enyo/Control~Control}.\n\t*\n\t* @method\n\t* @returns {module:enyo/Control~Control | null} The [control]{@link module:enyo/Control~Control} that is the] following\n\t*\tsibling. If no following sibling exists, we return `null`.\n\t* @public\n\t*/\n\tgetNextControl: function () {\n\t\tvar comps = this.getParent().children,\n\t\t\tcomp,\n\t\t\tsibling,\n\t\t\ti;\n\n\t\tfor (i = comps.length - 1; i >= 0; i--) {\n\t\t\tcomp = comps[i];\n\t\t\tif (comp === this) return sibling ? sibling : null;\n\t\t\tif (comp.generated) sibling = comp;\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/**\n\t* Children\n\t*\n\t* @method\n\t* @private\n\t*/\n\taddChild: function (child, before) {\n\t\t// if before is undefined, add to the end of the child list.\n\t\t// If it's null, add to front of list, otherwise add before the\n\t\t// specified control.\n\t\t//\n\t\t// allow delegating the child to a different container\n\t\tif (this.controlParent /*&& !child.isChrome*/) {\n\t\t\t// this.controlParent might have a controlParent, and so on; seek the ultimate parent\n\t\t\tthis.controlParent.addChild(child, before);\n\t\t} else {\n\t\t\t// NOTE: addChild drives setParent.\n\t\t\t// It's the opposite for setContainer, where containerChanged (in Containable)\n\t\t\t// drives addControl.\n\t\t\t// Because of the way 'parent' is derived from 'container', this difference is\n\t\t\t// helpful for implementing controlParent.\n\t\t\t// By the same token, since 'parent' is derived from 'container', setParent is\n\t\t\t// not intended to be called by client code. Therefore, the lack of parallelism\n\t\t\t// should be private to this implementation.\n\t\t\t// Set the child's parent property to this\n\t\t\tchild.setParent(this);\n\t\t\t// track in children array\n\t\t\tif (before !== undefined) {\n\t\t\t\tvar idx = (before === null) ? 0 : this.indexOfChild(before);\n\t\t\t\tthis.children.splice(idx, 0, child);\n\t\t\t} else {\n\t\t\t\tthis.children.push(child);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tremoveChild: function (child) {\n\t\treturn utils.remove(child, this.children);\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tindexOfChild: function (child) {\n\t\treturn utils.indexOf(child, this.children);\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tlayoutKindChanged: function () {\n\t\tif (this.layout) {\n\t\t\tthis.layout.destroy();\n\t\t}\n\t\tthis.layout = kind.createFromKind(this.layoutKind, this);\n\t\tif (this.generated) {\n\t\t\tthis.render();\n\t\t}\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tflow: function () {\n\t\tif (this.layout) {\n\t\t\tthis.layout.flow();\n\t\t}\n\t},\n\n\t/**\n\t* CAVEAT: currently we use the entry point for both post-render layout work *and*\n\t* post-resize layout work.\n\t* @method\n\t* @private\n\t*/\n\treflow: function () {\n\t\tif (this.layout) {\n\t\t\tthis.layout.reflow();\n\t\t}\n\t},\n\n\t/**\n\t* Call after this [control]{@link module:enyo/Control~Control} has been resized to allow it to process the\n\t* size change. To respond to a resize, override `handleResize()` instead. Acts as syntactic\n\t* sugar for `waterfall('onresize')`.\n\t*\n\t* @method\n\t* @public\n\t*/\n\tresize: function () {\n\t\tthis.waterfall('onresize');\n\t\tthis.waterfall('onpostresize');\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\thandleResize: function () {\n\t\t// FIXME: once we are in the business of reflowing layouts on resize, then we have an\n\t\t// inside/outside problem: some scenarios will need to reflow before child\n\t\t// controls reflow, and some will need to reflow after. Even more complex scenarios\n\t\t// have circular dependencies, and can require multiple passes or other resolution.\n\t\t// When we can rely on CSS to manage reflows we do not have these problems.\n\t\tthis.reflow();\n\t},\n\n\t/**\n\t* Sends a message to all of my descendants, but not myself. You can stop a\n\t* [waterfall]{@link module:enyo/Component~Component#waterfall} into [components]{@link module:enyo/Component~Component}\n\t* owned by a receiving [object]{@glossary Object} by returning a truthy value from the\n\t* {@glossary event} [handler]{@link module:enyo/Component~Component~EventHandler}.\n\t*\n\t* @method\n\t* @param {String} nom - The name of the {@glossary event}.\n\t* @param {Object} [event] - The event object to pass along.\n\t* @param {module:enyo/Component~Component} [sender=this] - The event's originator.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\twaterfallDown: function (nom, event, sender) {\n\t\tevent = event || {};\n\t\t// Note: Controls will generally be both in a $ hash and a child list somewhere.\n\t\t// Attempt to avoid duplicated messages by sending only to components that are not\n\t\t// UiComponent, as those components are guaranteed not to be in a child list.\n\t\t// May cause a problem if there is a scenario where a UiComponent owns a pure\n\t\t// Component that in turn owns Controls.\n\t\t//\n\t\t// waterfall to all pure components\n\t\tfor (var n in this.$) {\n\t\t\tif (!(this.$[n] instanceof UiComponent)) {\n\t\t\t\tthis.$[n].waterfall(nom, event, sender);\n\t\t\t}\n\t\t}\n\t\t// waterfall to my children\n\t\tfor (var i=0, cs=this.children, c; (c=cs[i]); i++) {\n\t\t\tc.waterfall(nom, event, sender);\n\t\t}\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tgetBubbleTarget: function (nom, event) {\n\t\tif (event.delegate) return this.owner;\n\t\telse {\n\t\t\treturn (\n\t\t\t\tthis.bubbleTarget\n\t\t\t\t|| (this.cachedBubble && this.cachedBubbleTarget[nom])\n\t\t\t\t|| this.parent\n\t\t\t\t|| this.owner\n\t\t\t);\n\t\t}\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tbubbleTargetChanged: function (was) {\n\t\tif (was && this.cachedBubble && this.cachedBubbleTarget) {\n\t\t\tfor (var n in this.cachedBubbleTarget) {\n\t\t\t\tif (this.cachedBubbleTarget[n] === was) delete this.cachedBubbleTarget[n];\n\t\t\t}\n\t\t}\n\t}\n});\n",
    "mtime": 1542469884563,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/UiComponent.js",
    "relPath": "enyo/UiComponent",
    "requires": [
      "enyo",
      "./kind",
      "./utils",
      "./master",
      "./Component"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "../AccessibilitySupport",
    "base": "/home/udo/git/NCPV/lib/enyo/src/Control",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/AccessibilitySupport",
    "name": "enyo/AccessibilitySupport",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/AccessibilitySupport",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/enyo/src/AccessibilitySupport/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/enyo/src/AccessibilitySupport/package.json": 1542469883991,
      "/home/udo/git/NCPV/lib/enyo/src/AccessibilitySupport/AccessibilitySupport.js": 1542469883987
    },
    "json": {
      "main": "AccessibilitySupport.js",
      "styles": [
        "AccessibilitySupport.css"
      ]
    },
    "main": "/home/udo/git/NCPV/lib/enyo/src/AccessibilitySupport/AccessibilitySupport.js",
    "contents": "/**\n* Mixin for adding WAI-ARIA attributes to controls\n*\n* @module enyo/AccessibilitySupport\n*/\n\nvar\n\tdispatcher = require('../dispatcher'),\n\tkind = require('../kind'),\n\tplatform = require('../platform'),\n\tutils = require('../utils');\n\nvar defaultObservers = [\n\t{from: 'accessibilityDisabled', method: function () {\n\t\tthis.setAriaAttribute('aria-hidden', this.accessibilityDisabled ? 'true' : null);\n\t}},\n\t{from: 'accessibilityLive', method: function () {\n\t\tvar live = this.accessibilityLive === true && 'assertive' || this.accessibilityLive || null;\n\t\tthis.setAriaAttribute('aria-live', live);\n\t}},\n\t{path: ['accessibilityAlert', 'accessibilityRole'], method: function () {\n\t\tvar role = this.accessibilityAlert && 'alert' || this.accessibilityRole || null;\n\t\tthis.setAriaAttribute('role', role);\n\t}},\n\t{path: ['content', 'accessibilityHint', 'accessibilityLabel', 'tabIndex'], method: function () {\n\t\tvar focusable = this.accessibilityLabel || this.content || this.accessibilityHint || false,\n\t\t\tprefix = this.accessibilityLabel || this.content || null,\n\t\t\tlabel = this.accessibilityHint && prefix && (prefix + ' ' + this.accessibilityHint) ||\n\t\t\t\t\tthis.accessibilityHint ||\n\t\t\t\t\tthis.accessibilityLabel ||\n\t\t\t\t\tnull;\n\n\t\tthis.setAriaAttribute('aria-label', label);\n\n\t\t// A truthy or zero tabindex will be set directly\n\t\tif (this.tabIndex || this.tabIndex === 0) {\n\t\t\tthis.setAriaAttribute('tabindex', this.tabIndex);\n\t\t}\n\t\t// The webOS browser will only read nodes with a non-null tabindex so if the node has\n\t\t// readable content, make it programmably focusable.\n\t\telse if (focusable && this.tabIndex === undefined && platform.webos) {\n\t\t\tthis.setAriaAttribute('tabindex', -1);\n\t\t}\n\t\t// Otherwise, remove it\n\t\telse {\n\t\t\tthis.setAriaAttribute('tabindex', null);\n\t\t}\n\t}}\n];\n\n/**\n* Prevents browser-initiated scrolling of contained controls into view when\n* those controls are explicitly focused.\n*\n* @private\n*/\nfunction preventScroll (node, rtl) {\n\tif (node) {\n\t\tdispatcher.listen(node, 'scroll', function () {\n\t\t\tnode.scrollTop = 0;\n\t\t\t// TODO: This probably won't work cross-browser, as the different\n\t\t\t// browser engines appear to treat scrollLeft differently in RTL.\n\t\t\t// See ENYO-2841.\n\t\t\tnode.scrollLeft = rtl ? node.scrollWidth : 0;\n\t\t});\n\t}\n}\n\nfunction updateAriaAttributes (all) {\n\tvar i, l, obs;\n\n\tfor (i = 0, l = this._ariaObservers.length; i < l; i++) {\n\t\tobs = this._ariaObservers[i];\n\t\tif ((all || obs.pending) && obs.method) {\n\t\t\tobs.method();\n\t\t\tobs.pending = false;\n\t\t}\n\t}\n}\n\nfunction registerAriaUpdate (obj) {\n\tvar fn;\n\tif (!obj.pending) {\n\t\tobj.pending = true;\n\t\tfn = this.bindSafely(updateAriaAttributes);\n\t\tif (!this.accessibilityDefer) {\n\t\t\tfn();\n\t\t} else {\n\t\t\tthis.startJob('updateAriaAttributes', fn, 16);\n\t\t}\n\t}\n}\n\nfunction toAriaAttribute (from, to) {\n\tvar value = this[from];\n\tthis.setAriaAttribute(to, value === undefined ? null : value);\n}\n\nfunction staticToAriaAttribute (to, value) {\n\tthis.setAriaAttribute(to, value);\n}\n\nfunction initAriaObservers (control) {\n\tvar conf = control._ariaObservers,\n\t\ti, l, fn;\n\n\tcontrol._ariaObservers = [];\n\tfor (i = 0, l = defaultObservers.length; i < l; i++) {\n\t\tinitAriaObserver(control, defaultObservers[i]);\n\t}\n\tif (conf) {\n\t\tfor (i = 0, l = conf.length; i < l; i++) {\n\t\t\tinitAriaObserver(control, conf[i]);\n\t\t}\n\t}\n\n\t// setup disabled observer and kickoff first run of observers\n\tfn = updateAriaAttributes.bind(control, true);\n\tcontrol.addObserver('accessibilityDisabled', fn);\n\tfn();\n}\n\nfunction initAriaObserver (control, c) {\n\tvar\n\t\t// path can either source from 'path' or 'from' (for binding-style configs)\n\t\tpath = c.path || c.from,\n\n\t\t// method is either:\n\t\t// \t\t'method', if it exists, or\n\t\t// \t\tstaticToAriaAttribute if 'to' and 'value' exist - static binding-style config, or\n\t\t// \t\ttoAriaAttribute if a 'to' path exists - binding-style config\n\t\tmethod = c.method && control.bindSafely(c.method) ||\n\t\t\t\t!path && c.to && c.value !== undefined && control.bindSafely(staticToAriaAttribute, c.to, c.value) ||\n\t\t\t\tc.to && control.bindSafely(toAriaAttribute, path, c.to) ||\n\t\t\t\tnull,\n\n\t\t// import the relevant and pre-validated parts into the instance-level config\n\t\tconfig = {\n\t\t\tpath: path,\n\t\t\tmethod: method,\n\t\t\tpending: false\n\t\t},\n\n\t\t// pre-bind the register method as it's used multiple times when 'path' is an array\n\t\tfn = registerAriaUpdate.bind(control, config),\n\n\t\t// iterator\n\t\tl;\n\n\tcontrol._ariaObservers.push(config);\n\tif (utils.isArray(path)) {\n\t\tfor (l = path.length - 1; l >= 0; --l) {\n\t\t\tcontrol.addObserver(path[l], fn);\n\t\t}\n\t}\n\telse if (path) {\n\t\tcontrol.addObserver(path, fn);\n\t}\n}\n\n/**\n* @mixin\n*/\nvar AccessibilitySupport = {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.AccessibilitySupport',\n\n\t/**\n\t* `accessibilityLabel` is used for accessibility voice readout. If\n\t* `accessibilityLabel` is set, the screen reader will read the label when the\n\t* control is focused.\n\t*\n\t* @type {String}\n\t* @default ''\n\t* @public\n\t*/\n\taccessibilityLabel: '',\n\n\t/**\n\t* `accessibilityHint` is used to provide additional information regarding the\n\t* control. If `accessibilityHint` is set, the screen reader will read the\n\t* hint content when the control is focused.\n\t*\n\t* @type {String}\n\t* @default ''\n\t* @public\n\t*/\n\taccessibilityHint: '',\n\n\t/**\n\t* The `role` of the control. May be superseded by a truthy `accessibilityAlert` value.\n\t*\n\t* @type {String}\n\t* @default ''\n\t* @public\n\t*/\n\taccessibilityRole: '',\n\n\t/**\n\t* `accessibilityAlert` affects the handling of alert message or page\n\t* description content. If `true`, aria role will be set to \"alert\" and the\n\t* screen reader will automatically read the content of `accessibilityLabel`,\n\t* regardless of focus state; if `false` (the default), the label will be read\n\t* when the control receives focus. Note that if you use `accessibilityAlert`,\n\t* the previous role will be replaced with \"alert\" role.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\taccessibilityAlert: false,\n\n\t/**\n\t* `accessibilityLive` affects the handling of dynamic content that updates\n\t* without a page reload. If `true`, the screen reader will read the content of\n\t* `accessibilityLabel` when the content changes; if `false` (the default), the\n\t* label will be read when the control gains focus.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\taccessibilityLive: false,\n\n\t/**\n\t* `accessibilityDisabled` is used to prevent voice readout. If `true`, the\n\t* screen reader will not read the label for the control. Note that this is not\n\t* working on HTML form elements which can get focus without tabindex.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\taccessibilityDisabled: false,\n\n\t/**\n\t* When `true`, `onscroll` events will be observed and scrolling will be\n\t* prevented by resetting the node's `scrollTop` and `scrollLeft` values. This\n\t* prevents inadvertent layout issues introduced by the browser's scrolling\n\t* contained controls into view when focused.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\taccessibilityPreventScroll: false,\n\n\t/**\n\t* The `tabindex` of the control. When `undefined` on webOS, it will be set to\n\t* `-1` to enable screen reading. A value of `null` (or `undefined` on\n\t* non-webOS) ensures that no `tabindex` will be set.\n\t*\n\t* @type {Number}\n\t* @default undefined\n\t* @public\n\t*/\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function (props) {\n\t\t\tsup.apply(this, arguments);\n\t\t\tinitAriaObservers(this);\n\t\t};\n\t}),\n\n\t/**\n\t* If `accessibilityDisabled` is `false`, sets the specified node attribute;\n\t* otherwise, removes it.\n\t*\n\t* @param {String} name  Attribute name\n\t* @param {String} value Attribute value\n\t* @public\n\t*/\n\tsetAriaAttribute: function (name, value) {\n\t\t// if the control is disabled, don't set any aria properties except aria-hidden\n\t\tif (this.accessibilityDisabled && name != 'aria-hidden') {\n\t\t\tvalue = null;\n\t\t}\n\t\t// if the value is defined and non-null, cast it to a String\n\t\telse if (value !== undefined && value !== null) {\n\t\t\tvalue = String(value);\n\t\t}\n\t\t// prevent invalidating attributes unnecessarily by checking current value first. avoids\n\t\t// resetting values on alert-able properties (e.g. aria-valuenow).\n\t\tif (this.getAttribute(name) !== value) {\n\t\t\tthis.setAttribute(name, value);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\trendered: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tif (this.accessibilityPreventScroll) {\n\t\t\t\tpreventScroll(this.hasNode(), this.rtl);\n\t\t\t}\n\t\t};\n\t})\n};\n\nvar sup = kind.concatHandler;\nkind.concatHandler = function (ctor, props, instance) {\n\tsup.call(this, ctor, props, instance);\n\n\tvar proto = ctor.prototype || ctor,\n\t\tariaObservers = proto._ariaObservers && proto._ariaObservers.slice(),\n\t\tincoming = props.ariaObservers;\n\n\tif (incoming && incoming instanceof Array) {\n\t\tif (ariaObservers) {\n\t\t\tariaObservers.push.apply(ariaObservers, incoming);\n\t\t} else {\n\t\t\tariaObservers = incoming.slice();\n\t\t}\n\t}\n\n\tproto._ariaObservers = ariaObservers;\n};\n\nmodule.exports = AccessibilitySupport;",
    "nodeModules": false,
    "relPath": "enyo/AccessibilitySupport",
    "requires": [
      "../dispatcher",
      "../kind",
      "../platform",
      "../utils"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/lib/enyo/src/AccessibilitySupport/AccessibilitySupport.css"
    ]
  },
  {
    "path": "./fullscreen",
    "base": "/home/udo/git/NCPV/lib/enyo/src/Control",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/Control/fullscreen",
    "name": "enyo/Control/fullscreen",
    "isFile": true,
    "contents": "var\n\tdispatcher = require('../dispatcher'),\n\tutils = require('../utils'),\n\tready = require('../ready'),\n\tSignals = require('../Signals');\n\n/**\n* Normalizes and provides fullscreen support for [controls]{@link module:enyo/Control~Control},\n* based on the [fullscreen]{@glossary fullscreen} API.\n*\n* @module enyo/Control/fullscreen\n* @public\n*/\nmodule.exports = function (Control) {\n\tvar floatingLayer = Control.floatingLayer;\n\tvar fullscreen = {\n\t\t\n\t\t/**\n\t\t* Reference to the current fullscreen [control]{@link module:enyo/Control~Control}.\n\t\t*\n\t\t* @private\n\t\t*/\n\t\tfullscreenControl: null,\n\n\t\t/**\n\t\t* Reference to the current fullscreen element (fallback for platforms\n\t\t* without native support).\n\t\t*\n\t\t* @private\n\t\t*/\n\t\tfullscreenElement: null,\n\n\t\t/** \n\t\t* Reference to that [control]{@link module:enyo/Control~Control} that requested fullscreen.\n\t\t* \n\t\t* @private\n\t\t*/\n\t\trequestor: null,\n\n\t\t/** \n\t\t* Native accessor used to get reference to the current fullscreen element.\n\t\t*\n\t\t* @private\n\t\t*/\n\t\telementAccessor:\n\t\t\t('fullscreenElement' in document) ? 'fullscreenElement' :\n\t\t\t('mozFullScreenElement' in document) ? 'mozFullScreenElement' :\n\t\t\t('webkitFullscreenElement' in document) ? 'webkitFullscreenElement' :\n\t\t\tnull,\n\n\t\t/** \n\t\t* Native accessor used to request fullscreen.\n\t\t*\n\t\t* @private\n\t\t*/\n\t\trequestAccessor:\n\t\t\t('requestFullscreen' in document.documentElement) ? 'requestFullscreen' :\n\t\t\t('mozRequestFullScreen' in document.documentElement) ? 'mozRequestFullScreen' :\n\t\t\t('webkitRequestFullscreen' in document.documentElement) ? 'webkitRequestFullscreen' :\n\t\t\tnull,\n\n\t\t/** \n\t\t* Native accessor used to cancel fullscreen.\n\t\t*\n\t\t* @private\n\t\t*/\n\t\tcancelAccessor:\n\t\t\t('cancelFullScreen' in document) ? 'cancelFullScreen' :\n\t\t\t('mozCancelFullScreen' in document) ? 'mozCancelFullScreen' :\n\t\t\t('webkitCancelFullScreen' in document) ? 'webkitCancelFullScreen' :\n\t\t\tnull,\n\n\t\t/**\n\t\t* Determines whether the platform supports the [fullscreen]{@glossary fullscreen} API.\n\t\t* \n\t\t* @returns {Boolean} Returns `true` if platform supports all of the \n\t\t*\t[fullscreen]{@glossary fullscreen} API, `false` otherwise.\n\t\t* @public\n\t\t*/\n\t\tnativeSupport: function() {\n\t\t\treturn (this.elementAccessor !== null && this.requestAccessor !== null && this.cancelAccessor !== null);\n\t\t},\n\n\t\t/** \n\t\t* Normalizes `getFullscreenElement()`.\n\t\t*\n\t\t* @public\n\t\t*/\n\t\tgetFullscreenElement: function() {\n\t\t\treturn (this.nativeSupport()) ? document[this.elementAccessor] : this.fullscreenElement;\n\t\t},\n\n\t\t/** \n\t\t* Returns current fullscreen [control]{@link module:enyo/Control~Control}.\n\t\t*\n\t\t* @public\n\t\t*/\n\t\tgetFullscreenControl: function() {\n\t\t\treturn this.fullscreenControl;\n\t\t},\n\n\t\t/**\n\t\t* Normalizes `requestFullscreen()`.\n\t\t*\n\t\t* @public\n\t\t*/\n\t\trequestFullscreen: function(ctl) {\n\t\t\tif (this.getFullscreenControl() || !(ctl.hasNode())) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.requestor = ctl;\n\n\t\t\t// Only use native request if platform supports all of the API\n\t\t\tif (this.nativeSupport()) {\n\t\t\t\tctl.hasNode()[this.requestAccessor]();\n\t\t\t} else {\n\t\t\t\tthis.fallbackRequestFullscreen();\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\t/** \n\t\t* Normalizes `cancelFullscreen()`.\n\t\t*\n\t\t* @public\n\t\t*/\n\t\tcancelFullscreen: function() {\n\t\t\tif (this.nativeSupport()) {\n\t\t\t\tdocument[this.cancelAccessor]();\n\t\t\t} else {\n\t\t\t\tthis.fallbackCancelFullscreen();\n\t\t\t}\n\t\t},\n\n\t\t/** \n\t\t* Fallback support for setting fullscreen element (done by browser on platforms with\n\t\t* native support).\n\t\t*\n\t\t* @private\n\t\t*/\n\t\tsetFullscreenElement: function(node) {\n\t\t\tthis.fullscreenElement = node;\n\t\t},\n\n\t\t/** \n\t\t* Sets current fullscreen [control]{@link module:enyo/Control~Control}.\n\t\t*\n\t\t* @private\n\t\t*/\n\t\tsetFullscreenControl: function(ctl) {\n\t\t\tthis.fullscreenControl = ctl;\n\t\t},\n\n\t\t/** \n\t\t* Fallback fullscreen request for platforms without fullscreen support.\n\t\t*\n\t\t* @private\n\t\t*/\n\t\tfallbackRequestFullscreen: function() {\n\t\t\tvar control = this.requestor;\n\n\t\t\tif (!control) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get before node to allow us to exit floating layer to the proper position\n\t\t\tcontrol.prevAddBefore = control.parent.controlAtIndex(control.indexInContainer() + 1);\n\n\t\t\t// Render floating layer if we need to\n\t\t\tif (!floatingLayer.hasNode()) {\n\t\t\t\tfloatingLayer.render();\n\t\t\t}\n\n\t\t\tcontrol.addClass('enyo-fullscreen');\n\t\t\tcontrol.appendNodeToParent(floatingLayer.hasNode());\n\t\t\tcontrol.resize();\n\n\t\t\tthis.setFullscreenControl(control);\n\t\t\tthis.setFullscreenElement(control.hasNode());\n\t\t},\n\n\t\t/** \n\t\t* Fallback cancel fullscreen for platforms without fullscreen support.\n\t\t*\n\t\t* @private\n\t\t*/\n\t\tfallbackCancelFullscreen: function() {\n\t\t\tvar control = this.fullscreenControl,\n\t\t\t\tbeforeNode,\n\t\t\t\tparentNode\n\t\t\t;\n\n\t\t\tif (!control) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Find beforeNode based on _this.addBefore_ and _this.prevAddBefore_\n\t\t\tbeforeNode = (control.prevAddBefore) ? control.prevAddBefore.hasNode() : null;\n\t\t\tparentNode = control.parent.hasNode();\n\t\t\tcontrol.prevAddBefore = null;\n\n\t\t\tcontrol.removeClass('enyo-fullscreen');\n\n\t\t\tif (!beforeNode) {\n\t\t\t\tcontrol.appendNodeToParent(parentNode);\n\t\t\t} else {\n\t\t\t\tcontrol.insertNodeInParent(parentNode, beforeNode);\n\t\t\t}\n\n\t\t\tcontrol.resize();\n\n\t\t\tthis.setFullscreenControl(null);\n\t\t\tthis.setFullscreenElement(null);\n\t\t},\n\n\t\t/** \n\t\t* Listens for fullscreen change {@glossary event} and broadcasts it as a\n\t\t* normalized event.\n\t\t*\n\t\t* @private\n\t\t*/\n\t\tdetectFullscreenChangeEvent: function() {\n\t\t\tthis.setFullscreenControl(this.requestor);\n\t\t\tthis.requestor = null;\n\n\t\t\t// Broadcast change\n\t\t\tSignals.send('onFullscreenChange');\n\t\t}\n\t};\n\n\t/**\n\t* Normalizes platform-specific fullscreen change [events]{@glossary event}.\n\t*\n\t* @private\n\t*/\n\tready(function() {\n\t\tdocument.addEventListener('webkitfullscreenchange', utils.bind(fullscreen, 'detectFullscreenChangeEvent'), false);\n\t\tdocument.addEventListener('mozfullscreenchange',    utils.bind(fullscreen, 'detectFullscreenChangeEvent'), false);\n\t\tdocument.addEventListener('fullscreenchange',       utils.bind(fullscreen, 'detectFullscreenChangeEvent'), false);\n\t});\n\n\t/**\n\t* If this platform doesn't have native support for fullscreen, add an escape handler to mimic \n\t* native behavior.\n\t*/\n\tif(!fullscreen.nativeSupport()) {\n\t\tdispatcher.features.push(\n\t\t\tfunction(e) {\n\t\t\t\tif (e.type === 'keydown' && e.keyCode === 27) {\n\t\t\t\t\tfullscreen.cancelFullscreen();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\treturn fullscreen;\n};",
    "mtime": 1542469884103,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/Control/fullscreen.js",
    "relPath": "enyo/Control/fullscreen",
    "requires": [
      "../dispatcher",
      "../utils",
      "../ready",
      "../Signals"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./drag",
    "base": "/home/udo/git/NCPV/lib/enyo/src/gesture",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/gesture/drag",
    "name": "enyo/gesture/drag",
    "isFile": true,
    "contents": "var\n\tdispatcher = require('../dispatcher'),\n\tutils = require('../utils');\n\nvar\n\tgestureUtil = require('./util');\n\n/**\n* Enyo supports a cross-platform set of drag [events]{@glossary event}. These\n* events allow users to write a single set of event handlers for applications\n* that run on both mobile and desktop platforms.\n*\n* The following events are provided:\n*\n* * 'dragstart'\n* * 'dragfinish'\n* * 'drag'\n* * 'drop'\n* * 'dragover'\n* * 'dragout'\n* * 'hold'\n* * 'release'\n* * 'holdpulse'\n* * 'flick'\n*\n* For more information on these events, see the documentation on\n* [Event Handling]{@linkplain $dev-guide/key-concepts/event-handling.html} in\n* the Enyo Developer Guide.\n*\n* Used internally by {@link module:enyo/gesture}\n*\n* @module enyo/gesture/drag\n* @public\n*/\nmodule.exports = {\n\n\t/**\n\t* @private\n\t*/\n\tholdPulseDefaultConfig: {\n\t\tfrequency: 200,\n\t\tevents: [{name: 'hold', time: 200}],\n\t\tresume: false,\n\t\tpreventTap: false,\n\t\tmoveTolerance: 16,\n\t\tendHold: 'onMove'\n\t},\n\n\t/**\n\t* Call this method to specify the framework's 'holdPulse' behavior, which\n\t* determines the nature of the events generated when a user presses and holds\n\t* on a user interface element.\n\t*\n\t* By default, an `onhold` event fires after 200 ms. After that, an `onholdpulse`\n\t* event fires every 200 ms until the user stops holding, at which point a\n\t* `onrelease` event fires.\n\t*\n\t* To change the default behavior, call this method and pass it a holdPulse\n\t* configuration object. The holdPulse configuration object has a number of\n\t* properties.\n\t*\n\t* You can specify a set of custom hold events by setting the `events` property\n\t* to an array containing one or more objects. Each object specifies a custom\n\t* hold event, in the form of a `name` / `time` pair. Notes:\n\t*\n\t*  * Your custom event names should not include the 'on' prefix; that will be\n\t*    added automatically by the framework.\n\t*\n\t*  * Times should be specified in milliseconds.\n\t*\n\t*  * Your `events` array overrides the framework defaults entirely, so if you\n\t*    want the standard `hold` event to fire at 200 ms (in addition to whatever\n\t*    custom events you define), you'll need to redefine it yourself as part of\n\t*    your `events` array.\n\t*\n\t* Regardless of how many custom hold events you define, `onholdpulse` events\n\t* will start firing after the first custom hold event fires, and continue until\n\t* the user stops holding. Likewise, only one `onrelease` event will fire,\n\t* regardless of how many custom hold events you define.\n\t*\n\t* The`frequency` parameter determines not only how often `holdpulse` events are\n\t* sent, but the frequency with which the hold duration is measured. This means\n\t* that the value you set for `frequency` should always be a common factor of the\n\t* times you set for your custom hold events, to ensure accurate event timing.\n\t*\n\t* You can use the `endHold` property to specify the circumstances under which a\n\t* hold is considered to end. Set `endHold` to `onMove` (the default) if you want\n\t* the hold to end as soon as the user's finger or pointer moves. Set `endHold`\n\t* to `onLeave` if you want the hold to end only when the finger or pointer\n\t* leaves the element altogether. When specifying `onMove`, you can also provide\n\t* a `moveTolerance` value (default: `16`) that determines how tolerant you want\n\t* to be of small movements when deciding whether a hold has ended. The higher\n\t* the value, the further a user's finger or pointer may move without causing\n\t* the hold to end.\n\t*\n\t* The `resume` parameter (default: `false`) specifies whether a hold\n\t* that has ended due to finger / pointer movement should be resumed if the\n\t* user's finger or pointer moves back inside the tolerance threshold (in the\n\t* case of `endHold: onMove`) or back over the element (in the case of\n\t* `endHold: onLeave`).\n\t*\n\t* Finally, the `preventTap` paramenter (default: `false`) allows you to prevent\n\t* an `ontap` event from firing when the hold is released.\n\t*\n\t* Here is an example:\n\t*\n\t* ```\n\t* gesture.drag.configureHoldPulse({\n\t*     frequency: 100,\n\t*     events: [\n\t*         {name: 'hold', time: 200},\n\t*         {name: 'longpress', time: 500}\n\t*     ],\n\t*     endHold: 'onLeave',\n\t*     resume: true,\n\t*     preventTap: true\n\t* });\n\t* ```\n\t* For comparison, here are the out-of-the-box defaults:\n\t*\n\t* ```\n\t* gesture.drag.configureHoldPulse({\n\t*     frequency: 200,\n\t*     events: [\n\t*         {name: 'hold', time: 200}\n\t*     ],\n\t*     endHold: 'onMove',\n\t*     moveTolerance: 16,\n\t*     resume: false,\n\t*     preventTap: false\n\t* });\n\t* ```\n\t*\n\t* The settings you provide via this method will be applied globally, affecting\n\t* every Control. Note that you can also override the defaults on a case-by-case\n\t* basis by handling the `down` event for any Control and calling the\n\t* `configureHoldPulse` method exposed by the event itself. That method works\n\t* exactly like this one, except that the settings you provide will apply only to\n\t* holds on that particular Control.\n\t*\n\t* @public\n\t*/\n\tconfigureHoldPulse: function (config) {\n\t\t// TODO: Might be nice to do some validation, error handling\n\n\t\t// _holdPulseConfig represents the current, global `holdpulse` settings, if the default\n\t\t// settings have been overridden in some way.\n\t\tthis._holdPulseConfig = this._holdPulseConfig || utils.clone(this.holdPulseDefaultConfig, true);\n\t\tutils.mixin(this._holdPulseConfig, config);\n\t},\n\n\t/**\n\t* Resets the `holdPulse` behavior to the default settings.\n\t*\n\t* @public\n\t*/\n\tresetHoldPulseConfig: function () {\n\t\tthis._holdPulseConfig = null;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tholdPulseConfig: {},\n\n\t/**\n\t* @private\n\t*/\n\ttrackCount: 5,\n\n\t/**\n\t* @private\n\t*/\n\tminFlick: 0.1,\n\n\t/**\n\t* @private\n\t*/\n\tminTrack: 8,\n\n\t/**\n\t* @private\n\t*/\n\tdown: function(e) {\n\t\t// tracking if the mouse is down\n\t\t//enyo.log('tracking ON');\n\t\t// Note: 'tracking' flag indicates interest in mousemove, it's turned off\n\t\t// on mouseup\n\t\t// make sure to stop dragging in case the up event was not received.\n\t\tthis.stopDragging(e);\n\t\tthis.target = e.target;\n\t\tthis.startTracking(e);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmove: function(e) {\n\t\tif (this.tracking) {\n\t\t\tthis.track(e);\n\t\t\t// If the mouse is not down and we're tracking a drag, abort.\n\t\t\t// this error condition can occur on IE/Webkit after interaction with a scrollbar.\n\t\t\tif (!e.which) {\n\t\t\t\tthis.stopDragging(e);\n\t\t\t\tthis.endHold();\n\t\t\t\tthis.tracking = false;\n\t\t\t\t//enyo.log('gesture.drag: mouse must be down to drag.');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.dragEvent) {\n\t\t\t\tthis.sendDrag(e);\n\t\t\t} else if (this.holdPulseConfig.endHold === 'onMove') {\n\t\t\t\tif (this.dy*this.dy + this.dx*this.dx >= this.holdPulseConfig.moveTolerance) { // outside of target\n\t\t\t\t\tif (this.holdJob) { // only stop/cancel hold job if it currently exists\n\t\t\t\t\t\tif (this.holdPulseConfig.resume) { // pause hold to potentially resume later\n\t\t\t\t\t\t\tthis.suspendHold();\n\t\t\t\t\t\t} else { // completely cancel hold\n\t\t\t\t\t\t\tthis.endHold();\n\t\t\t\t\t\t\tthis.sendDragStart(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (this.holdPulseConfig.resume && !this.holdJob) { // when moving inside target, only resume hold job if it was previously paused\n\t\t\t\t\tthis.resumeHold();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tup: function(e) {\n\t\tthis.endTracking(e);\n\t\tthis.stopDragging(e);\n\t\tthis.endHold();\n\t\tthis.target = null;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tenter: function(e) {\n\t\t// resume hold when re-entering original target when using 'onLeave' endHold value\n\t\tif (this.holdPulseConfig.resume && this.holdPulseConfig.endHold === 'onLeave' && this.target && e.target === this.target) {\n\t\t\tthis.resumeHold();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tleave: function(e) {\n\t\tif (this.dragEvent) {\n\t\t\tthis.sendDragOut(e);\n\t\t} else if (this.holdPulseConfig.endHold === 'onLeave') {\n\t\t\tif (this.holdPulseConfig.resume) { // pause hold to potentially resume later\n\t\t\t\tthis.suspendHold();\n\t\t\t} else { // completely cancel hold\n\t\t\t\tthis.endHold();\n\t\t\t\tthis.sendDragStart(e);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstopDragging: function(e) {\n\t\tif (this.dragEvent) {\n\t\t\tthis.sendDrop(e);\n\t\t\tvar handled = this.sendDragFinish(e);\n\t\t\tthis.dragEvent = null;\n\t\t\treturn handled;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmakeDragEvent: function(inType, inTarget, inEvent, inInfo) {\n\t\tvar adx = Math.abs(this.dx), ady = Math.abs(this.dy);\n\t\tvar h = adx > ady;\n\t\t// suggest locking if off-axis < 22.5 degrees\n\t\tvar l = (h ? ady/adx : adx/ady) < 0.414;\n\t\tvar e = {};\n\t\t// var e = {\n\t\te.type = inType;\n\t\te.dx = this.dx;\n\t\te.dy = this.dy;\n\t\te.ddx = this.dx - this.lastDx;\n\t\te.ddy = this.dy - this.lastDy;\n\t\te.xDirection = this.xDirection;\n\t\te.yDirection = this.yDirection;\n\t\te.pageX = inEvent.pageX;\n\t\te.pageY = inEvent.pageY;\n\t\te.clientX = inEvent.clientX;\n\t\te.clientY = inEvent.clientY;\n\t\te.horizontal = h;\n\t\te.vertical = !h;\n\t\te.lockable = l;\n\t\te.target = inTarget;\n\t\te.dragInfo = inInfo;\n\t\te.ctrlKey = inEvent.ctrlKey;\n\t\te.altKey = inEvent.altKey;\n\t\te.metaKey = inEvent.metaKey;\n\t\te.shiftKey = inEvent.shiftKey;\n\t\te.srcEvent = inEvent.srcEvent;\n\t\t// };\n\t\te.preventDefault = gestureUtil.preventDefault;\n\t\te.disablePrevention = gestureUtil.disablePrevention;\n\t\treturn e;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsendDragStart: function(e) {\n\t\t//enyo.log('dragstart');\n\t\tthis.dragEvent = this.makeDragEvent('dragstart', this.target, e);\n\t\tdispatcher.dispatch(this.dragEvent);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsendDrag: function(e) {\n\t\t//enyo.log('sendDrag to ' + this.dragEvent.target.id + ', over to ' + e.target.id);\n\t\t// send dragOver event to the standard event target\n\t\tvar synth = this.makeDragEvent('dragover', e.target, e, this.dragEvent.dragInfo);\n\t\tdispatcher.dispatch(synth);\n\t\t// send drag event to the drag source\n\t\tsynth.type = 'drag';\n\t\tsynth.target = this.dragEvent.target;\n\t\tdispatcher.dispatch(synth);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsendDragFinish: function(e) {\n\t\t//enyo.log('dragfinish');\n\t\tvar synth = this.makeDragEvent('dragfinish', this.dragEvent.target, e, this.dragEvent.dragInfo);\n\t\tsynth.preventTap = function() {\n\t\t\tif (e.preventTap) {\n\t\t\t\te.preventTap();\n\t\t\t}\n\t\t};\n\t\tdispatcher.dispatch(synth);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsendDragOut: function(e) {\n\t\tvar synth = this.makeDragEvent('dragout', e.target, e, this.dragEvent.dragInfo);\n\t\tdispatcher.dispatch(synth);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsendDrop: function(e) {\n\t\tvar synth = this.makeDragEvent('drop', e.target, e, this.dragEvent.dragInfo);\n\t\tsynth.preventTap = function() {\n\t\t\tif (e.preventTap) {\n\t\t\t\te.preventTap();\n\t\t\t}\n\t\t};\n\t\tdispatcher.dispatch(synth);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstartTracking: function(e) {\n\t\tthis.tracking = true;\n\t\t// note: use clientX/Y to be compatible with ie8\n\t\tthis.px0 = e.clientX;\n\t\tthis.py0 = e.clientY;\n\t\t// this.flickInfo = {startEvent: e, moves: []};\n\t\tthis.flickInfo = {};\n\t\tthis.flickInfo.startEvent = e;\n\t\t// FIXME: so we're trying to reuse objects where possible, should\n\t\t// do the same in scenarios like this for arrays\n\t\tthis.flickInfo.moves = [];\n\t\tthis.track(e);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\ttrack: function(e) {\n\t\tthis.lastDx = this.dx;\n\t\tthis.lastDy = this.dy;\n\t\tthis.dx = e.clientX - this.px0;\n\t\tthis.dy = e.clientY - this.py0;\n\t\tthis.xDirection = this.calcDirection(this.dx - this.lastDx, 0);\n\t\tthis.yDirection = this.calcDirection(this.dy - this.lastDy, 0);\n\t\t//\n\t\tvar ti = this.flickInfo;\n\t\tti.moves.push({\n\t\t\tx: e.clientX,\n\t\t\ty: e.clientY,\n\t\t\tt: utils.perfNow()\n\t\t});\n\t\t// track specified # of points\n\t\tif (ti.moves.length > this.trackCount) {\n\t\t\tti.moves.shift();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tendTracking: function() {\n\t\tthis.tracking = false;\n\t\tvar ti = this.flickInfo;\n\t\tvar moves = ti && ti.moves;\n\t\tif (moves && moves.length > 1) {\n\t\t\t// note: important to use up time to reduce flick\n\t\t\t// velocity based on time between move and up.\n\t\t\tvar l = moves[moves.length-1];\n\t\t\tvar n = utils.perfNow();\n\t\t\t// take the greatest of flick between each tracked move and last move\n\t\t\tfor (var i=moves.length-2, dt=0, x1=0, y1=0, x=0, y=0, sx=0, sy=0, m; (m=moves[i]); i--) {\n\t\t\t\t// this flick (this move - last move) / (this time - last time)\n\t\t\t\tdt = n - m.t;\n\t\t\t\tx1 = (l.x - m.x) / dt;\n\t\t\t\ty1 = (l.y - m.y) / dt;\n\t\t\t\t// establish flick direction\n\t\t\t\tsx = sx || (x1 < 0 ? -1 : (x1 > 0 ? 1 : 0));\n\t\t\t\tsy = sy || (y1 < 0 ? -1 : (y1 > 0 ? 1 : 0));\n\t\t\t\t// if either axis is a greater flick than previously recorded use this one\n\t\t\t\tif ((x1 * sx > x * sx) || (y1 * sy > y * sy)) {\n\t\t\t\t\tx = x1;\n\t\t\t\t\ty = y1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar v = Math.sqrt(x*x + y*y);\n\t\t\tif (v > this.minFlick) {\n\t\t\t\t// generate the flick using the start event so it has those coordinates\n\t\t\t\tthis.sendFlick(ti.startEvent, x, y, v);\n\t\t\t}\n\t\t}\n\t\tthis.flickInfo = null;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcalcDirection: function(inNum, inDefault) {\n\t\treturn inNum > 0 ? 1 : (inNum < 0 ? -1 : inDefault);\n\t},\n\n\t/**\n\t* Translate the old format for holdPulseConfig to the new one, to\n\t* preserve backward compatibility.\n\t*\n\t* @private\n\t*/\n\tnormalizeHoldPulseConfig: function (oldOpts) {\n\t\tvar nOpts = utils.clone(oldOpts);\n\t\tnOpts.frequency = nOpts.delay;\n\t\tnOpts.events = [{name: 'hold', time: nOpts.delay}];\n\t\treturn nOpts;\n\t},\n\n\t/**\n\t* Method to override holdPulseConfig for a given gesture. This method isn't\n\t* accessed directly from gesture.drag, but exposed by the `down` event.\n\t* See `prepareHold()`.\n\t*\n\t* @private\n\t*/\n\t_configureHoldPulse: function(opts) {\n\t\tvar nOpts = (opts.delay === undefined) ?\n\t\t\topts :\n\t\t\tthis.normalizeHoldPulseConfig(opts);\n\t\tutils.mixin(this.holdPulseConfig, nOpts);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tprepareHold: function(e) {\n\t\t// quick copy as the prototype of the new overridable config\n\t\tthis.holdPulseConfig = utils.clone(this._holdPulseConfig || this.holdPulseDefaultConfig, true);\n\n\t\t// expose method for configuring holdpulse options\n\t\te.configureHoldPulse = this._configureHoldPulse.bind(this);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tbeginHold: function(e) {\n\t\tvar ce;\n\t\t// cancel any existing hold since it's possible in corner cases to get a down without an up\n\t\tthis.endHold();\n\t\tthis.holdStart = utils.perfNow();\n\t\tthis._holdJobFunction = utils.bind(this, 'handleHoldPulse');\n\t\t// clone the event to ensure it stays alive on IE upon returning to event loop\n\t\tce = this._holdJobEvent = utils.clone(e);\n\t\tce.srcEvent = utils.clone(e.srcEvent);\n\t\tce.downEvent = e;\n\t\tthis._pulsing = false;\n\t\tthis._unsent = utils.clone(this.holdPulseConfig.events);\n\t\tthis._unsent.sort(this.sortEvents);\n\t\tthis._next = this._unsent.shift();\n\t\tif (this._next) {\n\t\t\tthis.holdJob = setInterval(this._holdJobFunction, this.holdPulseConfig.frequency);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tresumeHold: function() {\n\t\tthis.handleHoldPulse();\n\t\tthis.holdJob = setInterval(this._holdJobFunction, this.holdPulseConfig.frequency);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsortEvents: function(a, b) {\n\t\t\tif (a.time < b.time) return -1;\n\t\t\tif (a.time > b.time) return 1;\n\t\t\treturn 0;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tendHold: function() {\n\t\tvar e = this._holdJobEvent;\n\t\tthis.suspendHold();\n\t\tif (e && this._pulsing) {\n\t\t\tthis.sendRelease(e);\n\t\t}\n\t\tthis._pulsing = false;\n\t\tthis._unsent = null;\n\t\tthis._holdJobFunction = null;\n\t\tthis._holdJobEvent = null;\n\t\tthis._next = null;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsuspendHold: function() {\n\t\tclearInterval(this.holdJob);\n\t\tthis.holdJob = null;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\thandleHoldPulse: function() {\n\t\tvar holdTime = utils.perfNow() - this.holdStart,\n\t\t\thje = this._holdJobEvent,\n\t\t\te;\n\t\tthis.maybeSendHold(hje, holdTime);\n\t\tif (this._pulsing) {\n\t\t\te = gestureUtil.makeEvent('holdpulse', hje);\n\t\t\te.holdTime = holdTime;\n\t\t\tdispatcher.dispatch(e);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmaybeSendHold: function(inEvent, inHoldTime) {\n\t\tvar n = this._next;\n\t\twhile (n && n.time <= inHoldTime) {\n\t\t\tvar e = gestureUtil.makeEvent(n.name, inEvent);\n\t\t\tif (!this._pulsing && this.holdPulseConfig.preventTap) {\n\t\t\t\tinEvent.downEvent.preventTap();\n\t\t\t}\n\t\t\tthis._pulsing = true;\n\t\t\tdispatcher.dispatch(e);\n\t\t\tn = this._next = this._unsent && this._unsent.shift();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsendRelease: function(inEvent) {\n\t\tvar e = gestureUtil.makeEvent('release', inEvent);\n\t\tdispatcher.dispatch(e);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsendFlick: function(inEvent, inX, inY, inV) {\n\t\tvar e = gestureUtil.makeEvent('flick', inEvent);\n\t\te.xVelocity = inX;\n\t\te.yVelocity = inY;\n\t\te.velocity = inV;\n\t\tdispatcher.dispatch(e);\n\t}\n};\n",
    "mtime": 1542469884639,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/gesture/drag.js",
    "relPath": "enyo/gesture/drag",
    "requires": [
      "../dispatcher",
      "../utils",
      "./util"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./touchGestures",
    "base": "/home/udo/git/NCPV/lib/enyo/src/gesture",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/gesture/touchGestures",
    "name": "enyo/gesture/touchGestures",
    "isFile": true,
    "contents": "var\n\tdispatcher = require('../dispatcher'),\n\tutils = require('../utils');\n\n/**\n* The extended {@glossary event} [object]{@glossary Object} that is provided when we\n* emulate iOS multitouch gesture events on non-iOS devices.\n*\n* @typedef {Object} module:enyo/gesture/touchGestures~EmulatedGestureEvent\n* @property {Number} pageX - The x-coordinate of the center point between fingers.\n* @property {Number} pageY - The y-coordinate of the center point between fingers.\n* @property {Number} rotation - The degrees of rotation from the beginning of the gesture.\n* @property {Number} scale - The percent change of distance between fingers.\n*/\n\n/**\n* @module enyo/gesture/touchGestures\n* @private\n*/\nmodule.exports = {\n\n\t/**\n\t* @private\n\t*/\n\torderedTouches: [],\n\n\t/**\n\t* @private\n\t*/\n\tgesture: null,\n\n\t/**\n\t* @private\n\t*/\n\ttouchstart: function (e) {\n\t\t// some devices can send multiple changed touches on start and end\n\t\tvar i,\n\t\t\tchangedTouches = e.changedTouches,\n\t\t\tlength = changedTouches.length;\n\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tvar id = changedTouches[i].identifier;\n\n\t\t\t// some devices can send multiple touchstarts\n\t\t\tif (utils.indexOf(id, this.orderedTouches) < 0) {\n\t\t\t\tthis.orderedTouches.push(id);\n\t\t\t}\n\t\t}\n\n\t\tif (e.touches.length >= 2 && !this.gesture) {\n\t\t\tvar p = this.gesturePositions(e);\n\n\t\t\tthis.gesture = this.gestureVector(p);\n\t\t\tthis.gesture.angle = this.gestureAngle(p);\n\t\t\tthis.gesture.scale = 1;\n\t\t\tthis.gesture.rotation = 0;\n\t\t\tvar g = this.makeGesture('gesturestart', e, {vector: this.gesture, scale: 1, rotation: 0});\n\t\t\tdispatcher.dispatch(g);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\ttouchend: function (e) {\n\t\t// some devices can send multiple changed touches on start and end\n\t\tvar i,\n\t\t\tchangedTouches = e.changedTouches,\n\t\t\tlength = changedTouches.length;\n\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tutils.remove(changedTouches[i].identifier, this.orderedTouches);\n\t\t}\n\n\t\tif (e.touches.length <= 1 && this.gesture) {\n\t\t\tvar t = e.touches[0] || e.changedTouches[e.changedTouches.length - 1];\n\n\t\t\t// gesture end sends last rotation and scale, with the x/y of the last finger\n\t\t\tdispatcher.dispatch(this.makeGesture('gestureend', e, {vector: {xcenter: t.pageX, ycenter: t.pageY}, scale: this.gesture.scale, rotation: this.gesture.rotation}));\n\t\t\tthis.gesture = null;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\ttouchmove: function (e) {\n\t\tif (this.gesture) {\n\t\t\tvar g = this.makeGesture('gesturechange', e);\n\t\t\tthis.gesture.scale = g.scale;\n\t\t\tthis.gesture.rotation = g.rotation;\n\t\t\tdispatcher.dispatch(g);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tfindIdentifiedTouch: function (touches, id) {\n\t\tfor (var i = 0, t; (t = touches[i]); i++) {\n\t\t\tif (t.identifier === id) {\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgesturePositions: function (e) {\n\t\tvar first = this.findIdentifiedTouch(e.touches, this.orderedTouches[0]);\n\t\tvar last = this.findIdentifiedTouch(e.touches, this.orderedTouches[this.orderedTouches.length - 1]);\n\t\tvar fx = first.pageX, lx = last.pageX, fy = first.pageY, ly = last.pageY;\n\t\t// center the first touch as 0,0\n\t\tvar x = lx - fx, y = ly - fy;\n\t\tvar h = Math.sqrt(x*x + y*y);\n\t\treturn {x: x, y: y, h: h, fx: fx, lx: lx, fy: fy, ly: ly};\n\t},\n\n\t/**\n\t* Finds rotation angle.\n\t* \n\t* @private\n\t*/\n\tgestureAngle: function (positions) {\n\t\tvar p = positions;\n\t\t// yay math!, rad -> deg\n\t\tvar a = Math.asin(p.y / p.h) * (180 / Math.PI);\n\t\t// fix for range limits of asin (-90 to 90)\n\t\t// Quadrants II and III\n\t\tif (p.x < 0) {\n\t\t\ta = 180 - a;\n\t\t}\n\t\t// Quadrant IV\n\t\tif (p.x > 0 && p.y < 0) {\n\t\t\ta += 360;\n\t\t}\n\t\treturn a;\n\t},\n\n\t/**\n\t* Finds bounding box.\n\t* \n\t* @private\n\t*/\n\tgestureVector: function (positions) {\n\t\t// the least recent touch and the most recent touch determine the bounding box of the gesture event\n\t\tvar p = positions;\n\t\t// center the first touch as 0,0\n\t\treturn {\n\t\t\tmagnitude: p.h,\n\t\t\txcenter: Math.abs(Math.round(p.fx + (p.x / 2))),\n\t\t\tycenter: Math.abs(Math.round(p.fy + (p.y / 2)))\n\t\t};\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmakeGesture: function (type, e, cache) {\n\t\tvar vector, scale, rotation;\n\t\tif (cache) {\n\t\t\tvector = cache.vector;\n\t\t\tscale = cache.scale;\n\t\t\trotation = cache.rotation;\n\t\t} else {\n\t\t\tvar p = this.gesturePositions(e);\n\t\t\tvector = this.gestureVector(p);\n\t\t\tscale = vector.magnitude / this.gesture.magnitude;\n\t\t\t// gestureEvent.rotation is difference from the starting angle, clockwise\n\t\t\trotation = (360 + this.gestureAngle(p) - this.gesture.angle) % 360;\n\t\t}\n\t\tvar event = utils.clone(e);\n\t\treturn utils.mixin(event, {\n\t\t\ttype: type,\n\t\t\tscale: scale,\n\t\t\tpageX: vector.xcenter,\n\t\t\tpageY: vector.ycenter,\n\t\t\trotation: rotation\n\t\t});\n\t}\n};\n",
    "mtime": 1542469884651,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/gesture/touchGestures.js",
    "relPath": "enyo/gesture/touchGestures",
    "requires": [
      "../dispatcher",
      "../utils"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "../gesture",
    "base": "/home/udo/git/NCPV/lib/enyo/src/Control",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/gesture",
    "name": "enyo/gesture",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/gesture",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/enyo/src/gesture/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/enyo/src/gesture/package.json": 1542469884647,
      "/home/udo/git/NCPV/lib/enyo/src/gesture/gesture.js": 1542469884643
    },
    "json": {
      "main": "gesture.js"
    },
    "main": "/home/udo/git/NCPV/lib/enyo/src/gesture/gesture.js",
    "contents": "/**\n* @module enyo/gesture\n*/\n\n\nvar\n\tdispatcher = require('../dispatcher'),\n\tdom = require('../dom'),\n\tplatform = require('../platform'),\n\tutils = require('../utils');\n\nvar\n\tdrag = require('./drag'),\n\ttouchGestures = require('./touchGestures'),\n\tgestureUtil = require('./util');\n\n/**\n* Enyo supports a set of normalized events that work similarly across all supported platforms.\n* These events are provided so that users can write a single set of event handlers for\n* applications that run on both mobile and desktop platforms. They are needed because desktop\n* and mobile platforms handle basic input differently.\n*\n* For more information on normalized input events and their associated properties, see the\n* documentation on [Event Handling]{@linkplain $dev-guide/key-concepts/event-handling.html}\n* in the Enyo Developer Guide.\n*\n* @public\n*/\nvar gesture = module.exports = {\n\t/**\n\t* Handles \"down\" [events]{@glossary event}, including `mousedown` and `keydown`. This is\n\t* responsible for the press-and-hold key repeater.\n\t*\n\t* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.\n\t* @public\n\t*/\n\tdown: function(evt) {\n\t\tvar e = gestureUtil.makeEvent('down', evt);\n\n\t\t// prepare for hold\n\t\tdrag.prepareHold(e);\n\n\t\t// enable prevention of tap event\n\t\te.preventTap = function() {\n\t\t\te._tapPrevented = true;\n\t\t};\n\n\t\tdispatcher.dispatch(e);\n\t\tthis.downEvent = e;\n\n\t\t// start hold, now that control has had a chance\n\t\t// to override the holdPulse configuration\n\t\tdrag.beginHold(e);\n\t},\n\n\t/**\n\t* Handles `mousemove` [events]{@glossary event}.\n\t*\n\t* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.\n\t* @public\n\t*/\n\tmove: function(evt) {\n\t\tvar e = gestureUtil.makeEvent('move', evt);\n\t\t// include delta and direction v. down info in move event\n\t\te.dx = e.dy = e.horizontal = e.vertical = 0;\n\t\tif (e.which && this.downEvent) {\n\t\t\te.dx = evt.clientX - this.downEvent.clientX;\n\t\t\te.dy = evt.clientY - this.downEvent.clientY;\n\t\t\te.horizontal = Math.abs(e.dx) > Math.abs(e.dy);\n\t\t\te.vertical = !e.horizontal;\n\t\t}\n\t\tdispatcher.dispatch(e);\n\t},\n\n\t/**\n\t* Handles \"up\" [events]{@glossary event}, including `mouseup` and `keyup`.\n\t*\n\t* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.\n\t* @public\n\t*/\n\tup: function(evt) {\n\t\tvar e = gestureUtil.makeEvent('up', evt);\n\n\t\t// We have added some logic to synchronize up and down events in certain scenarios (i.e.\n\t\t// clicking multiple buttons with a mouse) and to generally guard against any potential\n\t\t// asymmetry, but a full solution would be to maintain a map of up/down events as an\n\t\t// ideal solution, for future work.\n\t\te._tapPrevented = this.downEvent && this.downEvent._tapPrevented && this.downEvent.which == e.which;\n\t\te.preventTap = function() {\n\t\t\te._tapPrevented = true;\n\t\t};\n\n\t\tdispatcher.dispatch(e);\n\t\tif (!e._tapPrevented && this.downEvent && this.downEvent.which == 1) {\n\t\t\tvar target = this.findCommonAncestor(this.downEvent.target, evt.target);\n\n\t\t\t// the common ancestor of the down/up events is the target of the tap\n\t\t\tif(target) {\n\t\t\t\tif(this.supportsDoubleTap(target)) {\n\t\t\t\t\tthis.doubleTap(e, target);\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendTap(e, target);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.downEvent && this.downEvent.which == e.which) {\n\t\t\tthis.downEvent = null;\n\t\t}\n\t},\n\n\t/**\n\t* Handles `mouseover` [events]{@glossary event}.\n\t*\n\t* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.\n\t* @public\n\t*/\n\tover: function(evt) {\n\t\tvar e = gestureUtil.makeEvent('enter', evt);\n\t\tdispatcher.dispatch(e);\n\t},\n\n\t/**\n\t* Handles `mouseout` [events]{@glossary event}.\n\t*\n\t* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.\n\t* @public\n\t*/\n\tout: function(evt) {\n\t\tvar e = gestureUtil.makeEvent('leave', evt);\n\t\tdispatcher.dispatch(e);\n\t},\n\n\t/**\n\t* Generates `tap` [events]{@glossary event}.\n\t*\n\t* @param {Event} evt - The standard {@glossary event} [object]{glossary Object}.\n\t* @public\n\t*/\n\tsendTap: function(evt, target) {\n\t\tvar e = gestureUtil.makeEvent('tap', evt);\n\t\te.target = target;\n\t\tdispatcher.dispatch(e);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\ttapData: {\n\t\tid: null,\n\t\ttimer: null,\n\t\tstart: 0\n\t},\n\n\t/**\n\t* Global configuration for double tap support. If this is true, all tap events for Controls\n\t* that do not have {@link module:enyo/Control~Control#doubleTapEnabled} explicitly set to false will be\n\t* delayed by the {@link module:enyo/Control~Control#doubleTapInterval}.\n\t*\n\t* @type {Boolean}\n\t* @default  false\n\t* @public\n\t*/\n\tdoubleTapEnabled: false,\n\n\t/**\n\t* Determines if the provided target node supports double tap events\n\t*\n\t* @param {Node} target\n\t* @return {Boolean}\n\t* @private\n\t*/\n\tsupportsDoubleTap: function(target) {\n\t\tvar obj = dispatcher.findDispatchTarget(target);\n\n\t\tif(obj) {\n\t\t\t// Control.doubleTapEnabled is a tri-value property. The default is 'inherit'\n\t\t\t// which takes its cue from gesture's doubleTapEnabled. Values of true or false\n\t\t\t// override the default. So, if the global is true, any truthy value on Control\n\t\t\t// results in true. If the global is false, only an explicit true on Control\n\t\t\t// results in true.\n\t\t\treturn this.doubleTapEnabled? !!obj.doubleTapEnabled : obj.doubleTapEnabled === true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdoubleTap: function(evt, t) {\n\t\tvar obj = dispatcher.findDispatchTarget(t);\n\n\t\tif(this.tapData.id !== obj.id) {\t// this is the first tap\n\t\t\tthis.resetTapData(true);\n\n\t\t\tthis.tapData.id = obj.id;\n\t\t\tthis.tapData.event = evt;\n\t\t\tthis.tapData.target = t;\n\t\t\tthis.tapData.timer = setTimeout(utils.bind(this, \"resetTapData\", true), obj.doubleTapInterval);\n\t\t\tthis.tapData.start = utils.perfNow();\n\t\t} else {\t\t\t\t\t\t\t// this is the double tap\n\t\t\tvar e2 = gestureUtil.makeEvent('doubletap', evt);\n\t\t\te2.target = t;\n\t\t\te2.tapInterval = utils.perfNow() - this.tapData.start;\n\t\t\tthis.resetTapData(false);\n\t\t\tdispatcher.dispatch(e2);\n\t\t}\n\t},\n\n\tresetTapData: function(sendTap) {\n\t\tvar data = this.tapData;\n\n\t\tif(sendTap && data.id) {\n\t\t\tthis.sendTap(data.event, data.target);\n\t\t}\n\n\t\tclearTimeout(data.timer);\n\t\tdata.id = data.start = data.event = data.target = data.timer = null;\n\t},\n\n\t/**\n\t* Given two [DOM nodes]{@glossary Node}, searches for a shared ancestor (looks up\n\t* the hierarchic [DOM]{@glossary DOM} tree of [nodes]{@glossary Node}). The shared\n\t* ancestor node is returned.\n\t*\n\t* @param {Node} controlA - Control one.\n\t* @param {Node} controlB - Control two.\n\t* @returns {(Node|undefined)} The shared ancestor.\n\t* @public\n\t*/\n\tfindCommonAncestor: function(controlA, controlB) {\n\t\tvar p = controlB;\n\t\twhile (p) {\n\t\t\tif (this.isTargetDescendantOf(controlA, p)) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t\tp = p.parentNode;\n\t\t}\n\t},\n\n\t/**\n\t* Given two controls, returns `true` if the `child` is inside the `parent`.\n\t*\n\t* @param {Node} child - The child to search for.\n\t* @param {Node} parent - The expected parent.\n\t* @returns {(Boolean|undefined)} `true` if the `child` is actually a child of `parent`.\n\t*/\n\tisTargetDescendantOf: function(child, parent) {\n\t\tvar c = child;\n\t\twhile(c) {\n\t\t\tif (c == parent) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tc = c.parentNode;\n\t\t}\n\t},\n\n\t/**\n\t* @todo I'd rather refine the public API of gesture rather than simply forwarding the internal\n\t*   drag module but this will work in the interim. - ryanjduffy\n\t*\n\t* Known Consumers:\n\t*  - Spotlight.onAcceleratedKey - (prepare|begin|end)Hold()\n\t*  - Moonstone - configureHoldPulse()\n\t*/\n\tdrag: drag\n};\n\n/**\n* Contains various methods for gesture events.\n*\n* @type {object}\n* @public\n*/\nmodule.exports.events = {\n\t/**\n\t* Shortcut to [gesture.down()]{@link module:enyo/gesture#down}.\n\t*\n\t* @memberof! module:enyo/gesture#\n\t* @method events.mousedown\n\t* @public\n\t*/\n\tmousedown: function(e) {\n\t\tgesture.down(e);\n\t},\n\n\t/**\n\t* Shortcut to [gesture.up()]{@link module:enyo/gesture#up}.\n\t*\n\t* @memberof! module:enyo/gesture#\n\t* @method events.mouseup\n\t* @public\n\t*/\n\tmouseup: function(e) {\n\t\tgesture.up(e);\n\t},\n\n\t/**\n\t* Shortcut to [gesture.move()]{@link module:enyo/gesture#move}.\n\t*\n\t* @memberof! module:enyo/gesture#\n\t* @method events.mousemove\n\t* @public\n\t*/\n\tmousemove:  function(e) {\n\t\tgesture.move(e);\n\t},\n\n\t/**\n\t* Shortcut to [gesture.over()]{@link module:enyo/gesture#over}.\n\t*\n\t* @memberof! module:enyo/gesture#\n\t* @method events.mouseover\n\t* @public\n\t*/\n\tmouseover:  function(e) {\n\t\tgesture.over(e);\n\t},\n\n\t/**\n\t* Shortcut to [gesture.out()]{@link module:enyo/gesture#out}.\n\t*\n\t* @memberof! module:enyo/gesture#\n\t* @method events.mouseout\n\t* @public\n\t*/\n\tmouseout:  function(e) {\n\t\tgesture.out(e);\n\t}\n};\n\n// Firefox mousewheel handling\ndom.requiresWindow(function() {\n\tif (document.addEventListener) {\n\t\tdocument.addEventListener('DOMMouseScroll', function(inEvent) {\n\t\t\tvar e = utils.clone(inEvent),\n\t\t\t\tisVertical = e.VERTICAL_AXIS == e.axis,\n\t\t\t\twheelDelta;\n\t\t\te.preventDefault = function() {\n\t\t\t\tinEvent.preventDefault();\n\t\t\t};\n\t\t\te.type = 'mousewheel';\n\n\t\t\twheelDelta = e.detail * -40;\n\t\t\te.wheelDeltaY = isVertical ? wheelDelta : 0;\n\t\t\te.wheelDeltaX = isVertical ? 0 : wheelDelta;\n\n\t\t\tdispatcher.dispatch(e);\n\t\t}, false);\n\t}\n});\n\n/**\n* @private\n*/\nvar handlers = {\n\ttouchstart: true,\n\ttouchmove: true,\n\ttouchend: true\n};\n\n/**\n* @private\n*/\ndispatcher.features.push(function (e) {\n\tvar type = e.type;\n\n\t// NOTE: beware of properties in gesture.events and drag inadvertently mapped to event types\n\tif (gesture.events[type]) {\n\t\tgesture.events[type](e);\n\t}\n\tif (!platform.gesture && platform.touch && handlers[type]) {\n\t\ttouchGestures[type](e);\n\t}\n\tif (drag[type]) {\n\t\tdrag[type](e);\n\t}\n});\n",
    "nodeModules": false,
    "relPath": "enyo/gesture",
    "requires": [
      "../dispatcher",
      "../dom",
      "../platform",
      "../utils",
      "./drag",
      "./touchGestures",
      "./util"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./Control",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/Control",
    "name": "enyo/Control",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/Control",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/enyo/src/Control/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/enyo/src/Control/package.json": 1542469884111,
      "/home/udo/git/NCPV/lib/enyo/src/Control/Control.js": 1542469884091
    },
    "json": {
      "main": "Control.js",
      "styles": [
        "fullscreen.less"
      ]
    },
    "main": "/home/udo/git/NCPV/lib/enyo/src/Control/Control.js",
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/Control~Control} kind.\n* @module enyo/Control\n*/\n\nvar\n\tkind = require('../kind'),\n\tutils = require('../utils'),\n\tplatform = require('../platform'),\n\tdispatcher = require('../dispatcher'),\n\toptions = require('../options'),\n\troots = require('../roots');\n\nvar\n\tAccessibilitySupport = require('../AccessibilitySupport'),\n\tUiComponent = require('../UiComponent'),\n\tHTMLStringDelegate = require('../HTMLStringDelegate'),\n\tDom = require('../dom');\n\nvar\n\tfullscreen = require('./fullscreen'),\n\tFloatingLayer = require('./floatingLayer');\n\n// While the namespace isn't needed here, gesture is required for ontap events for which Control\n// has a handler. Bringing them all in now for the time being.\nrequire('../gesture');\n\nvar nodePurgatory;\n\n/**\n* Called by `Control.teardownRender()`. In certain circumstances,\n* we need to temporarily keep a DOM node around after tearing down\n* because we're still acting on a stream of touch events emanating\n* from the node. See `Control.retainNode()` for more information.\n*\n* @private\n*/\nfunction storeRetainedNode (control) {\n\tvar p = getNodePurgatory(),\n\t\tn = control._retainedNode;\n\tif (n) {\n\t\tp.appendChild(n);\n\t}\n\tcontrol._retainedNode = null;\n}\n\n/**\n* Called (via a callback) when it's time to release a DOM node\n* that we've retained.\n*\n* @private\n*/\nfunction releaseRetainedNode (retainedNode) {\n\tvar p = getNodePurgatory();\n\tif (retainedNode) {\n\t\tp.removeChild(retainedNode);\n\t}\n}\n\n/**\n* Lazily add a hidden `<div>` to `document.body` to serve as a\n* container for retained DOM nodes.\n*\n* @private\n*/\nfunction getNodePurgatory () {\n\tvar p = nodePurgatory;\n\tif (!p) {\n\t\tp = nodePurgatory = document.createElement(\"div\");\n\t\tp.id = \"node_purgatory\";\n\t\tp.style.display = \"none\";\n\t\tdocument.body.appendChild(p);\n\t}\n\treturn p;\n}\n\n/**\n* {@link module:enyo/Control~Control} is a [component]{@link module:enyo/UiComponent~UiComponent} that controls\n* a [DOM]{@glossary DOM} [node]{@glossary Node} (i.e., an element in the user\n* interface). Controls are generally visible and the user often interacts with\n* them directly. While things like buttons and input boxes are obviously\n* controls, in Enyo, a control may be as simple as a text item or as complex\n* as an entire application. Both inherit the same basic core capabilities from\n* this kind.\n*\n* For more information, see the documentation on\n* [Controls]{@linkplain $dev-guide/key-concepts/controls.html} in the\n* Enyo Developer Guide.\n*\n* **If you make changes to `enyo/Control`, be sure to add or update the\n* appropriate unit tests.**\n*\n* @class Control\n* @extends module:enyo/UiComponent~UiComponent\n* @ui\n* @public\n*/\nvar Control = module.exports = kind(\n\t/** @lends module:enyo/Control~Control.prototype */ {\n\n\tname: 'enyo.Control',\n\n\t/**\n\t* @private\n\t*/\n\tkind: UiComponent,\n\n\t/**\n\t* @private\n\t*/\n\tmixins: options.accessibility ? [AccessibilitySupport] : null,\n\n\t/**\n\t* @type {String}\n\t* @default 'module:enyo/Control~Control'\n\t* @public\n\t*/\n\tdefaultKind: null, // set after the fact\n\n\t/**\n\t* The [DOM node]{@glossary DOM} tag name that should be created.\n\t*\n\t* @type {String}\n\t* @default 'div'\n\t* @public\n\t*/\n\ttag: 'div',\n\n\t/**\n\t* A [hash]{@glossary Object} of attributes to be applied to the created\n\t* [DOM]{@glossary DOM} node.\n\t*\n\t* @type {Object}\n\t* @default null\n\t* @public\n\t*/\n\tattributes: null,\n\n\t/**\n\t* [Boolean]{@glossary Boolean} flag indicating whether this element should\n\t* \"fit\", or fill its container's size.\n\t*\n\t* @type {Boolean}\n\t* @default null\n\t* @public\n\t*/\n\tfit: null,\n\n\t/**\n\t* [Boolean]{@glossary Boolean} flag indicating whether HTML is allowed in\n\t* this control's [content]{@link module:enyo/Control~Control#content} property. If `false`\n\t* (the default), HTML will be encoded into [HTML entities]{@glossary entity}\n\t* (e.g., `&lt;` and `&gt;`) for literal visual representation.\n\t*\n\t* @type {Boolean}\n\t* @default null\n\t* @public\n\t*/\n\tallowHtml: false,\n\n\t/**\n\t* Mimics the HTML `style` attribute.\n\t*\n\t* @type {String}\n\t* @default ''\n\t* @public\n\t*/\n\tstyle: '',\n\n\t/**\n\t* @private\n\t*/\n\tkindStyle: '',\n\n\t/**\n\t* Mimics the HTML `class` attribute.\n\t*\n\t* @type {String}\n\t* @default ''\n\t* @public\n\t*/\n\tclasses: '',\n\n\t/**\n\t* @private\n\t*/\n\tkindClasses: '',\n\n\t/**\n\t* [Classes]{@link module:enyo/Control~Control#classes} that are applied to all controls.\n\t*\n\t* @type {String}\n\t* @default ''\n\t* @public\n\t*/\n\tcontrolClasses: '',\n\n\t/**\n\t* The text-based content of the Control. If the [allowHtml]{@link module:enyo/Control~Control#allowHtml}\n\t* flag is set to `true`, you may set this property to an HTML string.\n\t* @public\n\t*/\n\tcontent: '',\n\n\t/**\n\t* If true or 'inherit' and enyo/gesture#doubleTabEnabled == true, will fire a doubletap\n\t* event, and will temporarily suppress a single tap while waiting for a double tap.\n\t*\n\t* @type {String|Boolean}\n\t* @default 'inherit'\n\t* @public\n\t*/\n\tdoubleTapEnabled: 'inherit',\n\n\t/**\n\t* Time in milliseconds to wait to detect a double tap\n\t*\n\t* @type {Number}\n\t* @default 300\n\t* @public\n\t*/\n\tdoubleTapInterval: 300,\n\n\t/**\n\t* If set to `true`, the [control]{@link module:enyo/Control~Control} will not be rendered until its\n\t* [showing]{@link module:enyo/Control~Control#showing} property has been set to `true`. This can be used\n\t* directly or is used by some widgets to control when children are rendered.\n\t*\n\t* It is important to note that setting this to `true` will _force_\n\t* [canGenerate]{@link module:enyo/Control~Control#canGenerate} and [showing]{@link module:enyo/Control~Control#showing}\n\t* to be `false`. Arbitrarily modifying the values of these properties prior to its initial\n\t* render may have unexpected results.\n\t*\n\t* Once a control has been shown/rendered with `renderOnShow` `true` the behavior will not\n\t* be used again.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\trenderOnShow: false,\n\n\t/**\n\t* @todo Find out how to document \"handlers\".\n\t* @public\n\t*/\n\thandlers: {\n\t\tontap: 'tap',\n\t\tonShowingChanged: 'showingChangedHandler'\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstrictlyInternalEvents: {onenter: 1, onleave: 1},\n\n\t/**\n\t* @private\n\t*/\n\tisInternalEvent: function (event) {\n\t\tvar rdt = dispatcher.findDispatchTarget(event.relatedTarget);\n\t\treturn rdt && rdt.isDescendantOf(this);\n\t},\n\n\t// .................................\n\t// DOM NODE MANIPULATION API\n\n\t/**\n\t* Gets the bounds for this control. The `top` and `left` properties returned\n\t* by this method represent the control's positional distance in pixels from\n\t* either A) the first parent of this control that is absolutely or relatively\n\t* positioned, or B) the `document.body`.\n\t*\n\t* This is a shortcut convenience method for {@link module:enyo/dom#getBounds}.\n\t*\n\t* @returns {Object} An [object]{@glossary Object} containing `top`, `left`,\n\t* `width`, and `height` properties.\n\t* @public\n\t*/\n\tgetBounds: function () {\n\t\tvar node = this.hasNode(),\n\t\t\tbounds = node && Dom.getBounds(node);\n\n\t\treturn bounds || {left: undefined, top: undefined, width: undefined, height: undefined};\n\t},\n\n\t/**\n\t* Sets the absolute/relative position and/or size for this control. Values\n\t* of `null` or `undefined` for the `bounds` properties will be ignored. You\n\t* may optionally specify a `unit` (i.e., a valid CSS measurement unit) as a\n\t* [string]{@glossary String} to be applied to each of the position/size\n\t* assignments.\n\t*\n\t* @param {Object} bounds - An [object]{@glossary Object}, optionally\n\t* containing one or more of the following properties: `width`, `height`,\n\t* `top`, `right`, `bottom`, and `left`.\n\t* @param {String} [unit='px']\n\t* @public\n\t*/\n\tsetBounds: function (bounds, unit) {\n\t\tvar newStyle = '',\n\t\t\textents = ['width', 'height', 'left', 'top', 'right', 'bottom'],\n\t\t\ti = 0,\n\t\t\tval,\n\t\t\text;\n\n\t\t// if no unit is supplied, we default to pixels\n\t\tunit = unit || 'px';\n\n\t\tfor (; (ext = extents[i]); ++i) {\n\t\t\tval = bounds[ext];\n\t\t\tif (val || val === 0) {\n\t\t\t\tnewStyle += (ext + ':' + val + (typeof val == 'string' ? '' : unit) + ';');\n\t\t\t}\n\t\t}\n\n\t\tthis.set('style', this.style + newStyle);\n\t},\n\n\t/**\n\t* Gets the bounds for this control. The `top` and `left` properties returned\n\t* by this method represent the control's positional distance in pixels from\n\t* `document.body`. To get the bounds relative to this control's parent(s),\n\t* use [getBounds()]{@link module:enyo/Control~Control#getBounds}.\n\t*\n\t* This is a shortcut convenience method for {@link module:enyo/dom#getAbsoluteBounds}.\n\t*\n\t* @returns {Object} An [object]{@glossary Object} containing `top`, `left`,\n\t* `width`, and `height` properties.\n\t* @public\n\t*/\n\tgetAbsoluteBounds: function () {\n\t\tvar node = this.hasNode(),\n\t\t\tbounds = node && Dom.getAbsoluteBounds(node);\n\n\t\treturn bounds || {\n\t\t\tleft: undefined,\n\t\t\ttop: undefined,\n\t\t\twidth: undefined,\n\t\t\theight: undefined,\n\t\t\tbottom: undefined,\n\t\t\tright: undefined\n\t\t};\n\t},\n\n\t/**\n\t* Shortcut method to set [showing]{@link module:enyo/Control~Control#showing} to `true`.\n\t*\n\t* @public\n\t*/\n\tshow: function () {\n\t\tthis.set('showing', true);\n\t},\n\n\t/**\n\t* Shortcut method to set [showing]{@link module:enyo/Control~Control#showing} to `false`.\n\t*\n\t* @public\n\t*/\n\thide: function () {\n\t\tthis.set('showing', false);\n\t},\n\n\t/**\n\t* Sets this control to be [focused]{@glossary focus}.\n\t*\n\t* @public\n\t*/\n\tfocus: function () {\n\t\tif (this.hasNode()) this.node.focus();\n\t},\n\n\t/**\n\t* [Blurs]{@glossary blur} this control. (The opposite of\n\t* [focus()]{@link module:enyo/Control~Control#focus}.)\n\t*\n\t* @public\n\t*/\n\tblur: function () {\n\t\tif (this.hasNode()) this.node.blur();\n\t},\n\n\t/**\n\t* Determines whether this control currently has the [focus]{@glossary focus}.\n\t*\n\t* @returns {Boolean} Whether this control has focus. `true` if the control\n\t* has focus; otherwise, `false`.\n\t* @public\n\t*/\n\thasFocus: function () {\n\t\tif (this.hasNode()) return document.activeElement === this.node;\n\t},\n\n\t/**\n\t* Determines whether this control's [DOM node]{@glossary Node} has been created.\n\t*\n\t* @returns {Boolean} Whether this control's [DOM node]{@glossary Node} has\n\t* been created. `true` if it has been created; otherwise, `false`.\n\t* @public\n\t*/\n\thasNode: function () {\n\t\treturn this.generated && (this.node || this.findNodeById());\n\t},\n\n\t/**\n\t* Gets the requested property (`name`) from the control's attributes\n\t* [hash]{@glossary Object}, from its cache of node attributes, or, if it has\n\t* yet to be cached, from the [node]{@glossary Node} itself.\n\t*\n\t* @param {String} name - The attribute name to get.\n\t* @returns {(String|null)} The value of the requested attribute, or `null`\n\t* if there isn't a [DOM node]{@glossary Node} yet.\n\t* @public\n\t*/\n\tgetAttribute: function (name) {\n\t\tvar node;\n\n\t\t// TODO: This is a fixed API assuming that no changes will happen to the DOM that\n\t\t// do not use it...original implementation of this method used the node's own\n\t\t// getAttribute method every time it could but we really only need to do that if we\n\t\t// weren't the ones that set the value to begin with -- in slow DOM situations this\n\t\t// could still be faster but it needs to be verified\n\t\tif (this.attributes.hasOwnProperty(name)) return this.attributes[name];\n\t\telse {\n\t\t\tnode = this.hasNode();\n\n\t\t\t// we store the value so that next time we'll know what it is\n\t\t\t/*jshint -W093 */\n\t\t\treturn (this.attributes[name] = (node ? node.getAttribute(name) : null));\n\t\t\t/*jshint +W093 */\n\t\t}\n\t},\n\n\t/**\n\t* Assigns an attribute to a control's [node]{@glossary Node}. Assigning\n\t* `name` a value of `null`, `false`, or the empty string `(\"\")` will remove\n\t* the attribute from the node altogether.\n\t*\n\t* @param {String} name - Attribute name to assign/remove.\n\t* @param {(String|Number|null)} value - The value to assign to `name`\n\t* @returns {this} Callee for chaining.\n\t* @public\n\t*/\n\tsetAttribute: function (name, value) {\n\t\tvar attrs = this.attributes,\n\t\t\tnode = this.hasNode(),\n\t\t\tdelegate = this.renderDelegate || Control.renderDelegate;\n\n\t\tif (name) {\n\t\t\tattrs[name] = value;\n\n\t\t\tif (node) {\n\t\t\t\tif (value == null || value === false || value === '') {\n\t\t\t\t\tnode.removeAttribute(name);\n\t\t\t\t} else node.setAttribute(name, value);\n\t\t\t}\n\n\t\t\tdelegate.invalidate(this, 'attributes');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* Reads the `name` property directly from the [node]{@glossary Node}. You\n\t* may provide a default (`def`) to use if there is no node yet.\n\t*\n\t* @param {String} name - The [node]{@glossary Node} property name to get.\n\t* @param {*} def - The default value to apply if there is no node.\n\t* @returns {String} The value of the `name` property, or `def` if the node\n\t* was not available.\n\t* @public\n\t*/\n\tgetNodeProperty: function (name, def) {\n\t\treturn this.hasNode() ? this.node[name] : def;\n\t},\n\n\t/**\n\t* Sets the value of a property (`name`) directly on the [node]{@glossary Node}.\n\t*\n\t* @param {String} name - The [node]{@glossary Node} property name to set.\n\t* @param {*} value - The value to assign to the property.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tsetNodeProperty: function (name, value) {\n\t\tif (this.hasNode()) this.node[name] = value;\n\t\treturn this;\n\t},\n\n\t/**\n\t* Appends additional content to this control.\n\t*\n\t* @param {String} content - The new string to add to the end of the `content`\n\t* property.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\taddContent: function (content) {\n\t\treturn this.set('content', this.get('content') + content);\n\t},\n\n\t// .................................\n\n\t// .................................\n\t// STYLE/CLASS API\n\n\t/**\n\t* Determines whether this control has the class `name`.\n\t*\n\t* @param {String} name - The name of the class (or classes) to check for.\n\t* @returns {Boolean} Whether the control has the class `name`.\n\t* @public\n\t*/\n\thasClass: function (name) {\n\t\treturn name && (' ' + this.classes + ' ').indexOf(' ' + name + ' ') > -1;\n\t},\n\n\t/**\n\t* Adds the specified class to this control's list of classes.\n\t*\n\t* @param {String} name - The name of the class to add.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\taddClass: function (name) {\n\t\tvar classes = this.classes || '';\n\n\t\t// NOTE: Because this method accepts a string and for efficiency does not wish to\n\t\t// parse it to determine if it is actually multiple classes we later pull a trick\n\t\t// to keep it normalized and synchronized with our attributes hash and the node's\n\t\tif (name && !this.hasClass(name)) {\n\n\t\t\t// this is hooked\n\t\t\tthis.set('classes', classes + (classes ? (' ' + name) : name));\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* Removes the specified class from this control's list of classes.\n\t*\n\t* **Note: It is not advisable to pass a string of multiple, space-delimited\n\t* class names into this method. Instead, call the method once for each class\n\t* name that you want to remove.**\n\t*\n\t* @param {String} name - The name of the class to remove.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tremoveClass: function (name) {\n\t\tvar classes = this.classes;\n\n\t\tif (name) {\n\t\t\tthis.set('classes', (' ' + classes + ' ').replace(' ' + name + ' ', ' ').trim());\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* Adds or removes the specified class conditionally, based on the state\n\t* of the `add` argument.\n\t*\n\t* @param {String} name - The name of the class to add or remove.\n\t* @param {Boolean} add - If `true`, `name` will be added as a class; if\n\t* `false`, it will be removed.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\taddRemoveClass: function (name, add) {\n\t\treturn name ? this[add ? 'addClass' : 'removeClass'](name) : this;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tclassesChanged: function () {\n\t\tvar classes = this.classes,\n\t\t\tnode = this.hasNode(),\n\t\t\tattrs = this.attributes,\n\t\t\tdelegate = this.renderDelegate || Control.renderDelegate;\n\n\t\tif (node) {\n\t\t\tif (classes || this.kindClasses) {\n\t\t\t\tnode.setAttribute('class', classes || this.kindClasses);\n\t\t\t} else node.removeAttribute('class');\n\n\t\t\tthis.classes = classes = node.getAttribute('class');\n\t\t}\n\n\t\t// we need to update our attributes.class value and flag ourselves to be\n\t\t// updated\n\t\tattrs['class'] = classes;\n\n\t\t// we want to notify the delegate that the attributes have changed in case it wants\n\t\t// to handle this is some special way\n\t\tdelegate.invalidate(this, 'attributes');\n\t},\n\n\t/**\n\t* Applies a CSS style directly to the control. Use the `prop` argument to\n\t* specify the CSS property name you'd like to set, and `value` to specify\n\t* the desired value. Setting `value` to `null` will remove the CSS property\n\t* `prop` altogether.\n\t*\n\t* @param {String} prop - The CSS property to assign.\n\t* @param {(String|Number|null|undefined)} value - The value to assign to\n\t* `prop`. Setting a value of `null`, `undefined`, or the empty string `(\"\")`\n\t* will remove the property `prop` from the control.\n\t* @returns {this} Callee for chaining.\n\t* @public\n\t*/\n\tapplyStyle: function (prop, value) {\n\n\t\t// NOTE: This method deliberately avoids calling set('style', ...) for performance\n\t\t// as it will have already been parsed by the browser so we pass it on via the\n\t\t// notification system which is the same\n\n\t\t// TODO: Wish we could delay this potentially...\n\t\t// if we have a node we render the value immediately and update our style string\n\t\t// in the process to keep them synchronized\n\t\tvar node = this.hasNode(),\n\t\t\tstyle = this.style,\n\t\t\tdelegate = this.renderDelegate || Control.renderDelegate;\n\n\t\t// FIXME: This is put in place for a Firefox bug where setting a style value of a node\n\t\t// via its CSSStyleDeclaration object (by accessing its node.style property) does\n\t\t// not work when using a CSS property name that contains one or more dash, and requires\n\t\t// setting the property via the JavaScript-style property name. This fix should be\n\t\t// removed once this issue has been resolved in the Firefox mainline and its variants\n\t\t// (it is currently resolved in the 36.0a1 nightly):\n\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=1083457\n\t\tif (node && (platform.firefox < 35 || platform.firefoxOS || platform.androidFirefox)) {\n\t\t\tprop = prop.replace(/-([a-z])/gi, function(match, submatch) {\n\t\t\t\treturn submatch.toUpperCase();\n\t\t\t});\n\t\t}\n\n\t\tif (value !== null && value !== '' && value !== undefined) {\n\t\t\t// update our current cached value\n\t\t\tif (node) {\n\t\t\t\tnode.style[prop] = value;\n\n\t\t\t\t// cssText is an internal property used to help know when to sync and not\n\t\t\t\t// sync with the node in styleChanged\n\t\t\t\tthis.style = this.cssText = node.style.cssText;\n\n\t\t\t\t// otherwise we have to try and prepare it for the next time it is rendered we\n\t\t\t\t// will need to update it because it will not be synchronized\n\t\t\t} else this.set('style', style + (' ' + prop + ':' + value + ';'));\n\t\t} else {\n\n\t\t\t// in this case we are trying to clear the style property so if we have the node\n\t\t\t// we let the browser handle whatever the value should be now and otherwise\n\t\t\t// we have to parse it out of the style string and wait to be rendered\n\n\t\t\tif (node) {\n\t\t\t\tnode.style[prop] = '';\n\t\t\t\tthis.style = this.cssText = node.style.cssText;\n\n\t\t\t\t// we need to invalidate the style for the delegate\n\t\t\t\tdelegate.invalidate(this, 'style');\n\t\t\t} else {\n\n\t\t\t\t// this is a rare case to nullify the style of a control that is not\n\t\t\t\t// rendered or does not have a node\n\t\t\t\tstyle = style.replace(new RegExp(\n\t\t\t\t\t// This looks a lot worse than it is. The complexity stems from needing to\n\t\t\t\t\t// match a url container that can have other characters including semi-\n\t\t\t\t\t// colon and also that the last property may/may-not end with one\n\t\t\t\t\t'\\\\s*' + prop + '\\\\s*:\\\\s*[a-zA-Z0-9\\\\ ()_\\\\-\\'\"%,]*(?:url\\\\(.*\\\\)\\\\s*[a-zA-Z0-9\\\\ ()_\\\\-\\'\"%,]*)?\\\\s*(?:;|;?$)',\n\t\t\t\t\t'gi'\n\t\t\t\t),'');\n\t\t\t\tthis.set('style', style);\n\t\t\t}\n\t\t}\n\t\t// we need to invalidate the style for the delegate -- regardless of whether or\n\t\t// not the node exists to ensure that the tag is updated properly the next time\n\t\t// it is rendered\n\t\tdelegate.invalidate(this, 'style');\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* Allows the addition of several CSS properties and values at once, via a\n\t* single string, similar to how the HTML `style` attribute works.\n\t*\n\t* @param {String} css - A string containing one or more valid CSS styles.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\taddStyles: function (css) {\n\t\tvar key,\n\t\t\tnewStyle = '';\n\n\t\tif (typeof css == 'object') {\n\t\t\tfor (key in css) newStyle += (key + ':' + css[key] + ';');\n\t\t} else newStyle = css || '';\n\n\t\tthis.set('style', this.style + newStyle);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstyleChanged: function () {\n\t\tvar delegate = this.renderDelegate || Control.renderDelegate;\n\n\t\t// if the cssText internal string doesn't match then we know style was set directly\n\t\tif (this.cssText !== this.style) {\n\n\t\t\t// we need to render the changes and synchronize - this means that the style\n\t\t\t// property was set directly so we will reset it prepending it with the original\n\t\t\t// style (if any) for the kind and keeping whatever the browser is keeping\n\t\t\tif (this.hasNode()) {\n\t\t\t\tthis.node.style.cssText = this.kindStyle + (this.style || '');\n\t\t\t\t// now we store the parsed version\n\t\t\t\tthis.cssText = this.style = this.node.style.cssText;\n\t\t\t}\n\n\t\t\t// we need to ensure that the delegate has an opportunity to handle this change\n\t\t\t// separately if it needs to\n\t\t\tdelegate.invalidate(this, 'style');\n\t\t}\n\t},\n\n\t/**\n\t* Retrieves a control's CSS property value. This doesn't just pull the\n\t* assigned value of `prop`; it returns the browser's understanding of `prop`,\n\t* the \"computed\" value. If the control isn't been rendered yet, and you need\n\t* a default value (such as `0`), include it in the arguments as `def`.\n\t*\n\t* @param {String} prop - The property name to get.\n\t* @param {*} [def] - An optional default value, in case the control isn't\n\t* rendered yet.\n\t* @returns {(String|Number)} The computed value of `prop`, as the browser\n\t* sees it.\n\t* @public\n\t*/\n\tgetComputedStyleValue: function (prop, def) {\n\t\treturn this.hasNode() ? Dom.getComputedStyleValue(this.node, prop) : def;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tfindNodeById: function () {\n\t\treturn this.id && (this.node = Dom.byId(this.id));\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tidChanged: function (was) {\n\t\tif (was) Control.unregisterDomEvents(was);\n\t\tif (this.id) {\n\t\t\tControl.registerDomEvents(this.id, this);\n\t\t\tthis.setAttribute('id', this.id);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcontentChanged: function () {\n\t\tvar delegate = this.renderDelegate || Control.renderDelegate;\n\t\tdelegate.invalidate(this, 'content');\n\t},\n\n\t/**\n\t* If the control has been generated, re-flows the control.\n\t*\n\t* @public\n\t*/\n\tbeforeChildRender: function () {\n\t\t// if we are generated, we should flow before rendering a child;\n\t\t// if not, the render context isn't ready anyway\n\t\tif (this.generated) this.flow();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tshowingChanged: function (was) {\n\t\tvar nextControl;\n\t\t// if we are changing from not showing to showing we attempt to find whatever\n\t\t// our last known value for display was or use the default\n\t\tif (!was && this.showing) {\n\t\t\tthis.applyStyle('display', this._display || '');\n\n\t\t\t// note the check for generated and canGenerate as changes to canGenerate will force\n\t\t\t// us to ignore the renderOnShow value so we don't undo whatever the developer was\n\t\t\t// intending\n\t\t\tif (!this.generated && !this.canGenerate && this.renderOnShow) {\n\t\t\t\tnextControl = this.getNextControl();\n\t\t\t\tif (nextControl && !this.addBefore) this.addBefore = nextControl;\n\t\t\t\tthis.set('canGenerate', true);\n\t\t\t\tthis.render();\n\t\t\t}\n\n\t\t\tthis.sendShowingChangedEvent(was);\n\t\t}\n\n\t\t// if we are supposed to be hiding the control then we need to cache our current\n\t\t// display state\n\t\telse if (was && !this.showing) {\n\t\t\tthis.sendShowingChangedEvent(was);\n\t\t\t// we can't truly cache this because it _could_ potentially be set to multiple\n\t\t\t// values throughout its lifecycle although that seems highly unlikely...\n\t\t\tthis._display = this.hasNode() ? this.node.style.display : '';\n\t\t\tthis.applyStyle('display', 'none');\n\t\t}\n\n\t},\n\n\t/**\n\t* @private\n\t*/\n\trenderOnShowChanged: function () {\n\t\t// ensure that the default value assigned to showing is actually a boolean\n\t\t// and that it is only true if the renderOnShow is also false\n\t\tthis.showing = ((!!this.showing) && !this.renderOnShow);\n\t\t// we want to check and make sure that the canGenerate value is correct given\n\t\t// the state of renderOnShow\n\t\tthis.canGenerate = (this.canGenerate && !this.renderOnShow);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsendShowingChangedEvent: function (was) {\n\t\tvar waterfall = (was === true || was === false),\n\t\t\tparent = this.parent;\n\n\t\t// make sure that we don't trigger the waterfall when this method\n\t\t// is arbitrarily called during _create_ and it should only matter\n\t\t// that it changed if our parent's are all showing as well\n\t\tif (waterfall && (parent ? parent.getAbsoluteShowing(true) : true)) {\n\t\t\tthis.waterfall('onShowingChanged', {originator: this, showing: this.showing});\n\t\t}\n\t},\n\n\t/**\n\t* Returns `true` if this control and all parents are showing.\n\t*\n\t* @param {Boolean} ignoreBounds - If `true`, it will not force a layout by retrieving\n\t*\tcomputed bounds and rely on the return from [showing]{@link module:enyo/Control~Control#showing}\n\t* exclusively.\n\t* @returns {Boolean} Whether the control is showing (visible).\n\t* @public\n\t*/\n\tgetAbsoluteShowing: function (ignoreBounds) {\n\t\tvar bounds = !ignoreBounds ? this.getBounds() : null,\n\t\t\tparent = this.parent;\n\n\t\tif (!this.generated || this.destroyed || !this.showing || (bounds &&\n\t\t\tbounds.height === 0 && bounds.width === 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parent && parent.getAbsoluteShowing) {\n\n\t\t\t// we actually don't care what the parent says if it is the floating layer\n\t\t\tif (!this.parentNode || (this.parentNode !== Control.floatingLayer.hasNode())) {\n\t\t\t\treturn parent.getAbsoluteShowing(ignoreBounds);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t* Handles the `onShowingChanged` event that is waterfalled by controls when\n\t* their `showing` value is modified. If the control is not showing itself\n\t* already, it will not continue the waterfall. Overload this method to\n\t* provide additional handling for this event.\n\t*\n\t* @private\n\t*/\n\tshowingChangedHandler: function (sender, event) {\n\t\t// If we have deferred a reflow, do it now...\n\t\tif (this.showing && this._needsReflow) {\n\t\t\tthis.reflow();\n\t\t}\n\n\t\t// Then propagate `onShowingChanged` if appropriate\n\t\treturn sender === this ? false : !this.showing;\n\t},\n\n\t/**\n\t* Overriding reflow() so that we can take `showing` into\n\t* account and defer reflowing accordingly.\n\t*\n\t* @private\n\t*/\n\treflow: function () {\n\t\tif (this.layout) {\n\t\t\tthis._needsReflow = this.showing ? this.layout.reflow() : true;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tfitChanged: function () {\n\t\tthis.parent.reflow();\n\t},\n\n\t/**\n\t* Determines whether we are in fullscreen mode or not.\n\t*\n\t* @returns {Boolean} Whether we are currently in fullscreen mode.\n\t* @public\n\t*/\n\tisFullscreen: function () {\n\t\treturn (this.hasNode() && this.node === Control.Fullscreen.getFullscreenElement());\n\t},\n\n\t/**\n\t* Requests that this control be displayed fullscreen (like a video\n\t* container). If the request is granted, the control fills the screen and\n\t* `true` is returned; if the request is denied, the control is not resized\n\t* and `false` is returned.\n\t*\n\t* @returns {Boolean} `true` on success; otherwise, `false`.\n\t* @public\n\t*/\n\trequestFullscreen: function () {\n\t\tif (!this.hasNode()) return false;\n\n\t\tif (Control.Fullscreen.requestFullscreen(this)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t/**\n\t* Ends fullscreen mode for this control.\n\t*\n\t* @returns {Boolean} If the control was in fullscreen mode before this\n\t* method was called, it is taken out of that mode and `true` is returned;\n\t* otherwise, `false` is returned.\n\t* @public\n\t*/\n\tcancelFullscreen: function() {\n\t\tif (this.isFullscreen()) {\n\t\t\tControl.Fullscreen.cancelFullscreen();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t// .................................\n\n\t// .................................\n\t// RENDER-SCHEME API\n\n\t/**\n\t* Indicates whether the control is allowed to be generated, i.e., rendered\n\t* into the [DOM]{@glossary DOM} tree.\n\t*\n\t* @type {Boolean}\n\t* @default true\n\t* @public\n\t*/\n\tcanGenerate: true,\n\n\t/**\n\t* Indicates whether the control is visible.\n\t*\n\t* @type {Boolean}\n\t* @default true\n\t* @public\n\t*/\n\tshowing: true,\n\n\t/**\n\t* The [node]{@glossary Node} that this control will be rendered into.\n\t*\n\t* @type {module:enyo/Control~Control}\n\t* @default null\n\t* @public\n\t*/\n\trenderDelegate: null,\n\n\t/**\n\t* Indicates whether the control has been generated yet.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @private\n\t*/\n\tgenerated: false,\n\n\t/**\n\t* Forces the control to be rendered. You should use this sparingly, as it\n\t* can be costly, but it may be necessary in cases where a control or its\n\t* contents have been updated surreptitiously.\n\t*\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\trender: function () {\n\n\t\t// prioritize the delegate set for this control otherwise use the default\n\t\tvar delegate = this.renderDelegate || Control.renderDelegate;\n\n\t\t// the render delegate acts on the control\n\t\tdelegate.render(this);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* Takes this control and drops it into a (new/different)\n\t* [DOM node]{@glossary Node}. This will replace any existing nodes in the\n\t* target `parentNode`.\n\t*\n\t* @param {Node} parentNode - The new parent of this control.\n\t* @param {Boolean} preventRooting - If `true`, this control will not be treated as a root\n\t*\tview and will not be added to the set of roots.\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\trenderInto: function (parentNode, preventRooting) {\n\t\tvar delegate = this.renderDelegate || Control.renderDelegate,\n\t\t\tnoFit = this.fit === false;\n\n\t\t// attempt to retrieve the parentNode\n\t\tparentNode = Dom.byId(parentNode);\n\n\t\t// teardown in case of previous render\n\t\tdelegate.teardownRender(this);\n\n\t\tif (parentNode == document.body && !noFit) this.setupBodyFitting();\n\t\telse if (this.fit) this.addClass('enyo-fit enyo-clip');\n\n\t\t// for IE10 support, we want full support over touch actions in enyo-rendered areas\n\t\tthis.addClass('enyo-no-touch-action');\n\n\t\t// add css to enable hw-accelerated scrolling on non-android platforms\n\t\t// ENYO-900, ENYO-901\n\t\tthis.setupOverflowScrolling();\n\n\t\t// if there are unflushed body classes we flush them now...\n\t\tDom.flushBodyClasses();\n\n\t\t// we inject this as a root view because, well, apparently that is just an assumption\n\t\t// we've been making...\n\t\tif (!preventRooting) {\n\t\t\troots.addToRoots(this);\n\t\t}\n\n\t\t// now let the delegate render it the way it needs to\n\t\tdelegate.renderInto(this, parentNode);\n\n\t\tDom.updateScaleFactor();\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* A function that fires after the control has rendered. This performs a\n\t* reflow.\n\t*\n\t* @public\n\t*/\n\trendered: function () {\n\t\tvar child,\n\t\t\ti = 0;\n\n\t\t// CAVEAT: Currently we use one entry point ('reflow') for\n\t\t// post-render layout work *and* post-resize layout work.\n\t\tthis.reflow();\n\n\t\tfor (; (child = this.children[i]); ++i) {\n\t\t\tif (child.generated) child.rendered();\n\t\t}\n\t},\n\n\t/**\n\t* You should generally not need to call this method in your app code.\n\t* It is used internally by some Enyo UI libraries to handle a rare\n\t* issue that sometimes arises when using a virtualized list or repeater\n\t* on a touch device.\n\t*\n\t* This issue occurs when a gesture (e.g. a drag) originates with a DOM\n\t* node that ends up being destroyed in mid-gesture as the list updates.\n\t* When the node is destroyed, the stream of DOM events representing the\n\t* gesture stops, causing the associated action to stop or otherwise\n\t* fail.\n\t*\n\t* You can prevent this problem from occurring by calling `retainNode`\n\t* on the {@link module:enyo/Control~Control} from which the gesture originates. Doing\n\t* so will cause Enyo to keep the DOM node around (hidden from view)\n\t* until you explicitly release it. You should call `retainNode` in the\n\t* event handler for the event that starts the gesture.\n\t*\n\t* `retainNode` returns a function that you must call when the gesture\n\t* ends to release the node. Make sure you call this function to avoid\n\t* \"leaking\" the DOM node (failing to remove it from the DOM).\n\t*\n\t* @param {Node} node - Optional. Defaults to the node associated with\n\t* the Control (`Control.node`). You can generally omit this parameter\n\t* when working with {@link module:enyo/DataList~DataList} or {@link module:enyo/DataGridList~DataGridList},\n\t* but should generally pass in the event's target node (`event.target`)\n\t* when working with {@link module:layout/List~List}. (Because {@link module:layout/List~List} is\n\t* based on the Flyweight pattern, the event's target node is often not\n\t* the node currently associated with the Control at the time the event\n\t* occurs.)\n\t* @returns {Function} Keep a reference to this function and call it\n\t* to release the node when the gesture has ended.\n\t* @public\n\t*/\n\tretainNode: function(node) {\n\t\tvar control = this,\n\t\t\tretainedNode = this._retainedNode = (node || this.hasNode());\n\t\treturn function() {\n\t\t\tif (control && (control._retainedNode == retainedNode)) {\n\t\t\t\tcontrol._retainedNode = null;\n\t\t\t} else {\n\t\t\t\treleaseRetainedNode(retainedNode);\n\t\t\t}\n\t\t};\n\t},\n\n\t/**\n\t* If a Control needs to do something before it and its children's DOM nodes\n\t* are torn down, it can implement this lifecycle method, which is called automatically\n\t* by the framework and takes no arguments.\n\t*\n\t* @type {Function}\n\t* @protected\n\t*/\n\tbeforeTeardown: null,\n\n\t/**\n\t* @param {Boolean} [cache] - Whether or not we are tearing down as part of a destroy\n\t*\toperation, or if we are just caching. If `true`, the `showing` and `canGenerate`\n\t*\tproperties of the control will not be reset.\n\t* @private\n\t*/\n\tteardownRender: function (cache) {\n\t\tvar delegate = this.renderDelegate || Control.renderDelegate;\n\n\t\tif (this._retainedNode) {\n\t\t\tstoreRetainedNode(this);\n\t\t}\n\n\t\tdelegate.teardownRender(this, cache);\n\n\t\t// if the original state was set with renderOnShow true then we need to reset these\n\t\t// values as well to coordinate the original intent\n\t\tif (this.renderOnShow && !cache) {\n\t\t\tthis.set('showing', false);\n\t\t\tthis.set('canGenerate', false);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tteardownChildren: function () {\n\t\tvar delegate = this.renderDelegate || Control.renderDelegate;\n\n\t\tdelegate.teardownChildren(this);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\taddNodeToParent: function () {\n\t\tvar pn;\n\n\t\tif (this.node) {\n\t\t\tpn = this.getParentNode();\n\t\t\tif (pn) {\n\t\t\t\tif (this.addBefore !== undefined) {\n\t\t\t\t\tthis.insertNodeInParent(pn, this.addBefore && this.addBefore.hasNode());\n\t\t\t\t} else this.appendNodeToParent(pn);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tappendNodeToParent: function(parentNode) {\n\t\tparentNode.appendChild(this.node);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tinsertNodeInParent: function(parentNode, beforeNode) {\n\t\tparentNode.insertBefore(this.node, beforeNode || parentNode.firstChild);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tremoveNodeFromDom: function() {\n\t\tvar node = this.hasNode();\n\t\tif (node) {\n\t\t\tDom.removeNode(node);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetParentNode: function () {\n\t\treturn this.parentNode || (this.parent && (\n\t\t\tthis.parent.hasNode() || this.parent.getParentNode())\n\t\t);\n\t},\n\n\t// .................................\n\n\t/**\n\t* @private\n\t*/\n\tconstructor: kind.inherit(function (sup) {\n\t\treturn function (props) {\n\t\t\tvar attrs = props && props.attributes;\n\n\t\t\t// ensure that we both keep an instance copy of defined attributes but also\n\t\t\t// update the hash with any additional instance definitions at runtime\n\t\t\tthis.attributes = this.attributes ? utils.clone(this.attributes) : {};\n\t\t\tif (attrs) {\n\t\t\t\tutils.mixin(this.attributes, attrs);\n\t\t\t\tdelete  props.attributes;\n\t\t\t}\n\n\t\t\treturn sup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function (props) {\n\t\t\tvar classes;\n\n\t\t\t// initialize the styles for this instance\n\t\t\tthis.style = this.kindStyle + this.style;\n\n\t\t\t// set initial values based on renderOnShow\n\t\t\tthis.renderOnShowChanged();\n\n\t\t\t// super initialization\n\t\t\tsup.apply(this, arguments);\n\n\t\t\t// ensure that if we aren't showing -> true then the correct style\n\t\t\t// is applied - note that there might be issues with this because we are\n\t\t\t// trying not to have to parse out any other explicit display value during\n\t\t\t// initialization and we can't check because we haven't rendered yet\n\t\t\tif (!this.showing) this.style += ' display: none;';\n\n\t\t\t// try and make it so we only need to call the method once during\n\t\t\t// initialization and only then when we have something to add\n\t\t\tclasses = this.kindClasses;\n\t\t\tif (classes && this.classes) classes += (' ' + this.classes);\n\t\t\telse if (this.classes) classes = this.classes;\n\n\t\t\t// if there are known classes needed to be applied from the kind\n\t\t\t// definition and the instance definition (such as a component block)\n\t\t\tthis.classes = this.attributes['class'] = classes ? classes.trim() : classes;\n\n\t\t\t// setup the id for this control if we have one\n\t\t\tthis.idChanged();\n\t\t\tthis.contentChanged();\n\t\t};\n\t}),\n\n\t/**\n\t* Destroys the control and removes it from the [DOM]{@glossary DOM}. Also\n\t* removes the control's ability to receive bubbled events.\n\t*\n\t* @public\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\t// if the control has been rendered we ensure it is removed from the DOM\n\t\t\tthis.removeNodeFromDom();\n\n\t\t\t// ensure no other bubbled events can be dispatched to this control\n\t\t\tdispatcher.$[this.id] = null;\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tdispatchEvent: kind.inherit(function (sup) {\n\t\treturn function (name, event, sender) {\n\t\t\t// prevent dispatch and bubble of events that are strictly internal (e.g.\n\t\t\t// enter/leave)\n\t\t\tif (this.strictlyInternalEvents[name] && this.isInternalEvent(event)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn sup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\taddChild: kind.inherit(function (sup) {\n\t\treturn function (control) {\n\t\t\tcontrol.addClass(this.controlClasses);\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tremoveChild: kind.inherit(function (sup) {\n\t\treturn function (control) {\n\t\t\tsup.apply(this, arguments);\n\t\t\tcontrol.removeClass(this.controlClasses);\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tset: kind.inherit(function (sup) {\n\t\treturn function (path, value, opts) {\n\t\t\t// this should be updated if a better api for hooking becomes available but for\n\t\t\t// now we just do this directly to ensure that the showing value is actually\n\t\t\t// a boolean\n\t\t\tif (path == 'showing') {\n\t\t\t\treturn sup.call(this, path, !! value, opts);\n\t\t\t} else return sup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t// .................................\n\t// BACKWARDS COMPATIBLE API, LEGACY METHODS AND PUBLIC PROPERTY\n\t// METHODS OR PROPERTIES THAT PROBABLY SHOULD NOT BE HERE BUT ARE ANYWAY\n\n\t/**\n\t* Apparently used by Ares 2 still but we have the property embedded in the kind...\n\t*\n\t* @deprecated\n\t* @private\n\t*/\n\tisContainer: false,\n\n\t/**\n\t* @private\n\t*/\n\trtl: false,\n\n\t/**\n\t* @private\n\t*/\n\tsetupBodyFitting: function () {\n\t\tDom.applyBodyFit();\n\t\tthis.addClass('enyo-fit enyo-clip');\n\t},\n\n\t/*\n\t* If the platform is Android or Android-Chrome, don't include the css rule\n\t* `-webkit-overflow-scrolling: touch`, as it is not supported in Android and leads to\n\t* overflow issues (ENYO-900 and ENYO-901). Similarly, BB10 has issues repainting\n\t* out-of-viewport content when `-webkit-overflow-scrolling` is used (ENYO-1396).\n\t*\n\t* @private\n\t*/\n\tsetupOverflowScrolling: function () {\n\t\tif(platform.android || platform.androidChrome || platform.blackberry) {\n\t\t\treturn;\n\t\t}\n\t\tDom.addBodyClass('webkitOverflowScrolling');\n\t},\n\n\t/**\n\t* Sets the control's directionality based on its content, or an optional `stringInstead`.\n\t*\n\t* @param {String} [stringInstead] An alternate string for consideration may be sent instead,\n\t*\tin-case the string to test the directionality of the control is stored in `this.value`,\n\t*\tor some other property, for example.\n\t* @private\n\t*/\n\tdetectTextDirectionality: function (stringInstead) {\n\t\t// If an argument was supplied at all, use it, even if it's undefined.\n\t\t// Values that are null or undefined, or are numbers, arrays, and some objects are safe\n\t\t// to be tested.\n\t\tvar str = (arguments.length) ? stringInstead : this.content;\n\t\tif (str || str === 0) {\n\t\t\tthis.rtl = utils.isRtl(str);\n\t\t\tthis.applyStyle('direction', this.rtl ? 'rtl' : 'ltr');\n\t\t} else {\n\t\t\tthis.applyStyle('direction', null);\n\t\t}\n\n\t},\n\n\t// .................................\n\n\t// .................................\n\t// DEPRECATED\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tgetTag: function () {\n\t\treturn this.tag;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tsetTag: function (tag) {\n\t\tvar was = this.tag;\n\n\t\tif (tag && typeof tag == 'string') {\n\t\t\tthis.tag = tag;\n\t\t\tif (was !== tag) this.notify('tag', was, tag);\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tgetAttributes: function () {\n\t\treturn this.attributes;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tsetAttributes: function (attrs) {\n\t\tvar was = this.attributes;\n\n\t\tif (typeof attrs == 'object') {\n\t\t\tthis.attributes = attrs;\n\t\t\tif (attrs !== was) this.notify('attributes', was, attrs);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tgetClasses: function () {\n\t\treturn this.classes;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tsetClasses: function (classes) {\n\t\tvar was = this.classes;\n\n\t\tthis.classes = classes;\n\t\tif (was != classes) this.notify('classes', was, classes);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tgetStyle: function () {\n\t\treturn this.style;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tsetStyle: function (style) {\n\t\tvar was = this.style;\n\n\t\tthis.style = style;\n\t\tif (was != style) this.notify('style', was, style);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tgetContent: function () {\n\t\treturn this.content;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tsetContent: function (content) {\n\t\tvar was = this.content;\n\t\tthis.content = content;\n\n\t\tif (was != content) this.notify('content', was, content);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tgetShowing: function () {\n\t\treturn this.showing;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tsetShowing: function (showing) {\n\t\tvar was = this.showing;\n\n\t\t// force the showing property to always be a boolean value\n\t\tthis.showing = !! showing;\n\n\t\tif (was != showing) this.notify('showing', was, showing);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tgetAllowHtml: function () {\n\t\treturn this.allowHtml;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tsetAllowHtml: function (allow) {\n\t\tvar was = this.allowHtml;\n\t\tthis.allowHtml = !! allow;\n\n\t\tif (was !== allow) this.notify('allowHtml', was, allow);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tgetCanGenerate: function () {\n\t\treturn this.canGenerate;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tsetCanGenerate: function (can) {\n\t\tvar was = this.canGenerate;\n\t\tthis.canGenerate = !! can;\n\n\t\tif (was !== can) this.notify('canGenerate', was, can);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tgetFit: function () {\n\t\treturn this.fit;\n\t},\n\n\t/**\n\t* @deprecated\n\t* @public\n\t*/\n\tsetFit: function (fit) {\n\t\tvar was = this.fit;\n\t\tthis.fit = !! fit;\n\n\t\tif (was !== fit) this.notify('fit', was, fit);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t* @ares\n\t* @deprecated\n\t* @public\n\t*/\n\tgetIsContainer: function () {\n\t\treturn this.isContainer;\n\t},\n\n\t/**\n\t* @ares\n\t* @deprecated\n\t* @public\n\t*/\n\tsetIsContainer: function (isContainer) {\n\t\tvar was = this.isContainer;\n\t\tthis.isContainer = !! isContainer;\n\n\t\tif (was !== isContainer) this.notify('isContainer', was, isContainer);\n\n\t\treturn this;\n\t}\n\n\t// .................................\n\n});\n\n/**\n* @static\n* @public\n*/\nkind.setDefaultCtor(Control);\n\n/**\n* @static\n* @public\n*/\nControl.renderDelegate = HTMLStringDelegate;\n\n/**\n* @private\n*/\nControl.registerDomEvents = function (id, control) {\n\tdispatcher.$[id] = control;\n};\n\n/**\n* @private\n*/\nControl.unregisterDomEvents = function (id) {\n\tdispatcher.$[id] = null;\n};\n\n/**\n* @private\n*/\nControl.normalizeCssStyleString = function (style) {\n\treturn style ? (\n\t\t(\";\" + style)\n\t\t// add a semi-colon if it's not the last character (also trim possible unnecessary whitespace)\n\t\t.replace(/([^;])\\s*$/, \"$1;\")\n\t\t// ensure we have one space after each colon or semi-colon\n\t\t.replace(/\\s*;\\s*([\\w-]+)\\s*:\\s*/g, \"; $1: \")\n\t\t// remove first semi-colon and space\n\t\t.substr(2).trim()\n\t) : \"\";\n};\n\n/**\n* @private\n*/\nControl.concat = function (ctor, props, instance) {\n\tvar proto = ctor.prototype || ctor,\n\t\tattrs,\n\t\tstr;\n\n\tif (props.classes) {\n\t\tif (instance) {\n\t\t\tstr = (proto.classes ? (proto.classes + ' ') : '') + props.classes;\n\t\t\tproto.classes = str;\n\t\t} else {\n\t\t\tstr = (proto.kindClasses || '') + (proto.classes ? (' ' + proto.classes) : '');\n\t\t\tproto.kindClasses = str;\n\t\t\tproto.classes = props.classes;\n\t\t}\n\t\tdelete props.classes;\n\t}\n\n\tif (props.style) {\n\t\tif (instance) {\n\t\t\tstr = (proto.style ? proto.style : '') + props.style;\n\t\t\tproto.style = Control.normalizeCssStyleString(str);\n\t\t} else {\n\t\t\tstr = proto.kindStyle ? proto.kindStyle : '';\n\t\t\tstr += proto.style ? (';' + proto.style) : '';\n\t\t\tstr += props.style;\n\n\t\t\t// moved it all to kindStyle so that it will be available whenever instanced\n\t\t\tproto.kindStyle = Control.normalizeCssStyleString(str);\n\t\t}\n\t\tdelete props.style;\n\t}\n\n\tif (props.attributes) {\n\t\tattrs = proto.attributes;\n\t\tproto.attributes = attrs ? utils.mixin({}, [attrs, props.attributes]) : props.attributes;\n\t\tdelete props.attributes;\n\t}\n};\n\nControl.prototype.defaultKind = Control;\n\n// Control has to be *completely* set up before creating the floating layer setting up the\n// fullscreen object because fullscreen depends on floating layer which depends on Control.\n\n/**\n* @static\n* @public\n*/\nControl.FloatingLayer = FloatingLayer(Control);\n\n/**\n* @static\n* @public\n*/\nControl.floatingLayer = new Control.FloatingLayer({id: 'floatingLayer'});\n\n/**\n* @static\n* @public\n*/\nControl.Fullscreen = fullscreen(Control);\n",
    "nodeModules": false,
    "relPath": "enyo/Control",
    "requires": [
      "enyo",
      "../kind",
      "../utils",
      "../platform",
      "../dispatcher",
      "../options",
      "../roots",
      "../AccessibilitySupport",
      "../UiComponent",
      "../HTMLStringDelegate",
      "../dom",
      "./fullscreen",
      "./floatingLayer",
      "../gesture"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/lib/enyo/src/Control/fullscreen.less"
    ]
  },
  {
    "path": "./touch",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/touch",
    "name": "enyo/touch",
    "isFile": true,
    "contents": "/**\n* This module has no exports. It merely extends {@link module:enyo/gesture} to enable touch events.\n*\n* @private\n* @module enyo/touch\n*/\nrequire('enyo');\n\nvar\n\tutils = require('./utils'),\n\tgesture = require('./gesture'),\n\tdispatcher = require('./dispatcher'),\n\tplatform = require('./platform');\n\nvar\n\tDom = require('./dom'),\n\tJob = require('./job');\n\nfunction dispatch (e) {\n\treturn dispatcher.dispatch(e);\n}\n\n/**\n* @private\n*/\nDom.requiresWindow(function() {\n\n\t/**\n\t* Add touch-specific gesture feature\n\t* \n\t* @private\n\t*/\n\n\t/**\n\t* @private\n\t*/\n\tvar oldevents = gesture.events;\n\t\n\t/**\n\t* @ignore\n\t*/\n\tgesture.events.touchstart = function (e) {\n\t\t// for duration of this touch, only handle touch events.  Old event\n\t\t// structure will be restored during touchend.\n\t\tgesture.events = touchGesture;\n\t\tgesture.events.touchstart(e);\n\t};\n\t\n\t/**\n\t* @ignore\n\t*/\n\tvar touchGesture = {\n\n\t\t/**\n\t\t* @ignore\n\t\t* @private\n\t\t*/\n\t\t_touchCount: 0,\n\n\t\t/**\n\t\t* @ignore\n\t\t* @private\n\t\t*/\n\t\ttouchstart: function (e) {\n\t\t\tthis._touchCount += e.changedTouches.length;\n\t\t\tthis.excludedTarget = null;\n\t\t\tvar event = this.makeEvent(e);\n\t\t\t//store the finger which generated the touchstart event\n\t\t\tthis.currentIdentifier = event.identifier;\n\t\t\tgesture.down(event);\n\t\t\t// generate a new event object since over is a different event\n\t\t\tevent = this.makeEvent(e);\n\t\t\tthis.overEvent = event;\n\t\t\tgesture.over(event);\n\t\t},\n\n\t\t/**\n\t\t* @ignore\n\t\t* @private\n\t\t*/\n\t\ttouchmove: function (e) {\n\t\t\tJob.stop('resetGestureEvents');\n\t\t\t// NOTE: allow user to supply a node to exclude from event\n\t\t\t// target finding via the drag event.\n\t\t\tvar de = gesture.drag.dragEvent;\n\t\t\tthis.excludedTarget = de && de.dragInfo && de.dragInfo.node;\n\t\t\tvar event = this.makeEvent(e);\n\t\t\t// do not generate the move event if this touch came from a different\n\t\t\t// finger than the starting touch\n\t\t\tif (this.currentIdentifier !== event.identifier) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgesture.move(event);\n\t\t\t// prevent default document scrolling if enyo.bodyIsFitting == true\n\t\t\t// avoid window scrolling by preventing default on this event\n\t\t\t// note: this event can be made unpreventable (native scrollers do this)\n\t\t\tif (Dom.bodyIsFitting) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\t// synthesize over and out (normally generated via mouseout)\n\t\t\tif (this.overEvent && this.overEvent.target != event.target) {\n\t\t\t\tthis.overEvent.relatedTarget = event.target;\n\t\t\t\tevent.relatedTarget = this.overEvent.target;\n\t\t\t\tgesture.out(this.overEvent);\n\t\t\t\tgesture.over(event);\n\t\t\t}\n\t\t\tthis.overEvent = event;\n\t\t},\n\n\t\t/**\n\t\t* @ignore\n\t\t* @private\n\t\t*/\n\t\ttouchend: function (e) {\n\t\t\tgesture.up(this.makeEvent(e));\n\t\t\t// NOTE: in touch land, there is no distinction between\n\t\t\t// a pointer enter/leave and a drag over/out.\n\t\t\t// While it may make sense to send a leave event when a touch\n\t\t\t// ends, it does not make sense to send a dragout.\n\t\t\t// We avoid this by processing out after up, but\n\t\t\t// this ordering is ad hoc.\n\t\t\tgesture.out(this.overEvent);\n\t\t\t// reset the event handlers back to the mouse-friendly ones after\n\t\t\t// a short timeout. We can't do this directly in this handler\n\t\t\t// because it messes up Android to handle the mouseup event.\n\t\t\t// FIXME: for 2.1 release, conditional on platform being\n\t\t\t// desktop Chrome, since we're seeing issues in PhoneGap with this\n\t\t\t// code.\n\t\t\tthis._touchCount -= e.changedTouches.length;\n\t\t},\n\n\t\t/**\n\t\t* Use `mouseup()` after touches are done to reset {@glossary event} handling \n\t\t* back to default; this works as long as no one did a `preventDefault()` on\n\t\t* the touch events.\n\t\t* \n\t\t* @ignore\n\t\t* @private\n\t\t*/\n\t\tmouseup: function () {\n\t\t\tif (this._touchCount === 0) {\n\t\t\t\tthis.sawMousedown = false;\n\t\t\t\tgesture.events = oldevents;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t* @ignore\n\t\t* @private\n\t\t*/\n\t\tmakeEvent: function (e) {\n\t\t\tvar event = utils.clone(e.changedTouches[0]);\n\t\t\tevent.srcEvent = e;\n\t\t\tevent.target = this.findTarget(event);\n\t\t\t// normalize \"mouse button\" info\n\t\t\tevent.which = 1;\n\t\t\t//enyo.log(\"target for \" + inEvent.type + \" at \" + e.pageX + \", \" + e.pageY + \" is \" + (e.target ? e.target.id : \"none\"));\n\t\t\treturn event;\n\t\t},\n\n\t\t/**\n\t\t* @ignore\n\t\t* @private\n\t\t*/\n\t\tcalcNodeOffset: function (node) {\n\t\t\tif (node.getBoundingClientRect) {\n\t\t\t\tvar o = node.getBoundingClientRect();\n\t\t\t\treturn {\n\t\t\t\t\tleft: o.left,\n\t\t\t\t\ttop: o.top,\n\t\t\t\t\twidth: o.width,\n\t\t\t\t\theight: o.height\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t* @ignore\n\t\t* @private\n\t\t*/\n\t\tfindTarget: function (e) {\n\t\t\treturn document.elementFromPoint(e.clientX, e.clientY);\n\t\t},\n\n\t\t/**\n\t\t* NOTE: Will find only 1 element under the touch and will fail if an element is \n\t\t* positioned outside the bounding box of its parent.\n\t\t* \n\t\t* @ignore\n\t\t* @private\n\t\t*/\n\t\tfindTargetTraverse: function (node, x, y) {\n\t\t\tvar n = node || document.body;\n\t\t\tvar o = this.calcNodeOffset(n);\n\t\t\tif (o && n != this.excludedTarget) {\n\t\t\t\tvar adjX = x - o.left;\n\t\t\t\tvar adjY = y - o.top;\n\t\t\t\t//enyo.log(\"test: \" + n.id + \" (left: \" + o.left + \", top: \" + o.top + \", width: \" + o.width + \", height: \" + o.height + \")\");\n\t\t\t\tif (adjX>0 && adjY>0 && adjX<=o.width && adjY<=o.height) {\n\t\t\t\t\t//enyo.log(\"IN: \" + n.id + \" -> [\" + adjX + \",\" + adjY + \" in \" + o.width + \"x\" + o.height + \"] (children: \" + n.childNodes.length + \")\");\n\t\t\t\t\tvar target;\n\t\t\t\t\tfor (var n$=n.childNodes, i=n$.length-1, c; (c=n$[i]); i--) {\n\t\t\t\t\t\ttarget = this.findTargetTraverse(c, x, y);\n\t\t\t\t\t\tif (target) {\n\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t* @ignore\n\t\t* @private\n\t\t*/\n\t\tconnect: function () {\n\t\t\tutils.forEach(['touchstart', 'touchmove', 'touchend', 'gesturestart', 'gesturechange', 'gestureend'], function(e) {\n\t\t\t\t// on iOS7 document.ongesturechange is never called\n\t\t\t\tdocument.addEventListener(e, dispatch, false);\n\t\t\t});\n\n\t\t\tif (platform.androidChrome <= 18 || platform.silk === 2) {\n\t\t\t\t// HACK: on Chrome for Android v18 on devices with higher density displays,\n\t\t\t\t// document.elementFromPoint expects screen coordinates, not document ones\n\t\t\t\t// bug also appears on Kindle Fire HD\n\t\t\t\tthis.findTarget = function(e) {\n\t\t\t\t\treturn document.elementFromPoint(e.screenX, e.screenY);\n\t\t\t\t};\n\t\t\t} else if (!document.elementFromPoint) {\n\t\t\t\tthis.findTarget = function(e) {\n\t\t\t\t\treturn this.findTargetTraverse(null, e.clientX, e.clientY);\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t};\n\t\n\ttouchGesture.connect();\n});\n",
    "mtime": 1542469884715,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/touch.js",
    "relPath": "enyo/touch",
    "requires": [
      "enyo",
      "./utils",
      "./gesture",
      "./dispatcher",
      "./platform",
      "./dom",
      "./job"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./ViewController",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/ViewController",
    "name": "enyo/ViewController",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/ViewController~ViewController} kind.\n* @module enyo/ViewController\n*/\n\n// needed so that the default kind is Control instead of Component, if it isn't required elsewhere\nrequire('./Control');\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils');\n\nvar\n\tController = require('./Controller'),\n\tUiComponent = require('./UiComponent');\n\nvar\n\tDom = require('./dom');\n\n/**\n* {@link module:enyo/ViewController~ViewController} is designed to manage the lifecycle of a particular view\n* ({@link module:enyo/Control~Control}) that it owns. It is capable of controlling when a view is inserted into\n* the DOM and where, managing [events]{@glossary event} bubbled from the view, and isolating (or\n* encapsulating) the entire view hierarchy below it. Alternatively, it may be implemented as a\n* [component]{@link module:enyo/Component~Component} in a larger hierarchy, in which case it will inject its view\n* into its parent rather than directly into the DOM. And, of course, a ViewController may be\n* used as the `controller` property of another view, although this usage will (by default)\n* result in the removal of its own view from the {@link module:enyo/Component~Component} bubbling hierarchy.\n*\n* Note that `enyo/ViewController` may have components defined in its\n* `components` [array]{@glossary Array}, but these components should\n* not be instances of `enyo/Control`.\n*\n* @class ViewController\n* @extends module:enyo/Controller~Controller\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/ViewController~ViewController.prototype */ {\n\n\tname: 'enyo.ViewController',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Controller,\n\n\t/**\n\t* The `view` property may either be a [constructor]{@glossary constructor}, an\n\t* instance of {@link module:enyo/Control~Control}, an [object]{@glossary Object}\n\t* description of the view ([object literal/hash]), or `null` if it will be\n\t* set later. Setting this property to a constructor or string naming a kind\n\t* will automatically create an instance of that kind according to this\n\t* controller's settings. If the `view` is set to an instance, it will be\n\t* rendered according to the properties of the controller. If this property\n\t* is a constructor, it will be preserved in the\n\t* [viewKind]{@link module:enyo/ViewController~ViewController#viewKind} property. Once\n\t* initialization is complete, the instance of this controller's view will be\n\t* available via this property.\n\t*\n\t* @type {Control|Function|Object}\n\t* @default null\n\t* @public\n\t*/\n\tview: null,\n\n\t/**\n\t* The preserved [kind]{@glossary kind} for this controller's view. You may\n\t* set this to a [constructor]{@glossary constructor} (or the\n\t* [view]{@link module:enyo/ViewController~ViewController#view} property). In either case, if a\n\t* view is set explicitly or this property is used, the constructor will be\n\t* available via this property.\n\t*\n\t* @type {Function}\n\t* @default null\n\t* @public\n\t*/\n\tviewKind: null,\n\n\t/**\n\t* Designates where the controller's view will render. This should be a\n\t* string consisting of either `'document.body'` (the default) or the DOM id\n\t* of a node (either inserted by an {@link module:enyo/Control~Control} or static HTML\n\t* already in the `document.body`). If the controller has a parent (because\n\t* it was instantiated as a component in an `enyo/Control`, this property\n\t* will be ignored and the view will instead be rendered in the parent. This\n\t* will not happen if the controller is a component of {@link module:enyo/Component~Component}\n\t* or is set as the `controller` property of an `enyo/Control`.\n\t*\n\t* @type {String}\n\t* @default 'document.body'\n\t* @public\n\t*/\n\trenderTarget: 'document.body',\n\n\t/**\n\t* When the view of the controller has its [destroy()]{@link module:enyo/Control~Control#destroy}\n\t* method called, it automatically triggers its own removal from the controller's\n\t* [view]{@link module:enyo/ViewController~ViewController#view} property. By default, the controller\n\t* will not create a new view (from [viewKind]{@link module:enyo/ViewController~ViewController#viewKind})\n\t* automatically unless this flag is set to `true`.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\tresetView: false,\n\n\t/**\n\t* Renders the controller's view, if possible. If the controller is a\n\t* component of a [UiComponent]{@link module:enyo/UiComponent~UiComponent}, the view will be\n\t* rendered into its container; otherwise, the view will be rendered into the\n\t* controller's [renderTarget]{@link module:enyo/ViewController~ViewController#renderTarget}. If\n\t* the view is already rendered, this method will do nothing.\n\t*\n\t* @param {String} [target] - When specified, this value will be used instead of\n\t*\t[renderTarget]{@link module:enyo/ViewController~ViewController#renderTarget}.\n\t* @public\n\t*/\n\trender: function (target) {\n\t\tvar v = this.view,\n\t\t\tt = target || this.renderTarget;\n\t\tif (v) {\n\t\t\tif (v.hasNode() && v.generated) { return; }\n\t\t\t// here we test to see if we need to render it into our target node or the container\n\t\t\tif (this.container) {\n\t\t\t\tv.render();\n\t\t\t} else {\n\t\t\t\tv.renderInto(Dom.byId(t) || utils.getPath.call(window, t));\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Renders the view into the specified `target` and sets the\n\t* [renderTarget]{@link module:enyo/ViewController~ViewController#renderTarget} property to\n\t* `target`.\n\t*\n\t* @param {String} target - Where the view will be rendered into.\n\t* @public\n\t*/\n\trenderInto: function (target) {\n\t\tthis.render((this.renderTarget=target));\n\t},\n\n\t/**\n\t* Responds to changes in the controller's [view]{@link module:enyo/ViewController~ViewController#view}\n\t* property during initialization or whenever `set('view', ...)` is called.\n\t* If a [constructor]{@glossary constructor} is found, it will be instanced\n\t* or resolved from a [string]{@glossary String}. If a previous view exists\n\t* and the controller is its [owner]{@link module:enyo/Component~Component#owner}, it will be\n\t* destroyed; otherwise, it will simply be removed.\n\t*\n\t* @private\n\t*/\n\tviewChanged: function (previous) {\n\t\tif (previous) {\n\t\t\tprevious.set('bubbleTarget', null);\n\t\t\tif (previous.owner === this && !previous.destroyed) {\n\t\t\t\tprevious.destroy();\n\t\t\t}\n\t\t\tif (previous.destroyed && !this.resetView) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tvar v = this.view;\n\n\t\t// if it is a function we need to instance it\n\t\tif (typeof v == 'function') {\n\t\t\t// save the constructor for later\n\t\t\tthis.viewKind = v;\n\t\t\tv = null;\n\t\t}\n\n\t\tif ((!v && this.viewKind) || (v && typeof v == 'object' && !(v instanceof UiComponent))) {\n\t\t\tvar d = (typeof v == 'object' && v !== null && !v.destroyed && v) || {kind: this.viewKind},\n\t\t\t\ts = this;\n\t\t\t// in case it isn't set...\n\t\t\td.kind = d.kind || this.viewKind || kind.getDefaultCtor();\n\t\t\tv = this.createComponent(d, {\n\t\t\t\towner: this,\n\t\t\t\t// if this controller is a component of a UiComponent kind then it\n\t\t\t\t// will have assigned a container that we can add to the child\n\t\t\t\t// so it will register as a child and control to be rendered in the\n\t\t\t\t// correct location\n\t\t\t\tcontainer: this.container || null,\n\t\t\t\tbubbleTarget: this\n\t\t\t});\n\t\t\tv.extend({\n\t\t\t\tdestroy: kind.inherit(function (sup) {\n\t\t\t\t\treturn function () {\n\t\t\t\t\t\tsup.apply(this, arguments);\n\t\t\t\t\t\t// if the bubble target is the view contorller then we need to\n\t\t\t\t\t\t// let it know we've been destroyed\n\t\t\t\t\t\tif (this.bubbleTarget === s) {\n\t\t\t\t\t\t\tthis.bubbleTarget.set('view', null);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t});\n\t\t} else if (v && v instanceof UiComponent) {\n\t\t\t// make sure we grab the constructor from an instance so we know what kind\n\t\t\t// it was to recreate later if necessary\n\t\t\tif (!this.viewKind) {\n\t\t\t\tthis.viewKind = v.ctor;\n\t\t\t}\n\t\t\tv.set('bubbleTarget', this);\n\t\t}\n\t\tthis.view = v;\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.viewChanged();\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tthis.view = null;\n\t\t\tthis.viewKind = null;\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\t/**\n\t\tThe `controller` can't be the instance owner of its child view for event\n\t\tpropagation reasons. When this flag is `true`, it ensures that events will\n\t\tnot be handled multiple times (by the `controller` and its `view`\n\t\tseparately).\n\t*/\n\tnotInstanceOwner: true\n});\n",
    "mtime": 1542469884587,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ViewController.js",
    "relPath": "enyo/ViewController",
    "requires": [
      "enyo",
      "./Control",
      "./kind",
      "./utils",
      "./Controller",
      "./UiComponent",
      "./dom"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "../ScrollStrategy",
    "base": "/home/udo/git/NCPV/lib/enyo/src/Scroller",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/ScrollStrategy",
    "name": "enyo/ScrollStrategy",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/ScrollStrategy~ScrollStrategy} kind.\n* @module enyo/ScrollStrategy\n*/\n\nvar\n\tkind = require('./kind'),\n\tdispatcher = require('./dispatcher');\n\nvar\n\tControl = require('./Control');\n\n/**\n* {@link module:enyo/ScrollStrategy~ScrollStrategy} is a helper [kind]{@glossary kind} that implements a default \n* scrolling strategy for an {@link module:enyo/Scroller~Scroller}.\n* \n* `enyo/ScrollStrategy` is not typically created in application code. Instead, it is specified \n* as the value of the [strategyKind]{@link module:enyo/Scroller~Scroller#strategyKind} property of an\n* `enyo/Scroller` or {@link module:layout/List~List}, or is used by the framework implicitly.\n*\n* @class ScrollStrategy\n* @protected\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/ScrollStrategy~ScrollStrategy.prototype */ {\n\n\tname: 'enyo.ScrollStrategy',\n\n\tkind: Control,\n\n\t/**\n\t* @private\n\t*/\n\ttag: null,\n\n\t/**\n\t* @private\n\t*/\n\tpublished: \n\t\t/** @lends module:enyo/ScrollStrategy~ScrollStrategy.prototype */ {\n\t\t\n\t\t/**\n\t\t* Specifies how to vertically scroll.  Acceptable values are `'scroll'`, `'auto'`,\n\t\t* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the\n\t\t* scroll strategy.\n\t\t* \n\t\t* @type {String}\n\t\t* @default 'default'\n\t\t* @public\n\t\t*/\n\t\tvertical: 'default',\n\t\t\n\t\t/**\n\t\t* Specifies how to horizontally scroll.  Acceptable values are `'scroll'`, `'auto'`,\n\t\t* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the\n\t\t* scroll strategy.\n\t\t* \n\t\t* @type {String}\n\t\t* @default 'default'\n\t\t* @public\n\t\t*/\n\t\thorizontal: 'default',\n\t\t\n\t\t/**\n\t\t* The horizontal scroll position.\n\t\t* \n\t\t* @type {Number}\n\t\t* @default 0\n\t\t* @public\n\t\t*/\n\t\tscrollLeft: 0,\n\t\t\n\t\t/**\n\t\t* The vertical scroll position.\n\t\t* \n\t\t* @type {Number}\n\t\t* @default 0\n\t\t* @public\n\t\t*/\n\t\tscrollTop: 0,\n\t\t\n\t\t/**\n\t\t* Maximum height of the scroll content.\n\t\t* \n\t\t* @type {Number}\n\t\t* @default null\n\t\t* @public\n\t\t*/\n\t\tmaxHeight: null,\n\t\t\n\t\t/**\n\t\t* Indicates whether mouse wheel may be used to move the [scroller]{@link module:enyo/Scroller~Scroller}.\n\t\t* \n\t\t* @type {Boolean}\n\t\t* @default true\n\t\t* @public\n\t\t*/\n\t\tuseMouseWheel: true\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tevents: {\n\t\tonScrollStart: '',\n\t\tonScrollStop: ''\n\t},\n\n\t/**\n\t* @private\n\t*/\n\thandlers: {\n\t\tondragstart: 'dragstart',\n\t\tondragfinish: 'dragfinish',\n\t\tondown: 'down',\n\t\tonmove: 'move',\n\t\tonmousewheel: 'mousewheel',\n\t\tonscroll: 'domScroll'\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.horizontalChanged();\n\t\t\tthis.verticalChanged();\n\t\t\tthis.maxHeightChanged();\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\trendered: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tdispatcher.makeBubble(this.container, 'scroll');\n\t\t\tthis.scrollNode = this.calcScrollNode();\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tteardownRender: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.scrollNode = null;\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tcalcScrollNode: function () {\n\t\treturn this.container.hasNode();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\thorizontalChanged: function () {\n\t\tthis.container.applyStyle('overflow-x', this.horizontal == 'default' ? 'auto' : this.horizontal);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tverticalChanged: function () {\n\t\tthis.container.applyStyle('overflow-y', this.vertical == 'default' ? 'auto' : this.vertical);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmaxHeightChanged: function () {\n\t\tthis.container.applyStyle('max-height', this.maxHeight);\n\t},\n\n\t/** \n\t* Scrolls to the specified position.\n\t*\n\t* @param {Number} x - The `x` position in pixels.\n\t* @param {Number} y - The `y` position in pixels.\n\t* @public\n\t*/\n\tscrollTo: function (x, y) {\n\t\tif (this.scrollNode) {\n\t\t\tthis.setScrollLeft(x);\n\t\t\tthis.setScrollTop(y);\n\t\t}\n\t},\n\n\t/** \n\t* Ensures that the given node is visible in the [scroller's]{@link module:enyo/Scroller~Scroller} viewport.\n\t*\n\t* @param {Node} node - The node to make visible in the [scroller's]{@link module:enyo/Scroller~Scroller}\n\t*\tviewport.\n\t* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top of the\n\t*\tscroller.\n\t* @public\n\t*/\n\tscrollToNode: function (node, alignWithTop) {\n\t\tif (this.scrollNode) {\n\t\t\tvar sb = this.getScrollBounds();\n\t\t\tvar n = node;\n\t\t\tvar b = {height: n.offsetHeight, width: n.offsetWidth, top: 0, left: 0};\n\t\t\twhile (n && n.parentNode && n.id != this.scrollNode.id) {\n\t\t\t\tb.top += n.offsetTop;\n\t\t\t\tb.left += n.offsetLeft;\n\t\t\t\tn = n.parentNode;\n\t\t\t}\n\t\t\t// By default, the element is scrolled to align with the top of the scroll area.\n\t\t\tthis.setScrollTop(Math.min(sb.maxTop, alignWithTop === false ? b.top - sb.clientHeight + b.height : b.top));\n\t\t\tthis.setScrollLeft(Math.min(sb.maxLeft, alignWithTop === false ? b.left - sb.clientWidth + b.width : b.left));\n\t\t}\n\t},\n\n\t/**\n\t* Scrolls the given [control]{@link module:enyo/Control~Control} into view.\n\t*\n\t* @param {module:enyo/Control~Control} ctl - The [control]{@link module:enyo/Control~Control} to make visible in the\n\t*\t[scroller's]{@link module:enyo/Scroller~Scroller} viewport.\n\t* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top of the\n\t*\tscroller.\n\t* @public\n\t*/\n\tscrollIntoView: function (ctl, alignWithTop) {\n\t\tif (ctl.hasNode()) {\n\t\t\tctl.node.scrollIntoView(alignWithTop);\n\t\t}\n\t},\n\tisInView: function(inNode) {\n\t\tvar sb = this.getScrollBounds();\n\t\tvar ot = inNode.offsetTop;\n\t\tvar oh = inNode.offsetHeight;\n\t\tvar ol = inNode.offsetLeft;\n\t\tvar ow = inNode.offsetWidth;\n\t\treturn (ot >= sb.top && ot + oh <= sb.top + sb.clientHeight) && (ol >= sb.left && ol + ow <= sb.left + sb.clientWidth);\n\t},\n\n\t/**\n\t* Sets the vertical scroll position.\n\t*\n\t* @param {Number} top - The vertical scroll position in pixels.\n\t* @public\n\t*/\n\tsetScrollTop: function (top) {\n\t\tthis.scrollTop = top;\n\t\tif (this.scrollNode) {\n\t\t\tthis.scrollNode.scrollTop = this.scrollTop;\n\t\t}\n\t},\n\n\t/**\n\t* Sets the horizontal scroll position.\n\t*\n\t* @param {Number} left - The horizontal scroll position in pixels.\n\t* @public\n\t*/\n\tsetScrollLeft: function (left) {\n\t\tthis.scrollLeft = left;\n\t\tif (this.scrollNode) {\n\t\t\tthis.scrollNode.scrollLeft = this.scrollLeft;\n\t\t}\n\t},\n\n\t/**\n\t* Retrieves the horizontal scroll position.\n\t*\n\t* @returns {Number} The horizontal scroll position in pixels.\n\t* @public\n\t*/\n\tgetScrollLeft: function () {\n\t\treturn this.scrollNode ? this.scrollNode.scrollLeft : this.scrollLeft;\n\t},\n\n\t/**\n\t* Retrieves the vertical scroll position.\n\t*\n\t* @returns {Number} The vertical scroll position in pixels.\n\t* @private\n\t*/\n\tgetScrollTop: function () {\n\t\treturn this.scrollNode ? this.scrollNode.scrollTop : this.scrollTop;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\t_getScrollBounds: function () {\n\t\tvar s = this.getScrollSize(), cn = this.container.hasNode();\n\t\tvar b = {\n\t\t\tleft: this.getScrollLeft(),\n\t\t\ttop: this.getScrollTop(),\n\t\t\tclientHeight: cn ? cn.clientHeight : 0,\n\t\t\tclientWidth: cn ? cn.clientWidth : 0,\n\t\t\theight: s.height,\n\t\t\twidth: s.width\n\t\t};\n\t\tb.maxLeft = Math.max(0, b.width - b.clientWidth);\n\t\tb.maxTop = Math.max(0, b.height - b.clientHeight);\n\t\treturn b;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetScrollSize: function () {\n\t\tvar n = this.scrollNode;\n\t\treturn {width: n ? n.scrollWidth : 0, height: n ? n.scrollHeight : 0};\n\t},\n\n\t/**\n\t* Retrieves the scroll boundaries of the [scroller]{@link module:enyo/Scroller~Scroller}.\n\t* \n\t* @returns {module:enyo/Scroller~Scroller~BoundaryObject} An [object]{@glossary Object} describing the\n\t*\tscroll boundaries.\n\t* @public\n\t*/\n\tgetScrollBounds: function () {\n\t\treturn this._getScrollBounds();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcalcStartInfo: function () {\n\t\tvar sb = this.getScrollBounds();\n\t\tvar y = this.getScrollTop(), x = this.getScrollLeft();\n\t\tthis.canVertical = sb.maxTop > 0 && this.vertical != 'hidden';\n\t\tthis.canHorizontal = sb.maxLeft > 0 && this.horizontal != 'hidden';\n\t\tthis.startEdges = {\n\t\t\ttop: y === 0,\n\t\t\tbottom: y === sb.maxTop,\n\t\t\tleft: x === 0,\n\t\t\tright: x === sb.maxLeft\n\t\t};\n\t},\n\n\t// NOTE: down, move, and drag handlers are needed only for native touch scrollers\n\n\t/**\n\t* @private\n\t*/\n\tshouldDrag: function (e) {\n\t\tvar requestV = e.vertical;\n\t\treturn (requestV && this.canVertical  || !requestV && this.canHorizontal) /*&& !this.isOobVerticalScroll(event)*/;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdragstart: function (sender, e) {\n\t\tthis.dragging = this.shouldDrag(e);\n\t\tif (this.dragging) {\n\t\t\treturn this.preventDragPropagation;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdragfinish: function (sender, e) {\n\t\tif (this.dragging) {\n\t\t\tthis.dragging = false;\n\t\t\te.preventTap();\n\t\t}\n\t},\n\n\t/**\n\t* Avoid allowing scroll when starting at a vertical boundary to prevent iOS from window \n\t* scrolling.\n\t* \n\t* @private\n\t*/\n\tdown: function (sender, e) {\n\t\tif (this.isScrolling()) {\n\t\t\te.preventTap();\n\t\t}\n\t\tthis.calcStartInfo();\n\t},\n\n\t/**\n\t* NOTE: Mobile native [scrollers]{@link module:enyo/Scroller~Scroller} need `touchmove`. Indicate this by \n\t* setting the `requireTouchmove` property to `true`.\n\t* \n\t* @private\n\t*/\n\tmove: function (sender, e) {\n\t\tif (e.which && (this.canVertical && e.vertical || this.canHorizontal && e.horizontal)) {\n\t\t\te.disablePrevention();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmousewheel: function (sender, e) {\n\t\t//* We disable mouse wheel scrolling by preventing the default\n\t\tif (!this.useMouseWheel) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdomScroll: function(sender, e) {\n\t\tif (!this._scrolling) {\n\t\t\tthis.doScrollStart();\n\t\t}\n\t\tthis._scrolling = true;\n\t\tthis.startJob('stopScrolling', function() {\n\t\t\tthis._scrolling = false;\n\t\t\tthis.doScrollStop();\n\t\t}, 100);\n\t},\n\n\t/**\n\t* @public\n\t*/\n\tisScrolling: function() {\n\t\treturn this._scrolling;\n\t}\n});\n",
    "mtime": 1542469884423,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ScrollStrategy.js",
    "relPath": "enyo/ScrollStrategy",
    "requires": [
      "enyo",
      "./kind",
      "./dispatcher",
      "./Control"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./ScrollThumb",
    "base": "/home/udo/git/NCPV/lib/enyo/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/ScrollThumb",
    "name": "enyo/ScrollThumb",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ScrollThumb",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/enyo/src/ScrollThumb/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/enyo/src/ScrollThumb/package.json": 1542469884435,
      "/home/udo/git/NCPV/lib/enyo/src/ScrollThumb/ScrollThumb.js": 1542469884431
    },
    "json": {
      "main": "ScrollThumb.js",
      "styles": [
        "ScrollThumb.css"
      ]
    },
    "main": "/home/udo/git/NCPV/lib/enyo/src/ScrollThumb/ScrollThumb.js",
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/ScrollThumb~ScrollThumb} kind.\n* @module enyo/ScrollThumb\n*/\n\nvar\n\tkind = require('../kind');\n\nvar\n\tControl = require('../Control'),\n\tDom = require('../dom');\n\n/**\n* {@link module:enyo/ScrollThumb~ScrollThumb} is a helper [kind]{@glossary kind} used by \n* {@link module:enyo/TouchScrollStrategy~TouchScrollStrategy} and {@link module:enyo/TranslateScrollStrategy~TranslateScrollStrategy} to\n* display a small visual scroll indicator.\n* \n* `enyo/ScrollThumb` is not typically created in application code.\n*\n* @class ScrollThumb\n* @protected\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/ScrollThumb~ScrollThumb.prototype */ {\n\t\n\tname: 'enyo.ScrollThumb',\n\t\n\tkind: Control,\n\n\t/**\n\t* The orientation of the scroll indicator bar; 'v' for vertical or 'h' for horizontal.\n\t* \n\t* @type {String}\n\t* @default 'v'\n\t* @public\n\t*/\n\taxis: 'v',\n\n\t/**\n\t* Minimum size of the indicator.\n\t* \n\t* @private\n\t*/\n\tminSize: 4,\n\n\t/**\n\t* Size of the indicator's corners.\n\t* \n\t* @private\n\t*/\n\tcornerSize: 6,\n\n\t/**\n\t* @private\n\t*/\n\tclasses: 'enyo-thumb',\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tvar v = this.axis == 'v';\n\t\t\tthis.dimension = v ? 'height' : 'width';\n\t\t\tthis.offset = v ? 'top' : 'left';\n\t\t\tthis.translation = v ? 'translateY' : 'translateX';\n\t\t\tthis.positionMethod = v ? 'getScrollTop' : 'getScrollLeft';\n\t\t\tthis.sizeDimension = v ? 'clientHeight' : 'clientWidth';\n\t\t\tthis.addClass('enyo-' + this.axis + 'thumb');\n\t\t\tthis.transform = Dom.canTransform();\n\t\t\tif (Dom.canAccelerate()) {\n\t\t\t\tDom.transformValue(this, 'translateZ', 0);\n\t\t\t}\n\t\t};\n\t}),\n\n\t/** \n\t* Syncs the scroll indicator bar to the [scroller]{@link module:enyo/Scroller~Scroller} size and position,\n\t* as determined by the passed-in scroll strategy.\n\t*\n\t* @param {module:enyo/ScrollStrategy~ScrollStrategy} strategy - The scroll strategy to be synced with.\n\t* @public\n\t*/\n\tsync: function (strategy) {\n\t\tthis.scrollBounds = strategy._getScrollBounds();\n\t\tthis.update(strategy);\n\t},\n\n\t/**\n\t* Updates the scroll indicator bar based on the scroll bounds of the strategy, the available\n\t* scroll area, and whether there is overscrolling. If the scroll indicator bar is not\n\t* needed, it will be not be displayed.\n\t* \n\t* @param {module:enyo/ScrollStrategy~ScrollStrategy} strategy - The scroll strategy to update from.\n\t* @public\n\t*/\n\tupdate: function (strategy) {\n\t\tif (this.showing) {\n\t\t\tvar d = this.dimension, o = this.offset;\n\t\t\tvar bd = this.scrollBounds[this.sizeDimension], sbd = this.scrollBounds[d];\n\t\t\tvar overs = 0, overp = 0, over = 0;\n\t\t\tif (bd >= sbd) {\n\t\t\t\tthis.hide();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (strategy.isOverscrolling()) {\n\t\t\t\tover = strategy.getOverScrollBounds()['over' + o];\n\t\t\t\tovers = Math.abs(over);\n\t\t\t\toverp = Math.max(over, 0);\n\t\t\t}\n\t\t\tvar sbo = strategy[this.positionMethod]() - over;\n\t\t\t// calc size & position\n\t\t\tvar bdc = bd - this.cornerSize;\n\t\t\tvar s = Math.floor((bd * bd / sbd) - overs);\n\t\t\ts = Math.max(this.minSize, s);\n\t\t\tvar p = Math.floor((bdc * sbo / sbd) + overp);\n\t\t\tp = Math.max(0, Math.min(bdc - this.minSize, p));\n\t\t\t// apply thumb styling\n\t\t\tthis.needed = s < bd;\n\t\t\tif (this.needed && this.hasNode()) {\n\t\t\t\tif (this._pos !== p) {\n\t\t\t\t\tthis._pos = p;\n\t\t\t\t\tif(!this.transform) {\n\t\t\t\t\t\t//adjust top/left for browsers that don't support translations\n\t\t\t\t\t\tif(this.axis=='v') {\n\t\t\t\t\t\t\tthis.setBounds({top:p + 'px'});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.setBounds({left:p + 'px'});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDom.transformValue(this, this.translation, p + 'px');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this._size !== s) {\n\t\t\t\t\tthis._size = s;\n\t\t\t\t\tthis.applyStyle(d, s + 'px');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.hide();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* We implement `setShowing()` and cancel the [delayHide()]{@link module:enyo/ScrollThumb~ScrollThumb#delayHide} \n\t* because [showing]{@link module:enyo/Control~Control#showing} is not changed while we execute\n\t* `delayHide()`.\n\t*\n\t* @param {Boolean} showing - If `true`, displays the {@link module:enyo/ScrollThumb~ScrollThumb} if appropriate;\n\t*\totherwise, hides the ScrollThumb.\n\t* @public\n\t*/\n\tsetShowing: function (showing) {\n\t\tif (showing && showing != this.showing) {\n\t\t\tif (this.scrollBounds[this.sizeDimension] >= this.scrollBounds[this.dimension]) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (this.hasNode()) {\n\t\t\tthis.cancelDelayHide();\n\t\t}\n\t\tif (showing != this.showing) {\n\t\t\tvar last = this.showing;\n\t\t\tthis.showing = showing;\n\t\t\tthis.showingChanged(last);\n\t\t}\n\t},\n\n\t/**\n\t* Delays automatic hiding of the {@link module:enyo/ScrollThumb~ScrollThumb}.\n\t*\n\t* @param {Number} delay - The number of milliseconds to delay hiding of the\n\t*\t{@link module:enyo/ScrollThumb~ScrollThumb}.\n\t* @public\n\t*/\n\tdelayHide: function (delay) {\n\t\tif (this.showing) {\n\t\t\tthis.startJob('hide', this.hide, delay || 0);\n\t\t}\n\t},\n\n\t/**\n\t* Cancels any pending [delayHide()]{@link module:enyo/ScrollThumb~ScrollThumb#delayHide} jobs.\n\t* \n\t* @public\n\t*/\n\tcancelDelayHide: function () {\n\t\tthis.stopJob('hide');\n\t}\n});\n",
    "nodeModules": false,
    "relPath": "enyo/ScrollThumb",
    "requires": [
      "enyo",
      "../kind",
      "../Control",
      "../dom"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/lib/enyo/src/ScrollThumb/ScrollThumb.css"
    ]
  },
  {
    "path": "../GroupItem",
    "base": "/home/udo/git/NCPV/lib/enyo/src/ToolDecorator",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/GroupItem",
    "name": "enyo/GroupItem",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/GroupItem~GroupItem} kind.\n* @module enyo/GroupItem\n*/\n\nvar\n\tkind = require('./kind');\nvar\n\tControl = require('./Control');\n\n/**\n* Fires when the [active state]{@link module:enyo/GroupItem~GroupItem#active} has changed.\n*\n* @event module:enyo/GroupItem~GroupItem#onActivate\n* @type {Object}\n* @property {Object} sender - The [component]{@link module:enyo/Component~Component} that most recently\n*\tpropagated the {@glossary event}.\n* @property {Object} event - An [object]{@glossary Object} containing event information.\n* @public\n*/\n\n/**\n* {@link module:enyo/GroupItem~GroupItem} is the base [kind]{@glossary kind} for the\n* [Grouping]{@link module:enyo/Group~Group} API. It manages the\n* [active state]{@link module:enyo/GroupItem~GroupItem#active} of the [component]{@link module:enyo/Component~Component}\n* (or the [inheriting]{@glossary subkind} component). A subkind may call `setActive()` \n* to set the [active]{@link module:enyo/GroupItem~GroupItem#active} property to the desired state; this\n* will additionally [bubble]{@link module:enyo/Component~Component#bubble} an \n* [onActivate]{@link module:enyo/GroupItem~GroupItem#onActivate} {@glossary event}, which may\n* be handled as needed by the containing components. This is useful for creating\n* groups of items whose state should be managed collectively.\n*\n* For an example of how this works, see the {@link module:enyo/Group~Group} kind, which enables the\n* creation of radio groups from arbitrary components that\tsupport the Grouping API.\n*\n* @class GroupItem\n* @extends module:enyo/Control~Control\n* @ui\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/Groupitem~Groupitem.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.GroupItem',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Control,\n\n\t/**\n\t* @private\n\t*/\n\tpublished: \n\t\t/** @lends module:enyo/Groupitem~Groupitem.prototype */ {\n\n\t\t/**\n\t\t* Will be `true` if the item is currently selected.\n\t\t* \n\t\t* @type {Boolean}\n\t\t* @default false\n\t\t* @public\n\t\t*/\n\t\tactive: false\n\t},\n\t\n\t/**\n\t* @method\n\t* @private\n\t*/\n\trendered: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.activeChanged();\n\t\t};\n\t}),\n\n\t/**\n\t* @fires module:enyo/GroupItem~GroupItem#onActivate\n\t* @private\n\t*/\n\tactiveChanged: function () {\n\t\tthis.bubble('onActivate');\n\t}\n});\n",
    "mtime": 1542469884183,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/GroupItem.js",
    "relPath": "enyo/GroupItem",
    "requires": [
      "enyo",
      "./kind",
      "./Control"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "enyo/Application",
    "base": "/home/udo/git/NCPV/src",
    "external": true,
    "relName": "enyo/Application",
    "name": "enyo/Application",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/Application~Application} kind.\n* @module enyo/Application\n*/\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils'),\n\tmaster = require('./master');\n\nvar \n\tViewController = require('./ViewController'),\n\tController = require('./Controller');\n\nvar \n\tapplications = {};\n\n/**\n* {@link module:enyo/Application~Application} is a type of {@link module:enyo/ViewController~ViewController} that\n* encapsulates a collection of [controllers]{@link module:enyo/Controller~Controller} and a\n* hierarchy of [controls]{@link module:enyo/Control~Control}. There may be multiple instances\n* of an [application]{@link module:enyo/Application~Application} at a given time, with unique\n* names and target [DOM nodes]{@glossary Node}. Within a given application, a\n* reference to the application is available on all [components]{@link module:enyo/Component~Component}\n* via the [app]{@link module:enyo/ApplicationSupport#app} property.\n*\n* @class Application\n* @extends module:enyo/ViewController~ViewController\n* @public\n*/\nexports = module.exports = kind(\n\t/** @lends module:enyo/Application~Application.prototype */ {\n\t\n\tname: 'enyo.Application',\n\t\n\t/**\n\t* @private\n\t*/\n\tkind: ViewController,\n\t\n\t/**\n\t* If set to `true` (the default), the [application's]{@link module:enyo/Application~Application}\n\t* [start()]{@link module:enyo/Application~Application#start} method will automatically be called\n\t* once its [create()]{@link module:enyo/Application~Application#create} method has completed\n\t* execution. Set this to `false` if additional setup (or an asynchronous\n\t* {@glossary event}) is required before starting.\n\t*\n\t* @type {Boolean}\n\t* @default true\n\t* @public\n\t*/\n\tautoStart: true,\n\t\n\t/**\n\t* If set to `true` (the default), the [application]{@link module:enyo/Application~Application} will immediately\n\t* [render]{@link module:enyo/Application~Application#render} its [view]{@link module:enyo/ViewController~ViewController#view} when\n\t* the [start()]{@link module:enyo/Application~Application#start} method has completed execution. Set this to\n\t* `false` to delay rendering if additional setup (or an asynchronous {@glossary event}) is\n\t* required before rendering.\n\t*\n\t* @type {Boolean}\n\t* @default true\n\t* @public\n\t*/\n\trenderOnStart: true,\n\t\n\t/**\n\t* The `defaultKind` for {@link module:enyo/Application~Application} is {@link module:enyo/Controller~Controller}.\n\t*\n\t* @type {Object}\n\t* @default module:enyo/Controller~Controller\n\t* @public\n\t*/\n\tdefaultKind: Controller,\n\n\t/**\n\t* A [bindable]{@link module:enyo/BindingSupport~BindingSupport}, read-only property that indicates whether the\n\t* [view]{@link module:enyo/ViewController~ViewController#view} has been rendered.\n\t*\n\t* @readonly\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\tviewReady: false,\n\t\n\t/**\n\t* An abstract method to allow for additional setup to take place after the application has\n\t* completed its initialization and is ready to be rendered. Overload this method to suit\n\t* your app's specific requirements.\n\t*\n\t* @returns {this} The callee for chaining.\n\t* @public\n\t*/\n\tstart: function () {\n\t\tif (this.renderOnStart) this.render();\n\t\treturn this;\n\t},\n\t\n\t/**\n\t* @method\n\t* @private\n\t*/\n\trender: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\t// call the super method render() from ViewController\n\t\t\tsup.apply(this, arguments);\n\t\t\tif (this.view && this.view.generated) this.set('viewReady', true);\n\t\t};\n\t}),\n\t\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tconstructor: kind.inherit(function (sup) {\n\t\treturn function (props) {\n\t\t\tif (props && typeof props.name == 'string') {\n\t\t\t\tutils.setPath(props.name, this);\n\t\t\t\t// since applications are stored by their id's we set it\n\t\t\t\t// to the name if it exists\n\t\t\t\tthis.id = (props && props.name);\n\t\t\t}\n\t\t\tsup.apply(this, arguments);\n\t\t\t// we alias the `controllers` property to the `$` property to preserve\n\t\t\t// backwards compatibility for the deprecated API for now\n\t\t\tthis.controllers = this.$;\n\t\t\tapplications[this.id || this.makeId()] = this;\n\t\t};\n\t}),\n\t\n\t/**\n\t* Allows normal creation flow and then executes the application's \n\t* [start()]{@link module:enyo/Application~Application#start} method if the\n\t* [autoStart]{@link module:enyo/Application~Application#autoStart} property is `true`.\n\t*\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\t// ensure that we create() all of the components before continuing\n\t\t\tsup.apply(this, arguments);\n\t\t\tif (this.autoStart) this.start();\n\t\t\t\n\t\t};\n\t}),\n\t\n\t/**\n\t* Ensures that all [components]{@link module:enyo/Component~Component} created by this application have \n\t* their [app]{@link module:enyo/ApplicationSupport#app} property set correctly.\n\t*\n\t* @method\n\t* @private\n\t*/\n\tadjustComponentProps: kind.inherit(function (sup) {\n\t\treturn function (props) {\n\t\t\tprops.app = this;\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\t\n\t/**\n\t* Cleans up the registration for the application.\n\t*\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tdelete applications[this.id];\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\t\n\t/**\n\t* Ensures that [events]{@glossary event} bubbling from the views will reach \n\t* {@link module:enyo/master} as expected.\n\t*\n\t* @private\n\t*/\n\towner: master\n});\n\n/**\n* Any {@link module:enyo/Application~Application} instances will be available by name from this \n* [object]{@glossary Object}. If no name is provided for an \n* [application]{@link module:enyo/Application~Application}, a name will be generated for it.\n*\n* @public\n* @type {Object}\n* @default {}\n*/\nexports.applications = applications;\n",
    "mtime": 1542469884011,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/Application.js",
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relPath": "enyo/Application",
    "requires": [
      "enyo",
      "./kind",
      "./utils",
      "./master",
      "./ViewController",
      "./Controller"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "../TouchScrollStrategy",
    "base": "/home/udo/git/NCPV/lib/enyo/src/Scroller",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/TouchScrollStrategy",
    "name": "enyo/TouchScrollStrategy",
    "isFile": true,
    "contents": "require('enyo');\nrequire('./touch');\n\n/**\n* Contains the declaration for the {@link module:enyo/TouchScrollStrategy~TouchScrollStrategy} kind.\n* @module enyo/TouchScrollStrategy\n*/\n\nvar\n\tkind = require('./kind'),\n\tutils = require('./utils'),\n\tdispatcher = require('./dispatcher'),\n\tplatform = require('./platform');\n\nvar\n\tScrollMath = require('./ScrollMath'),\n\tScrollStrategy = require('./ScrollStrategy'),\n\tScrollThumb = require('./ScrollThumb'),\n\tDom = require('./dom');\n\n/**\n* Fires when dragging has started, allowing drags to propagate to parent\n* [scrollers]{@link module:enyo/Scroller~Scroller}.\n*\n* @event module:enyo/TouchScrollStrategy~TouchScrollStrategy#onShouldDrag\n* @type {Object}\n* @property {Object} sender - The [component]{@link module:enyo/Component~Component} that most recently\n*\tpropagated the {@glossary event}.\n* @property {module:enyo/Scroller~ScrollEvent} event - An [object]{@glossary Object} containing\n*\tevent information.\n* @private\n*/\n\n/**\n* {@link module:enyo/TouchScrollStrategy~TouchScrollStrategy} is a helper [kind]{@glossary kind} for implementing a\n* touch-based [scroller]{@link module:enyo/Scroller~Scroller}. It integrates the scrolling simulation provided\n* by {@link module:enyo/ScrollMath~ScrollMath} into an `enyo/Scroller`.\n*\n* `enyo/TouchScrollStrategy` is not typically created in application code. Instead, it is\n* specified as the value of the [strategyKind]{@link module:enyo/Scroller~Scroller#strategyKind} property\n* of an `enyo/Scroller` or {@link module:layout/List~List}, or is used by the framework implicitly.\n*\n* @class TouchScrollStrategy\n* @extends module:enyo/ScrollStrategy~ScrollStrategy\n* @protected\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/TouchScrollStrategy~TouchScrollStrategy.prototype */ {\n\n\tname: 'enyo.TouchScrollStrategy',\n\n\t/**\n\t* @private\n\t*/\n\tkind: ScrollStrategy,\n\n\t/**\n\t\tIf `true` (the default), the scroller will overscroll and bounce back at the edges.\n\t*/\n\toverscroll: true,\n\n\t/**\n\t\tIf `true` (the default), the scroller will not propagate `dragstart`\n\t\tevents that cause it to start scrolling.\n\t*/\n\tpreventDragPropagation: true,\n\n\t/**\n\t* @private\n\t*/\n\tpublished:\n\t\t/** @lends module:enyo/TouchScrollStrategy~TouchScrollStrategy.prototype */ {\n\n\t\t/**\n\t\t* Specifies how to vertically scroll.  Acceptable values are `'scroll'`, `'auto'`,\n\t\t* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the\n\t\t* scroll strategy.\n\t\t*\n\t\t* @type {String}\n\t\t* @default 'default'\n\t\t* @public\n\t\t*/\n\t\tvertical: 'default',\n\n\t\t/**\n\t\t* Specifies how to horizontally scroll.  Acceptable values are `'scroll'`, `'auto'`,\n\t\t* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the\n\t\t* scroll strategy.\n\t\t*\n\t\t* @type {String}\n\t\t* @default 'default'\n\t\t* @public\n\t\t*/\n\t\thorizontal: 'default',\n\n\t\t/**\n\t\t* Set to `true` to display a scroll thumb.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default true\n\t\t* @public\n\t\t*/\n\t\tthumb: true,\n\n\t\t/**\n\t\t* Set to `true` to display a transparent overlay while scrolling. This can help improve\n\t\t* performance of complex, large scroll regions on some platforms (e.g., Android).\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default false\n\t\t* @public\n\t\t*/\n\t\tscrim: false,\n\n\t\t/**\n\t\t* Indicates whether to allow drag [events]{@glossary event} to be sent while gesture\n\t\t* events are happening simultaneously.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default true\n\t\t* @public\n\t\t*/\n\t\tdragDuringGesture: true,\n\n\t\t/**\n\t\t* Facades animation time step from [ScrollMath]{@link module:enyo/ScrollMath~ScrollMath}.\n\t\t*\n\t\t* @type {Number}\n\t\t* @default 20\n\t\t* @public\n\t\t*/\n\t\tinterval: 20,\n\n\t\t/**\n\t\t* Facades animation interval type from [ScrollMath]{@link module:enyo/ScrollMath~ScrollMath}.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default true\n\t\t* @public\n\t\t*/\n\t\tfixedTime: true,\n\n\t\t/**\n\t\t* Facades one unit of time for simulation from [ScrollMath]{@link module:enyo/ScrollMath~ScrollMath}.\n\t\t*\n\t\t* @type {Number}\n\t\t* @default 10\n\t\t* @public\n\t\t*/\n\t\tframe: 10,\n\n\t\t/**\n\t\t* Indicates whether default [events]{@glossary event} (e.g., native scrolling\n\t\t* events) should be suppressed.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default true\n\t\t* @public\n\t\t*/\n\t\tpreventDefault: true\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tevents: {\n\t\tonShouldDrag: ''\n\t},\n\n\t/**\n\t* @private\n\t*/\n\thandlers: {\n\t\tonflick: 'flick',\n\t\tonShouldDrag: 'shouldDrag',\n\t\tondrag: 'drag'\n\t},\n\n\t/**\n\t* @private\n\t*/\n\ttools: [\n\t\t{kind: ScrollMath, onScrollStart: 'scrollMathStart', onScroll: 'scrollMathScroll', onScrollStop: 'scrollMathStop', onStabilize: 'scrollMathStabilize'},\n\t\t{name: 'vthumb', kind: ScrollThumb, axis: 'v', showing: false},\n\t\t{name: 'hthumb', kind: ScrollThumb, axis: 'h', showing: false}\n\t],\n\n\t/**\n\t* @private\n\t*/\n\tscrimTools: [{name: 'scrim', classes: 'enyo-fit', style: 'z-index: 1;', showing: false}],\n\n\t/**\n\t* @private\n\t*/\n\tcomponents: [\n\t\t{name: 'client', classes: 'enyo-touch-scroller enyo-touch-scroller-client'}\n\t],\n\n\t/**\n\t* Flag indicating whether the list is currently reordering.\n\t*\n\t* @readonly\n\t* @public\n\t*/\n\tlistReordering: false,\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.transform = Dom.canTransform();\n\t\t\tif(!this.transform) {\n\t\t\t\tif(this.overscroll) {\n\t\t\t\t\t//so we can adjust top/left if browser can't handle translations\n\t\t\t\t\tthis.$.client.applyStyle('position', 'relative');\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.accel = Dom.canAccelerate();\n\t\t\tvar containerClasses = 'enyo-touch-strategy-container';\n\t\t\t// note: needed for ios to avoid incorrect clipping of thumb\n\t\t\t// and need to avoid on Android as it causes problems hiding the thumb\n\t\t\tif (platform.ios && this.accel) {\n\t\t\t\tcontainerClasses += ' enyo-composite';\n\t\t\t}\n\t\t\tthis.scrimChanged();\n\t\t\tthis.intervalChanged();\n\t\t\tthis.fixedTimeChanged();\n\t\t\tthis.frameChanged();\n\t\t\tthis.container.addClass(containerClasses);\n\t\t\tthis.translation = this.accel ? 'translate3d' : 'translate';\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tinitComponents: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tthis.createChrome(this.tools);\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tdestroy: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tthis.container.removeClass('enyo-touch-strategy-container');\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\trendered: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tdispatcher.makeBubble(this.$.client, 'scroll');\n\t\t\tthis.calcBoundaries();\n\t\t\tthis.syncScrollMath();\n\t\t\tif (this.thumb) {\n\t\t\t\tthis.alertThumbs();\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tscrimChanged: function () {\n\t\tif (this.scrim && !this.$.scrim) {\n\t\t\tthis.makeScrim();\n\t\t}\n\t\tif (!this.scrim && this.$.scrim) {\n\t\t\tthis.$.scrim.destroy();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmakeScrim: function () {\n\t\t// reset control parent so scrim doesn't go into client.\n\t\tvar cp = this.controlParent;\n\t\tthis.controlParent = null;\n\t\tthis.createChrome(this.scrimTools);\n\t\tthis.controlParent = cp;\n\t\tvar cn = this.container.hasNode();\n\t\t// render scrim in container, strategy has no dom.\n\t\tif (cn) {\n\t\t\tthis.$.scrim.parentNode = cn;\n\t\t\tthis.$.scrim.render();\n\t\t}\n\t},\n\n\t/**\n\t* Determines whether or not the scroller is actively moving.\n\t*\n\t* @return {Boolean} `true` if actively moving; otherwise, `false`.\n\t* @public\n\t*/\n\tisScrolling: function () {\n\t\tvar m = this.$.scrollMath;\n\t\treturn m ? m.isScrolling() : this.scrolling;\n\t},\n\n\t/**\n\t* Determines whether or not the scroller is in overscroll.\n\t*\n\t* @return {Boolean} `true` if in overscroll; otherwise, `false`.\n\t* @public\n\t*/\n\tisOverscrolling: function () {\n\t\tvar m = this.$.scrollMath || this;\n\t\treturn (this.overscroll) ? Boolean(m.isInOverScroll()) : false;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdomScroll: function () {\n\t\tif (!this.isScrolling()) {\n\t\t\tthis.calcBoundaries();\n\t\t\tthis.syncScrollMath();\n\t\t\tif (this.thumb) {\n\t\t\t\tthis.alertThumbs();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\thorizontalChanged: function () {\n\t\tthis.$.scrollMath.horizontal = (this.horizontal != 'hidden');\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tverticalChanged: function () {\n\t\tthis.$.scrollMath.vertical = (this.vertical != 'hidden');\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmaxHeightChanged: function () {\n\t\tthis.$.client.applyStyle('max-height', this.maxHeight);\n\t\t// note: previously used enyo-fit here but IE would reset scroll position when the scroll thumb\n\t\t// was hidden; in general IE resets scrollTop when there are 2 abs position siblings, one has\n\t\t// scrollTop and the other is hidden.\n\t\tthis.$.client.addRemoveClass('enyo-scrollee-fit', !this.maxHeight);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tthumbChanged: function () {\n\t\tthis.hideThumbs();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tintervalChanged: function () {\n\t\tif (this.$.scrollMath) {\n\t\t\tthis.$.scrollMath.interval = this.interval;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tfixedTimeChanged: function () {\n\t\tif (this.$.scrollMath) {\n\t\t\tthis.$.scrollMath.fixedTime = this.fixedTime;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tframeChanged: function () {\n\t\tif (this.$.scrollMath) {\n\t\t\tthis.$.scrollMath.frame = this.frame;\n\t\t}\n\t},\n\n\t/**\n\t* Stops any active scroll movement.\n\t*\n\t* @todo Doc update made while merging, need official documentation update!\n\t*\n\t* @param {Boolean} emit - Whether or not to fire the `onScrollStop` event.\n\t* @public\n\t*/\n\tstop: function (emit) {\n\t\tif (this.isScrolling()) {\n\t\t\tthis.$.scrollMath.stop(emit);\n\t\t}\n\t},\n\n\t/**\n\t* Adjusts the scroll position to be valid, if necessary (e.g., after the scroll contents\n\t* have changed).\n\t*\n\t* @public\n\t*/\n\tstabilize: function () {\n\t\tif(this.$.scrollMath) {\n\t\t\tthis.$.scrollMath.stabilize();\n\t\t}\n\t},\n\n\t/**\n\t* Scrolls to a specific position within the scroll area.\n\t*\n\t* @param {Number} x - The `x` position in pixels.\n\t* @param {Number} y - The `y` position in pixels.\n\t* @public\n\t*/\n\tscrollTo: function (x, y) {\n\t\tthis.stop(true);\n\t\tthis.$.scrollMath.scrollTo(x, y || y === 0 ? y : null);\n\t},\n\n\t/**\n\t* Scrolls the given [control]{@link module:enyo/Control~Control} into view.\n\t*\n\t* @param {module:enyo/Control~Control} ctl - The [control]{@link module:enyo/Control~Control} to make visible in the\n\t*\t[scroller's]{@link module:enyo/Scroller~Scroller} viewport.\n\t* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top of the\n\t*\tscroller.\n\t* @method\n\t* @public\n\t*/\n\tscrollIntoView: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tthis.stop(true);\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* Sets the horizontal scroll position.\n\t*\n\t* @param {Number} left - The horizontal scroll position in pixels.\n\t* @method\n\t* @public\n\t*/\n\tsetScrollLeft: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tthis.stop(true);\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* Sets the vertical scroll position.\n\t*\n\t* @param {Number} top - The vertical scroll position in pixels.\n\t* @method\n\t* @public\n\t*/\n\tsetScrollTop: kind.inherit(function (sup) {\n\t\treturn function(top) {\n\t\t\tthis.stop(true);\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* Retrieves the horizontal scroll position.\n\t*\n\t* @returns {Number} The horizontal scroll position in pixels.\n\t* @method\n\t* @public\n\t*/\n\tgetScrollLeft: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\treturn this.isScrolling() ? this.scrollLeft : sup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* Retrieves the vertical scroll position.\n\t*\n\t* @returns {Number} The vertical scroll position in pixels.\n\t* @method\n\t* @private\n\t*/\n\tgetScrollTop: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\treturn this.isScrolling() ? this.scrollTop : sup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tcalcScrollNode: function () {\n\t\treturn this.$.client.hasNode();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcalcAutoScrolling: function () {\n\t\tvar v = (this.vertical == 'auto');\n\t\tvar h = (this.horizontal == 'auto') || (this.horizontal == 'default');\n\t\tif ((v || h) && this.scrollNode) {\n\t\t\tvar b = this.getScrollBounds();\n\t\t\tif (v) {\n\t\t\t\tthis.$.scrollMath.vertical = b.height > b.clientHeight;\n\t\t\t}\n\t\t\tif (h) {\n\t\t\t\tthis.$.scrollMath.horizontal = b.width > b.clientWidth;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tshouldDrag: function (sender, e) {\n\t\tthis.calcAutoScrolling();\n\t\tvar requestV = e.vertical;\n\t\tvar canH = this.$.scrollMath.horizontal && !requestV;\n\t\tvar canV = this.$.scrollMath.vertical && requestV;\n\t\tvar down = e.dy < 0, right = e.dx < 0;\n\t\tvar oobV = (!down && this.startEdges.top || down && this.startEdges.bottom);\n\t\tvar oobH = (!right && this.startEdges.left || right && this.startEdges.right);\n\t\t// we would scroll if not at a boundary\n\t\tif (!e.boundaryDragger && (canH || canV)) {\n\t\t\te.boundaryDragger = this;\n\t\t}\n\t\t// include boundary exclusion\n\t\tif ((!oobV && canV) || (!oobH && canH)) {\n\t\t\te.dragger = this;\n\t\t\treturn true;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tflick: function (sender, e) {\n\t\tvar onAxis = Math.abs(e.xVelocity) > Math.abs(e.yVelocity) ? this.$.scrollMath.horizontal : this.$.scrollMath.vertical;\n\t\tif (onAxis && this.dragging) {\n\t\t\tthis.$.scrollMath.flick(e);\n\t\t\treturn this.preventDragPropagation;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdown: kind.inherit(function (sup) {\n\t\treturn function (sender, e) {\n\t\t\tif (!this.isOverscrolling()) {\n\t\t\t\tsup.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tmove: function (sender, e) {\n\t},\n\n\t// Special synthetic DOM events served up by the Gesture system\n\n\t/**\n\t* @fires module:enyo/TouchScrollStrategy~TouchScrollStrategy#onShouldDrag\n\t* @private\n\t*/\n\tdragstart: function (sender, e) {\n\t\t// Ignore drags sent from multi-touch events\n\t\tif(!this.dragDuringGesture && e.srcEvent.touches && e.srcEvent.touches.length > 1) {\n\t\t\treturn true;\n\t\t}\n\t\t// note: allow drags to propagate to parent scrollers via data returned in the shouldDrag event.\n\t\tthis.doShouldDrag(e);\n\t\tthis.dragging = (e.dragger == this || (!e.dragger && e.boundaryDragger == this));\n\t\tif (this.dragging) {\n\t\t\tif(this.preventDefault){\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\t// note: needed because show/hide changes\n\t\t\t// the position so sync'ing is required when\n\t\t\t// dragging begins (needed because show/hide does not trigger onscroll)\n\t\t\tthis.syncScrollMath();\n\t\t\tthis.$.scrollMath.startDrag(e);\n\t\t\tif (this.preventDragPropagation) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdrag: function (sender, e) {\n\t\t// if the list is doing a reorder, don't scroll\n\t\tif(this.listReordering) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.dragging) {\n\t\t\tif(this.preventDefault){\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\tthis.$.scrollMath.drag(e);\n\t\t\tif (this.scrim) {\n\t\t\t\tthis.$.scrim.show();\n\t\t\t}\n\t\t}\n\t},\n\tdragfinish: function (sender, e) {\n\t\tif (this.dragging) {\n\t\t\te.preventTap();\n\t\t\tthis.$.scrollMath.dragFinish();\n\t\t\tthis.dragging = false;\n\t\t\tif (this.scrim) {\n\t\t\t\tthis.$.scrim.hide();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmousewheel: function (sender, e) {\n\t\tif (!this.dragging && this.useMouseWheel) {\n\t\t\tthis.calcBoundaries();\n\t\t\tthis.syncScrollMath();\n\t\t\tthis.stabilize();\n\t\t\tif (this.$.scrollMath.mousewheel(e)) {\n\t\t\t\te.preventDefault();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tscrollMathStart: function () {\n\t\tif (this.scrollNode && !this.isScrolling()) {\n\t\t\tthis.scrolling = true;\n\t\t\tif (!this.isOverscrolling()) {\n\t\t\t\tthis.calcBoundaries();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tscrollMathScroll: function (sender) {\n\t\tif(!this.overscroll) {\n\t\t\t//don't overscroll past edges\n\t\t\tthis.effectScroll(-Math.min(sender.leftBoundary, Math.max(sender.rightBoundary, sender.x)),\n\t\t\t\t\t-Math.min(sender.topBoundary, Math.max(sender.bottomBoundary, sender.y)));\n\t\t} else {\n\t\t\tthis.effectScroll(-sender.x, -sender.y);\n\t\t}\n\t\tif (this.thumb) {\n\t\t\tthis.showThumbs();\n\t\t\tthis.delayHideThumbs(100);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tscrollMathStop: function () {\n\t\tthis.scrolling = false;\n\t\tthis.effectScrollStop();\n\t\tif (this.thumb) {\n\t\t\tthis.delayHideThumbs(100);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tscrollMathStabilize: function (sender) {\n\t\tthis.effectScroll(-sender.x, -sender.y);\n\t\tif (this.thumb) {\n\t\t\tthis.showThumbs();\n\t\t\tthis.delayHideThumbs(100);\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcalcBoundaries: function () {\n\t\tvar s = this.$.scrollMath || this, b = this._getScrollBounds();\n\t\ts.bottomBoundary = b.clientHeight - b.height;\n\t\ts.rightBoundary = b.clientWidth - b.width;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tsyncScrollMath: function () {\n\t\tvar m = this.$.scrollMath;\n\t\tif(m) {\n\t\t\tm.setScrollX(-this.getScrollLeft());\n\t\t\tm.setScrollY(-this.getScrollTop());\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\teffectScroll: function (x, y) {\n\t\tif (this.scrollNode) {\n\t\t\tthis.scrollLeft = this.scrollNode.scrollLeft = x;\n\t\t\tthis.scrollTop = this.scrollNode.scrollTop = y;\n\t\t\tthis.effectOverscroll(x !== null? Math.round(x): x, y !== null? Math.round(y): y);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\teffectScrollStop: function () {\n\t\tthis.effectOverscroll(null, null);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\teffectOverscroll: function (x, y) {\n\t\tvar n = this.scrollNode;\n\t\tvar xt = '0', yt = '0', zt = this.accel ? ',0' : '';\n\t\tif (y !== null && Math.abs(y - n.scrollTop) > 1) {\n\t\t\tyt = (n.scrollTop - y);\n\t\t}\n\t\tif (x !== null && Math.abs(x - n.scrollLeft) > 1) {\n\t\t\txt = (n.scrollLeft - x);\n\t\t}\n\t\tif(!this.transform) {\n\t\t\t//adjust top/left if browser can't handle translations\n\t\t\tthis.$.client.setBounds({left:xt + 'px', top:yt + 'px'});\n\t\t} else {\n\t\t\tDom.transformValue(this.$.client, this.translation, xt + 'px, ' + yt + 'px' + zt);\n\t\t}\n\t},\n\n\t/**\n\t* Retrieves the overscroll boundaries of the [scroller]{@link module:enyo/Scroller~Scroller}.\n\t*\n\t* @returns {module:enyo/Scroller~OverscrollBoundaryObject} An [object]{@glossary Object}\n\t*\tdescribing the overscroll boundaries.\n\t* @public\n\t*/\n\tgetOverScrollBounds: function () {\n\t\tvar m = this.$.scrollMath || this;\n\t\treturn {\n\t\t\toverleft: Math.min(m.leftBoundary - m.x, 0) || Math.max(m.rightBoundary - m.x, 0),\n\t\t\tovertop: Math.min(m.topBoundary - m.y, 0) || Math.max(m.bottomBoundary - m.y, 0)\n\t\t};\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\t_getScrollBounds: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tvar r = sup.apply(this, arguments);\n\t\t\tutils.mixin(r, this.getOverScrollBounds());\n\t\t\treturn r;\n\t\t};\n\t}),\n\n\t/**\n\t* Retrieves the scroll boundaries of the [scroller]{@link module:enyo/Scroller~Scroller}.\n\t*\n\t* @returns {module:enyo/Scroller~BoundaryObject} An [object]{@glossary Object} describing the\n\t*\tscroll boundaries.\n\t* @method\n\t* @public\n\t*/\n\tgetScrollBounds: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tthis.stop(true);\n\t\t\treturn sup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* This method exists primarily to support an internal use case for\n\t* [enyo/DataList]{@link module:enyo/DataList~DataList}. It is intended to be called by the\n\t* [scroller]{@link module:enyo/Scroller~Scroller} that owns this strategy.\n\t*\n\t* Triggers a remeasurement of the scroller's metrics (specifically, the\n\t* size of its viewport, the size of its contents and the difference between\n\t* the two, which determines the extent to which the scroller may scroll).\n\t*\n\t* @public\n\t*/\n\tremeasure: function () {\n\t\tthis.calcBoundaries();\n\t\tif (this.thumb) {\n\t\t\tthis.syncThumbs();\n\t\t}\n\t\tthis.stabilize();\n\t},\n\n\t/**\n\t* Displays the scroll indicators and sets the auto-hide timeout.\n\t*\n\t* @public\n\t*/\n\talertThumbs: function () {\n\t\tthis.showThumbs();\n\t\tthis.delayHideThumbs(500);\n\t},\n\n\t/**\n\t* Syncs the vertical and horizontal scroll indicators.\n\t*\n\t* @public\n\t*/\n\tsyncThumbs: function () {\n\t\tthis.$.vthumb.sync(this);\n\t\tthis.$.hthumb.sync(this);\n\t},\n\tupdateThumbs: function () {\n\t\tthis.$.vthumb.update(this);\n\t\tthis.$.hthumb.update(this);\n\t},\n\n\t/**\n\t* Syncs and shows both the vertical and horizontal scroll indicators. We only sync after we\n\t* have checked if the vertical and/or horizontal scroll indicators are to be shown, so that\n\t* {@link module:enyo/ScrollThumb~ScrollThumb#update} accurately makes calculations when the indicators are\n\t* visible.\n\t*\n\t* @public\n\t*/\n\tshowThumbs: function () {\n\t\tif (this.horizontal != 'hidden') {\n\t\t\tthis.$.hthumb.show();\n\t\t}\n\t\tif (this.vertical != 'hidden') {\n\t\t\tthis.$.vthumb.show();\n\t\t}\n\t\tthis.syncThumbs();\n\t},\n\n\t/**\n\t* Hides the vertical and horizontal scroll indicators.\n\t*\n\t* @public\n\t*/\n\thideThumbs: function () {\n\t\tthis.$.vthumb.hide();\n\t\tthis.$.hthumb.hide();\n\t},\n\n\t/**\n\t* Hides the vertical and horizontal scroll indicators asynchronously.\n\t*\n\t* @public\n\t*/\n\tdelayHideThumbs: function (delay) {\n\t\tthis.$.vthumb.delayHide(delay);\n\t\tthis.$.hthumb.delayHide(delay);\n\t}\n});\n",
    "mtime": 1542469884543,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/TouchScrollStrategy.js",
    "relPath": "enyo/TouchScrollStrategy",
    "requires": [
      "enyo",
      "./touch",
      "./kind",
      "./utils",
      "./dispatcher",
      "./platform",
      "./ScrollMath",
      "./ScrollStrategy",
      "./ScrollThumb",
      "./dom"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "../ToolDecorator",
    "base": "/home/udo/git/NCPV/lib/enyo/src/Button",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/ToolDecorator",
    "name": "enyo/ToolDecorator",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/ToolDecorator",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/enyo/src/ToolDecorator/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/enyo/src/ToolDecorator/package.json": 1542469884543,
      "/home/udo/git/NCPV/lib/enyo/src/ToolDecorator/ToolDecorator.js": 1542469884539
    },
    "json": {
      "main": "ToolDecorator.js",
      "styles": [
        "ToolDecorator.css"
      ]
    },
    "main": "/home/udo/git/NCPV/lib/enyo/src/ToolDecorator/ToolDecorator.js",
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/ToolDecorator~ToolDecorator} kind.\n* @module enyo/ToolDecorator\n*/\n\n\n\nvar\n\tkind = require('../kind');\nvar\n\tGroupItem = require('../GroupItem');\n\n/**\n* {@link module:enyo/ToolDecorator~ToolDecorator} lines up [components]{@link module:enyo/Component~Component} in a row,\n* centered vertically.\n*\n* @class ToolDecorator\n* @extends module:enyo/GroupItem~GroupItem\n* @ui\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/ToolDecorator~ToolDecorator.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.ToolDecorator',\n\n\t/**\n\t* @private\n\t*/\n\tkind: GroupItem,\n\n\t/**\n\t* @private\n\t*/\n\tclasses: 'enyo-tool-decorator'\n});\n",
    "nodeModules": false,
    "relPath": "enyo/ToolDecorator",
    "requires": [
      "enyo",
      "../kind",
      "../GroupItem"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/lib/enyo/src/ToolDecorator/ToolDecorator.css"
    ]
  },
  {
    "path": "../TranslateScrollStrategy",
    "base": "/home/udo/git/NCPV/lib/enyo/src/Scroller",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/TranslateScrollStrategy",
    "name": "enyo/TranslateScrollStrategy",
    "isFile": true,
    "contents": "require('enyo');\n\n/**\n * Contains the declaration for the {@link module:enyo/TranslateScrollStrategy~TranslateScrollStrategy} kind.\n * @module enyo/TranslateScrollStrategy\n */\n\nvar\n\tkind = require('./kind'),\n\tdispatcher = require('./dispatcher');\n\nvar\n\tTouchScrollStrategy = require('./TouchScrollStrategy'),\n\tDom = require('./dom');\n\n/**\n* {@link module:enyo/TranslateScrollStrategy~TranslateScrollStrategy} is a helper [kind]{@glossary kind} that extends\n* {@link module:enyo/TouchScrollStrategy~TouchScrollStrategy}, optimizing it for scrolling environments in which effecting\n* scroll changes with transforms using CSS translations is fastest.\n* \n* `TranslateScrollStrategy` is not typically created in application code. Instead, it is\n* specified as the value of the [strategyKind]{@link module:enyo/Scroller~Scroller#strategyKind} property of\n* an {@link module:enyo/Scroller~Scroller} or {@link module:layout/List~List}, or is used by the framework implicitly.\n*\n* @class TranslateScrollStrategy\n* @extends module:enyo/TouchScrollStrategy~TouchScrollStrategy\n* @protected\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/TranslateScrollStrategy~TranslateScrollStrategy.prototype */ {\n\n\tname: 'enyo.TranslateScrollStrategy',\n\n\t/**\n\t* @private\n\t*/\n\tkind: TouchScrollStrategy,\n\n\t/** \n\t* Set to `true` to optimize the strategy to only use translation to scroll; this increases\n\t* fluidity of scrolling animation. It should not be used when the\n\t* [scroller]{@link module:enyo/Scroller~Scroller} contains [controls]{@link module:enyo/Control~Control} that require\n\t* keyboard input. This is because when `translateOptimized` is `true`, it is possible to\n\t* position inputs such that they will not become visible when focused.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\ttranslateOptimized: false,\n\n\t/**\n\t* @private\n\t*/\n\tcomponents: [\n\t\t{name: 'clientContainer', classes: 'enyo-touch-scroller', components: [\n\t\t\t{name: 'client', classes: 'enyo-touch-scroller-client'}\n\t\t]}\n\t],\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\trendered: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tdispatcher.makeBubble(this.$.clientContainer, 'scroll');\n\t\t\tif (this.translateOptimized) {\n\t\t\t\t// on render, the start positions should be 0 for translateOptimized because the\n\t\t\t\t// scrollNode's scrollTop/Left will always be 0 and therefore offsetting the\n\t\t\t\t// translate to account for a non-zero scrollTop/Left isn't necessary.\n\t\t\t\tthis.setStartPosition(true);\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* Sets the start position for scrolling.\n\t*\n\t* @param {Boolean} [reset] When true, resets the start position to 0 rather than the current\n\t* \tscrollTop and scrollLeft.\n\t* @private\n\t*/\n\tsetStartPosition: function (reset) {\n\t\tif (reset) {\n\t\t\tthis.startX = this.startY = 0;\n\t\t} else {\n\t\t\tthis.startX = this.getScrollLeft();\n\t\t\tthis.startY = this.getScrollTop();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetScrollSize: function () {\n\t\tvar n = this.$.client.hasNode();\n\t\treturn {width: n ? n.scrollWidth : 0, height: n ? n.scrollHeight : 0};\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\t// apply initial transform so we're always composited\n\t\t\tDom.transformValue(this.$.client, this.translation, '0,0,0');\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tcalcScrollNode: function () {\n\t\treturn this.$.clientContainer.hasNode();\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmaxHeightChanged: function () {\n\t\t// content should cover scroller at a minimum if there's no max-height.\n\t\tthis.$.client.applyStyle('min-height', this.maxHeight ? null : '100%');\n\t\tthis.$.client.applyStyle('max-height', this.maxHeight);\n\t\tthis.$.clientContainer.addRemoveClass('enyo-scrollee-fit', !this.maxHeight);\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tshouldDrag: kind.inherit(function (sup) {\n\t\treturn function(inEvent) {\n\t\t\t// stop and update drag info before checking drag status\n\t\t\tthis.stop();\n\t\t\tthis.calcStartInfo();\n\t\t\treturn sup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tsyncScrollMath: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tif (!this._translated) {\n\t\t\t\tsup.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* Sets the horizontal scroll position.\n\t*\n\t* @param {Number} left - The horizontal scroll position in pixels.\n\t* @method\n\t* @public\n\t*/\n\tsetScrollLeft: kind.inherit(function (sup) {\n\t\treturn function(inLeft) {\n\t\t\tvar m, p;\n\t\t\tif (this.translateOptimized) {\n\t\t\t\tp = this.scrollLeft;\n\t\t\t\tm = this.$.scrollMath;\n\t\t\t\tthis.stop(true);\n\t\t\t\tm.setScrollX(-inLeft);\n\t\t\t\tm.stabilize();\n\t\t\t\tif (p != -m.x) {\n\t\t\t\t\t// We won't get a native scroll event,\n\t\t\t\t\t// so need to make one ourselves\n\t\t\t\t\tm.doScroll();\n\t\t\t\t\tthis.delayHideThumbs(100);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsup.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* Sets the vertical scroll position.\n\t*\n\t* @param {Number} top - The vertical scroll position in pixels.\n\t* @method\n\t* @public\n\t*/\n\tsetScrollTop: kind.inherit(function (sup) {\n\t\treturn function(inTop) {\n\t\t\tvar m, p;\n\t\t\tif (this.translateOptimized) {\n\t\t\t\tp = this.scrollTop;\n\t\t\t\tm = this.$.scrollMath;\n\t\t\t\tthis.stop(true);\n\t\t\t\tm.setScrollY(-inTop);\n\t\t\t\tm.stabilize();\n\t\t\t\tif (p != -m.y) {\n\t\t\t\t\t// We won't get a native scroll event,\n\t\t\t\t\t// so need to make one ourselves\n\t\t\t\t\tm.doScroll();\n\t\t\t\t\tthis.delayHideThumbs(100);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsup.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* Retrieves the horizontal scroll position.\n\t*\n\t* @returns {Number} The horizontal scroll position in pixels.\n\t* @method\n\t* @public\n\t*/\n\tgetScrollLeft: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\treturn this._translated ? this.scrollLeft: sup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* Retrieves the vertical scroll position.\n\t*\n\t* @returns {Number} The vertical scroll position in pixels.\n\t* @method\n\t* @private\n\t*/\n\tgetScrollTop: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\treturn this._translated ? this.scrollTop : sup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcalcBoundaries: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tif (this.translateOptimized && !this.isScrolling()) this.stabilize();\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\thandleResize: function() {\n\t\tif (this.translateOptimized) {\n\t\t\tthis.stabilize();\n\t\t}\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tscrollMathStart: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tif (!this._translated) {\n\t\t\t\tthis.setStartPosition();\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tscrollMathScroll: function (sender) {\n\t\tif(!this.overscroll) { //don't overscroll past edges\n\t\t\tthis.scrollLeft = -Math.min(sender.leftBoundary, Math.max(sender.rightBoundary, sender.x));\n\t\t\tthis.scrollTop = -Math.min(sender.topBoundary, Math.max(sender.bottomBoundary, sender.y));\n\t\t} else {\n\t\t\tthis.scrollLeft = -sender.x;\n\t\t\tthis.scrollTop = -sender.y;\n\t\t}\n\t\tthis.effectScroll(this.scrollLeft, this.scrollTop);\n\t\tif (this.thumb) {\n\t\t\tthis.showThumbs();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tscrollMathStabilize: kind.inherit(function (sup) {\n\t\treturn function (sender) {\n\t\t\tif (this._translated) {\n\t\t\t\tthis.scrollLeft = -sender.x;\n\t\t\t\tthis.scrollTop = -sender.y;\n\t\t\t\tthis.effectScroll(-sender.x, -sender.y);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn sup.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* While moving, scroller uses translate.\n\t*\n\t* @private\n\t*/\n\teffectScroll: kind.inherit(function (sup) {\n\t\treturn function (x, y) {\n\t\t\tvar o;\n\t\t\tif (this.translateOptimized || this.isScrolling()) {\n\t\t\t\tx = this.startX - x;\n\t\t\t\ty = this.startY - y;\n\t\t\t\to = x + 'px, ' + y + 'px' + (this.accel ? ',0' : '');\n\t\t\t\tDom.transformValue(this.$.client, this.translation, o);\n\t\t\t\tthis._translated = true;\n\t\t\t} else {\n\t\t\t\tsup.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* When stopped, we use `scrollLeft/scrollTop` (makes cursor positioning automagic).\n\t*\n\t* @private\n\t*/\n\teffectScrollStop: function () {\n\t\tif (!this.translateOptimized) {\n\t\t\tvar t = '0,0' + (this.accel ? ',0' : '');\n\t\t\t// FIXME: normally translate3d changes not effect scrollHeight; however\n\t\t\t// there appear to be some dom changes (e.g. showing a node inside the scroller,\n\t\t\t// which do cause the scrollHeight to be changed from the translate3d.\n\t\t\t// In this case setting the translate3d back to 0 does not restore scrollHeight.\n\t\t\t// This causes a problem because setting scrollTop can produced an unexpected result if\n\t\t\t// scrollHeight is less than expected.\n\t\t\t// We detect this fault by validating scroll bounds and (1) un-apply the translate3d,\n\t\t\t// (2) update scrollTop/Left, and (3) re-apply a 0,0,0 translate3d to ensure compositing.\n\t\t\t// Luckily this corrects the problem (which appears to be a webkit bug). Note that\n\t\t\t// it's important to maintain a composited state (translate3d 0,0,0) or Android 4 is\n\t\t\t// slow to start scrolling.\n\t\t\tvar m = this.$.scrollMath, sb = this._getScrollBounds();\n\t\t\tvar needsBoundsFix = Boolean((sb.maxTop + m.bottomBoundary) || (sb.maxLeft + m.rightBoundary));\n\t\t\tDom.transformValue(this.$.client, this.translation, needsBoundsFix ? null : t);\n\t\t\t// note: this asynchronously triggers dom scroll event\n\t\t\tthis.setScrollLeft(this.scrollLeft);\n\t\t\tthis.setScrollTop(this.scrollTop);\n\t\t\tif (needsBoundsFix) {\n\t\t\t\tDom.transformValue(this.$.client, this.translation, t);\n\t\t\t}\n\t\t\tthis._translated = false;\n\t\t}\n\t},\n\n\t/**\n\t* FIXME: we can fix scrolling artifacts BUGS on Android 4.04 with this heinous incantation.\n\t*\n\t* @private\n\t*/\n\ttwiddle: function () {\n\t\tif (this.translateOptimized && this.scrollNode) { // this.scrollNode is not always defined and makes Motorola XOOM crash\n\t\t\tthis.scrollNode.scrollTop = 1;\n\t\t\tthis.scrollNode.scrollTop = 0;\n\t\t}\n\t}\n});\n",
    "mtime": 1542469884559,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/TranslateScrollStrategy.js",
    "relPath": "enyo/TranslateScrollStrategy",
    "requires": [
      "enyo",
      "./kind",
      "./dispatcher",
      "./TouchScrollStrategy",
      "./dom"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "enyo/Button",
    "base": "/home/udo/git/NCPV/lib/onyx/src/Button",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relName": "enyo/Button",
    "name": "enyo/Button",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/Button",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/enyo/src/Button/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/enyo/src/Button/package.json": 1542469884059,
      "/home/udo/git/NCPV/lib/enyo/src/Button/Button.js": 1542469884055
    },
    "json": {
      "main": "Button.js",
      "styles": [
        "Button.css"
      ]
    },
    "main": "/home/udo/git/NCPV/lib/enyo/src/Button/Button.js",
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/Button~Button} kind.\n* @module enyo/Button\n*/\n\nvar\n\tkind = require('../kind');\nvar\n\tToolDecorator = require('../ToolDecorator');\n\n/**\n* {@link module:enyo/Button~Button} implements an HTML [button]{@glossary button}, with support\n* for grouping using {@link module:enyo/Group~Group}.\n*\n* For more information, see the documentation on\n* [Buttons]{@linkplain $dev-guide/building-apps/controls/buttons.html} in the\n* Enyo Developer Guide.\n*\n* @class Button\n* @extends module:enyo/ToolDecorator~ToolDecorator\n* @ui\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:enyo/Button~Button.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.Button',\n\t\n\t/**\n\t* @private\n\t*/\n\tkind: ToolDecorator,\n\n\t/**\n\t* @private\n\t*/\n\ttag: 'button',\n\n\t/**\n\t* @private\n\t*/\n\tattributes: {\n\t\t/**\n\t\t * Set to `'button'`; otherwise, the default value would be `'submit'`, which\n\t\t * can cause unexpected problems when [controls]{@link module:enyo/Control~Control} are used\n\t\t * inside of a [form]{@glossary form}.\n\t\t * \n\t\t * @type {String}\n\t\t * @private\n\t\t */\n\t\ttype: 'button'\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tpublished: \n\t\t/** @lends module:enyo/Button~Button.prototype */ {\n\t\t\n\t\t/**\n\t\t * When `true`, the [button]{@glossary button} is shown as disabled and does not \n\t\t * generate tap [events]{@glossary event}.\n\t\t * \n\t\t * @type {Boolean}\n\t\t * @default false\n\t\t * @public\n\t\t */\n\t\tdisabled: false\n\t},\n\t\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.disabledChanged();\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tdisabledChanged: function () {\n\t\tthis.setAttribute('disabled', this.disabled);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\ttap: function () {\n\t\tif (this.disabled) {\n\t\t\t// work around for platforms like Chrome on Android or Opera that send\n\t\t\t// mouseup to disabled form controls\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.setActive(true);\n\t\t}\n\t},\n\n\t// Accessibility\n\n\t/**\n\t* @default button\n\t* @type {String}\n\t* @see enyo/AccessibilitySupport~AccessibilitySupport#accessibilityRole\n\t* @public\n\t*/\n\taccessibilityRole: 'button',\n\n\t/**\n\t* When `true`, `aria-pressed` will reflect the state of\n\t* {@link module:enyo/GroupItem~GroupItem#active}\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\taccessibilityPressed: false,\n\n\t/**\n\t* @private\n\t*/\n\tariaObservers: [\n\t\t{from: 'disabled', to: 'aria-disabled'},\n\t\t{path: ['active', 'accessibilityPressed'], method: function () {\n\t\t\tthis.setAriaAttribute('aria-pressed', this.accessibilityPressed ? String(this.active) : null);\n\t\t}},\n\t\t{from: 'accessibilityRole', to: 'role'}\n\t]\n});\n",
    "nodeModules": false,
    "relPath": "enyo/Button",
    "requires": [
      "enyo",
      "../kind",
      "../ToolDecorator"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/lib/enyo/src/Button/Button.css"
    ]
  },
  {
    "path": "enyo/Scroller",
    "base": "/home/udo/git/NCPV/src/views",
    "external": true,
    "relName": "enyo/Scroller",
    "name": "enyo/Scroller",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/enyo/src/Scroller",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/enyo/src/Scroller/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/enyo/src/Scroller/package.json": 1542469884451,
      "/home/udo/git/NCPV/lib/enyo/src/Scroller/Scroller.js": 1542469884447
    },
    "json": {
      "main": "Scroller.js",
      "styles": [
        "Scroller.css"
      ]
    },
    "main": "/home/udo/git/NCPV/lib/enyo/src/Scroller/Scroller.js",
    "contents": "require('enyo');\n\n/**\n* Contains the declaration for the {@link module:enyo/Scroller~Scroller} kind.\n* @module enyo/Scroller\n*/\n\n\n\nvar\n\tkind = require('../kind'),\n\tplatform = require('../platform');\n\nvar\n\tControl = require('../Control'),\n\tScrollStrategy = require('../ScrollStrategy'),\n\tTouchScrollStrategy = require('../TouchScrollStrategy'),\n\tTranslateScrollStrategy = require('../TranslateScrollStrategy');\n\n/**\n* An [object]{@glossary Object} representing the scroll boundaries.\n*\n* @typedef {Object} module:enyo/Scroller~Scroller~BoundaryObject\n* @property {Number} left - The left scroll position.\n* @property {Number} top - The top scroll position.\n* @property {Number} maxLeft - Maximum value for the left scroll position (minimum is always 0).\n* @property {Number} maxTop - Maximum value for the top scroll position (minimum is always 0).\n* @property {Number} clientHeight - The vertical size of the [scroller]{@link module:enyo/Scroller~Scroller} on\n*\tscreen.\n* @property {Number} clientWidth - The horizontal size of the [scroller]{@link module:enyo/Scroller~Scroller} on\n*\tscreen.\n* @property {Number} width - The horizontal size of the full area of the scrolled region.\n* @property {Number} height - The vertical size of the full area of the scrolled region.\n* @property {Number} xDir - Either `1`, `-1`, or `0`, indicating positive movement along the\n*\tx-axis, negative movement, or no movement, respectively.\n* @property {Number} yDir - Either `1`, `-1`, or `0`, indicating positive movement along the\n*\ty-axis, negative movement, or no movement, respectively.\n*/\n\n\n/**\n* An [object]{@glossary Object} representing the overscroll boundaries.\n*\n* @typedef {Object} module:enyo/Scroller~Scroller~OverscrollBoundaryObject\n* @property {Number} overleft - The left overscroll position.\n* @property {Number} overtop - The top overscroll position.\n*/\n\n/**\n* The extended {@glossary event} [object]{@glossary Object} that is provided\n* when a scroll event is fired.\n*\n* @typedef {Object} module:enyo/Scroller~Scroller~ScrollEvent\n* @property {module:enyo/Scroller~Scroller~BoundaryObject} bounds - Current values of scroller bounds.\n*/\n\n/**\n* Fires when a scrolling action starts.\n*\n* @event module:enyo/Scroller~Scroller#onScrollStart\n* @type {Object}\n* @property {Object} sender - The [component]{@link module:enyo/Component~Component} that most recently\n*\tpropagated the {@glossary event}.\n* @property {module:enyo/Scroller~Scroller~ScrollEvent} event - An [object]{@glossary Object} containing\n*\tevent information.\n* @public\n*/\n\n/**\n* Fires while a scrolling action is in progress.\n*\n* @event module:enyo/Scroller~Scroller#onScroll\n* @type {Object}\n* @property {Object} sender - The [component]{@link module:enyo/Component~Component} that most recently\n*\tpropagated the {@glossary event}.\n* @property {Object} event - An [object]{@glossary Object} containing\n*\tevent information.\n* @public\n*/\n\n/**\n* Fires when a scrolling action stops.\n*\n* @event module:enyo/Scroller~Scroller#onScrollStop\n* @type {Object}\n* @property {Object} sender - The [component]{@link module:enyo/Component~Component} that most recently\n*\tpropagated the {@glossary event}.\n* @property {Object} event - An [object]{@glossary Object} containing\n*\tevent information.\n* @public\n*/\n\n/**\n* {@link module:enyo/Scroller~Scroller} is a scroller suitable for use in both desktop and mobile\n* applications.\n*\n* In some mobile environments, a default scrolling solution is not implemented for\n* DOM elements. In such cases, `enyo/Scroller` implements a touch-based scrolling\n* solution, which may be opted into either globally (by setting\n* [touchScrolling]{@link module:enyo/Scroller~Scroller#touchScrolling} to `true`) or on a\n* per-instance basis (by specifying a [strategyKind]{@link module:enyo/Scroller~Scroller#strategyKind}\n* of `'TouchScrollStrategy'`).\n*\n* For more information, see the documentation on\n* [Scrollers]{@linkplain $dev-guide/building-apps/layout/scrollers.html} in the\n* Enyo Developer Guide.\n*\n* @class Scroller\n* @public\n*/\nvar Scroller = module.exports = kind(\n\t/** @lends module:enyo/Scroller~Scroller.prototype */ {\n\n\tname: 'enyo.Scroller',\n\n\tkind: Control,\n\n\t/**\n\t* @private\n\t*/\n\tpublished:\n\t\t/** @lends module:enyo/Scroller~Scroller.prototype */ {\n\n\t\t/**\n\t\t* Specifies how to horizontally scroll.  Acceptable values are `'scroll'`, `'auto'`,\n\t\t* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the\n\t\t* scroll strategy.\n\t\t*\n\t\t* @type {String}\n\t\t* @default 'default'\n\t\t* @public\n\t\t*/\n\t\thorizontal: 'default',\n\n\t\t/**\n\t\t* Specifies how to vertically scroll.  Acceptable values are `'scroll'`, `'auto'`,\n\t\t* `'hidden'`, and `'default'`. The precise effect of the setting is determined by the\n\t\t* scroll strategy.\n\t\t*\n\t\t* @type {String}\n\t\t* @default 'default'\n\t\t* @public\n\t\t*/\n\t\tvertical: 'default',\n\n\t\t/**\n\t\t* The vertical scroll position.\n\t\t*\n\t\t* @type {Number}\n\t\t* @default 0\n\t\t* @public\n\t\t*/\n\t\tscrollTop: 0,\n\n\t\t/**\n\t\t* The horizontal scroll position.\n\t\t*\n\t\t* @type {Number}\n\t\t* @default 0\n\t\t* @public\n\t\t*/\n\t\tscrollLeft: 0,\n\n\t\t/**\n\t\t* Maximum height of the scroll content.\n\t\t*\n\t\t* @type {Number}\n\t\t* @default null\n\t\t* @memberof enyo/Scroller~Scroller.prototype\n\t\t* @public\n\t\t*/\n\t\tmaxHeight: null,\n\n\t\t/**\n\t\t* Set to `true` to make this [scroller]{@link module:enyo/Scroller~Scroller} select a\n\t\t* platform-appropriate touch-based scrolling strategy. Note that if you specify a value\n\t\t* for [strategyKind]{@link module:enyo/Scroller~Scroller#strategyKind}, that will take precedence over\n\t\t* this setting.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default false\n\t\t* @public\n\t\t*/\n\t\ttouch: false,\n\t\t/**\n\t\t* Specifies a type of scrolling. The [scroller]{@link module:enyo/Scroller~Scroller} will attempt to\n\t\t* automatically select a strategy compatible with the runtime environment. Alternatively,\n\t\t* you may choose to use a specific strategy:\n\t\t*\n\t\t* - [ScrollStrategy]{@link module:enyo/ScrollStrategy~ScrollStrategy} is the default and implements no\n\t\t*\tscrolling, relying instead on the environment to scroll properly.\n\t\t* - [TouchScrollStrategy]{@link module:enyo/TouchScrollStrategy~TouchScrollStrategy} implements a touch scrolling\n\t\t*\tmechanism.\n\t\t* - [TranslateScrollStrategy]{@link module:enyo/TranslateScrollStrategy~TranslateScrollStrategy} implements a touch\n\t\t*\tscrolling mechanism using translations; it is currently recommended only for Android\n\t\t*\t3+, iOS 5+ and Windows Phone 8.\n\t\t* - [TransitionScrollStrategy]{@link module:enyo/TransitionScrollStrategy~TransitionScrollStrategy} implements a touch\n\t\t*\tscrolling mechanism using CSS transitions;\n\t\t*\n\t\t* @type {Object}\n\t\t* @default module:enyo/ScrollStrategy~ScrollStrategy\n\t\t* @public\n\t\t*/\n\t\tstrategyKind: ScrollStrategy,\n\n\t\t/**\n\t\t* Set to `true` to display a scroll thumb in touch [scrollers]{@link module:enyo/Scroller~Scroller}.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default true\n\t\t* @public\n\t\t*/\n\t\tthumb: true,\n\n\t\t/**\n\t\t* If `true`, mouse wheel may be used to move the [scroller]{@link module:enyo/Scroller~Scroller}.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default true\n\t\t* @public\n\t\t*/\n\t\tuseMouseWheel: true\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tevents: {\n\t\tonScrollStart: '',\n\t\tonScroll: '',\n\t\tonScrollStop: ''\n\t},\n\n\t/**\n\t* If `true`, enables touch scrolling globally.\n\t*\n\t* @name touchScrolling\n\t* @type {Boolean}\n\t* @default undefined\n\t* @memberof enyo/Scroller~Scroller.prototype\n\t* @public\n\t*/\n\n\t/**\n\t* If `true` and this is a touch [scroller]{@link module:enyo/Scroller~Scroller}, the scroller\n\t* will overscroll and bounce back at the edges.\n\t*\n\t* @type {Boolean}\n\t* @default true\n\t* @public\n\t*/\n\ttouchOverscroll: true,\n\n\t/**\n\t* If `true`, the [scroller]{@link module:enyo/Scroller~Scroller} will not propagate `dragstart`\n\t* [events]{@glossary event} that cause it to start scrolling.\n\t*\n\t* @type {Boolean}\n\t* @default true\n\t* @public\n\t*/\n\tpreventDragPropagation: true,\n\n\t/**\n\t* If `true`, the [scroller]{@link module:enyo/Scroller~Scroller} will not propagate scroll\n\t* [events]{@glossary event}.\n\t*\n\t* @type {Boolean}\n\t* @default true\n\t* @public\n\t*/\n\tpreventScrollPropagation: true,\n\n\t/**\n\t* Needed to allow global mods to `enyo/Scroller.touchScrolling`.\n\t*\n\t* @private\n\t*/\n\n\n\t/**\n\t* @private\n\t*/\n\thandlers: {\n\t\tonscroll: 'domScroll',\n\t\tonScrollStart: 'scrollStart',\n\t\tonScroll: 'scroll',\n\t\tonScrollStop: 'scrollStop'\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tclasses: 'enyo-scroller',\n\n\t/**\n\t* @lends module:enyo/Scroller~Scroller\n\t* @private\n\t*/\n\tstatics: {\n\t\t/**\n\t\t* @private\n\t\t*/\n\t\tosInfo: [\n\t\t\t{os: 'android', version: 3},\n\t\t\t{os: 'androidChrome', version: 18},\n\t\t\t{os: 'androidFirefox', version: 16},\n\t\t\t{os: 'firefoxOS', version: 16},\n\t\t\t{os: 'ios', version: 5},\n\t\t\t{os: 'webos', version: 1e9},\n\t\t\t{os: 'blackberry', version:1e9},\n\t\t\t{os: 'tizen', version: 2}\n\t\t],\n\t\t/** Returns true if platform should have touch events. */\n\t\thasTouchScrolling: function() {\n\t\t\tfor (var i=0, t; (t=this.osInfo[i]); i++) {\n\t\t\t\tif (platform[t.os]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// special detection for IE10+ on touch devices\n\t\t\tif ((platform.ie >= 10 || platform.windowsPhone >= 8) && platform.touch) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t* Returns true if the platform has native div scrollers (desktop\n\t\t* browsers always have them).\n\t\t*/\n\t\thasNativeScrolling: function() {\n\t\t\tfor (var i=0, t; (t=this.osInfo[i]); i++) {\n\t\t\t\tif (platform[t.os] < t.version) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t/**\n\t\t* @private\n\t\t*/\n\t\tgetTouchStrategy: function() {\n\t\t\treturn (platform.androidChrome >= 27) || (platform.android >= 3) || (platform.ios >= 5) || (platform.windowsPhone === 8) || (platform.webos >= 4)\n\t\t\t\t? TranslateScrollStrategy\n\t\t\t\t: TouchScrollStrategy;\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcontrolParentName: 'strategy',\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tcreate: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.horizontalChanged();\n\t\t\tthis.verticalChanged();\n\t\t\tthis.useMouseWheelChanged();\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\timportProps: kind.inherit(function (sup) {\n\t\treturn function(inProps) {\n\t\t\tsup.apply(this, arguments);\n\t\t\t// allow global overriding of strategy kind\n\t\t\tif (inProps && inProps.strategyKind === undefined && (Scroller.touchScrolling || this.touch)) {\n\t\t\t\tthis.strategyKind = Scroller.getTouchStrategy();\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tinitComponents: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tthis.strategyKindChanged();\n\t\t\tsup.apply(this, arguments);\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\trendered: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tthis.syncStrategy();\n\t\t};\n\t}),\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tsyncStrategy: function() {\n\t\tthis.$.strategy.setScrollLeft(this.scrollLeft);\n\t\tthis.$.strategy.setScrollTop(this.scrollTop);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tstrategyKindChanged: function () {\n\t\tif (this.$.strategy) {\n\t\t\tthis.$.strategy.destroy();\n\t\t\tthis.controlParent = null;\n\t\t}\n\t\t// note: createComponents automatically updates controlParent.\n\t\tthis.createStrategy();\n\t\tif (this.hasNode()) {\n\t\t\tthis.render();\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcreateStrategy: function () {\n\t\tthis.createComponents([{name: 'strategy', maxHeight: this.maxHeight,\n\t\t\tkind: this.strategyKind, thumb: this.thumb,\n\t\t\tpreventDragPropagation: this.preventDragPropagation,\n\t\t\toverscroll:this.touchOverscroll, isChrome: true}]);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetStrategy: function () {\n\t\treturn this.$.strategy;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tmaxHeightChanged: function () {\n\t\tthis.$.strategy.setMaxHeight(this.maxHeight);\n\t},\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tshowingChanged: kind.inherit(function (sup) {\n\t\treturn function() {\n\t\t\tsup.apply(this, arguments);\n\t\t\tif (this.showing) {\n\t\t\t\tthis.syncStrategy();\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tshowingChangedHandler: kind.inherit(function(sup) {\n\t\treturn function(sender, event) {\n\t\t\tif (this.showing && event.showing) {\n\t\t\t\tthis.syncStrategy();\n\t\t\t}\n\t\t};\n\t}),\n\n\t/**\n\t* @private\n\t*/\n\tthumbChanged: function () {\n\t\tthis.$.strategy.setThumb(this.thumb);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\thorizontalChanged: function () {\n\t\tthis.$.strategy.setHorizontal(this.horizontal);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tverticalChanged: function () {\n\t\tthis.$.strategy.setVertical(this.vertical);\n\t},\n\n\t// FIXME: these properties are virtual; property changed methods are fired only if\n\t// property value changes, not if getter changes.\n\n\t/**\n\t* Sets the horizontal scroll position.\n\t*\n\t* @param {Number} left - The horizontal scroll position in pixels.\n\t* @public\n\t*/\n\tsetScrollLeft: function (left) {\n\t\tthis.$.strategy.setScrollLeft(left);\n\t},\n\n\t/**\n\t* Sets the vertical scroll position.\n\t*\n\t* @param {Number} top - The vertical scroll position in pixels.\n\t* @public\n\t*/\n\tsetScrollTop: function (top) {\n\t\tthis.$.strategy.setScrollTop(top);\n\t},\n\n\t/**\n\t* Retrieves the horizontal scroll position.\n\t*\n\t* @returns {Number} The horizontal scroll position in pixels.\n\t* @public\n\t*/\n\tgetScrollLeft: function () {\n\t\t// sync our internal property\n\t\tthis.scrollLeft = this.$.strategy.getScrollLeft();\n\t\treturn this.scrollLeft;\n\t},\n\n\t/**\n\t* Retrieves the vertical scroll position.\n\t*\n\t* @returns {Number} The vertical scroll position in pixels.\n\t* @public\n\t*/\n\tgetScrollTop: function () {\n\t\t// sync our internal property\n\t\tthis.scrollTop = this.$.strategy.getScrollTop();\n\t\treturn this.scrollTop;\n\t},\n\n\t/**\n\t* Retrieves the scroll boundaries of the [scroller]{@link module:enyo/Scroller~Scroller}.\n\t*\n\t* @returns {module:enyo/Scroller~BoundaryObject} An [object]{@glossary Object} describing the\n\t*\tscroll boundaries.\n\t* @public\n\t*/\n\tgetScrollBounds: function () {\n\t\tvar bounds  = this.$.strategy.getScrollBounds();\n\t\tif (\n\t\t\t(bounds.xDir !== -1 && bounds.xDir !== 0 && bounds.xDir !== 1) ||\n\t\t\t(bounds.yDir !== -1 && bounds.yDir !== 0 && bounds.yDir !== 1)\n\t\t) {\n\t\t\tthis.decorateBounds(bounds);\n\t\t}\n\t\t// keep our properties synchronized always and without extra calls\n\t\tthis.scrollTop  = bounds.top;\n\t\tthis.scrollLeft = bounds.left;\n\t\treturn bounds;\n\t},\n\n\t/**\n\t* Trigger a remeasurement of the scroller's metrics (specifically, the\n\t* size of its viewport, the size of its contents and the difference between\n\t* the two, which determines the extent to which the scroller may scroll).\n\t*\n\t* You should generally not need to call this from application code, as the\n\t* scroller usually remeasures automatically whenever needed. This method\n\t* exists primarily to support an internal use case for\n\t* [enyo/DataList]{@link module:enyo/DataList~DataList}.\n\t*\n\t* @public\n\t*/\n\tremeasure: function() {\n\t\tvar s = this.$.strategy;\n\t\tif (s.remeasure) s.remeasure();\n\t},\n\n\t/**\n\t* Scrolls the given [control]{@link module:enyo/Control~Control} into view.\n\t*\n\t* @param {module:enyo/Control~Control} ctl - The control to make visible in the\n\t*\t[scroller's]{@link module:enyo/Scroller~Scroller} viewport.\n\t* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top\n\t* of the scroller.\n\t* @public\n\t*/\n\tscrollIntoView: function (ctl, alignWithTop) {\n\t\tthis.$.strategy.scrollIntoView(ctl, alignWithTop);\n\t},\n\n\t/**\n\t* Scrolls to the specified position.\n\t*\n\t* @param {Number} x - The `x` position in pixels.\n\t* @param {Number} y - The `y` position in pixels.\n\t* @public\n\t*/\n\tscrollTo: function (x, y) {\n\t\tthis.$.strategy.scrollTo(x, y);\n\t},\n\n\t/**\n\t* Ensures that the given [control]{@link module:enyo/Control~Control} is visible in the\n\t* [scroller's]{@link module:enyo/Scroller~Scroller} viewport. Unlike\n\t* [scrollIntoView()]{@link module:enyo/Scroller~Scroller#scrollIntoView}, which uses DOM's\n\t* [scrollIntoView()]{@glossary scrollIntoView}, this only affects the current\n\t* scroller.\n\t*\n\t* @param {module:enyo/Control~Control} ctl - The [control]{@link module:enyo/Control~Control} to make visible in the\n\t*\t[scroller's]{@link module:enyo/Scroller~Scroller} viewport.\n\t* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top of the\n\t*\tscroller.\n\t* @public\n\t*/\n\tscrollToControl: function (ctl, alignWithTop) {\n\t\tthis.scrollToNode(ctl.hasNode(), alignWithTop);\n\t},\n\n\t/**\n\t* Ensures that the given node is visible in the [scroller's]{@link module:enyo/Scroller~Scroller} viewport.\n\t*\n\t* @param {Node} node - The node to make visible in the [scroller's]{@link module:enyo/Scroller~Scroller}\n\t*\tviewport.\n\t* @param {Boolean} alignWithTop - If `true`, the node is aligned with the top of the\n\t*\tscroller.\n\t* @public\n\t*/\n\tscrollToNode: function (node, alignWithTop) {\n\t\tthis.$.strategy.scrollToNode(node, alignWithTop);\n\t},\n\n\t/**\n\t* Stops the scroller if it is currently animating.\n\t*\n\t* @public\n\t*/\n\tstop: function() {\n\t\tif (typeof this.$.strategy.stop == 'function') {\n\t\t\tthis.$.strategy.stop(true);\n\t\t}\n\t},\n\n\t/**\n\t* Adds current values of `getScrollBounds()` to {@glossary event}.\n\t*\n\t* @private\n\t*/\n\tdecorateScrollEvent: function (e) {\n\t\tvar bounds = e.scrollBounds = e.scrollBounds || this.$.strategy._getScrollBounds();\n\t\t// in the off chance that the event already had scrollBounds then we need\n\t\t// to make sure they are decorated\n\t\tif (\n\t\t\t(bounds.xDir !== -1 && bounds.xDir !== 0 && bounds.xDir !== 1) ||\n\t\t\t(bounds.yDir !== -1 && bounds.yDir !== 0 && bounds.yDir !== 1)\n\t\t) {\n\t\t\tthis.decorateBounds(bounds);\n\t\t}\n\t\t// keep our properties synchronized always and without extra calls\n\t\tthis.scrollTop  = bounds.top;\n\t\tthis.scrollLeft = bounds.left;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdecorateBounds: function (bounds) {\n\t\tvar x       = this.scrollLeft - bounds.left,\n\t\t\ty       = this.scrollTop  - bounds.top;\n\t\tbounds.xDir = (x < 0? 1: x > 0? -1: 0);\n\t\tbounds.yDir = (y < 0? 1: y > 0? -1: 0);\n\t\t// we update our current bounds properties so we don't have to unnecessarily\n\t\t// call getScrollTop/getScrollLeft because we already have the current data\n\t\tthis.scrollLeft = bounds.left;\n\t\tthis.scrollTop  = bounds.top;\n\t},\n\n\t/**\n\t* Normalizes scroll {@glossary event} to `onScroll`.\n\t*\n\t* @fires module:enyo/Scroller~Scroller#onScroll\n\t* @private\n\t*/\n\tdomScroll: function (sender, e) {\n\t\t// if a scroll event originated here, pass it to our strategy to handle\n\t\tif (this.$.strategy.domScroll && e.originator == this) {\n\t\t\tthis.$.strategy.domScroll(sender, e);\n\t\t}\n\t\tthis.decorateScrollEvent(e);\n\t\tthis.doScroll(e);\n\t\treturn true;\n\t},\n\n\t/**\n\t* @returns {Boolean} `true` if the current scroll {@glossary event} should\n\t* be stopped; `false` if it should be allowed to propagate.\n\t* @private\n\t*/\n\tshouldStopScrollEvent: function (e) {\n\t\treturn (this.preventScrollPropagation &&\n\t\t\te.originator.owner != this.$.strategy);\n\t},\n\n\t/**\n\t* Calls [shouldStopScrollEvent()]{@link module:enyo/Scroller~Scroller#shouldStopScrollEvent} to\n\t* determine whether current scroll {@glossary event} should be stopped.\n\t*\n\t* @private\n\t*/\n\tscrollStart: function (sender, e) {\n\t\tif (!this.shouldStopScrollEvent(e)) {\n\t\t\tthis.decorateScrollEvent(e);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t* Either propagates or stops the current scroll {@glossary event}.\n\t*\n\t* @private\n\t*/\n\tscroll: function (sender, e) {\n\t\t// note: scroll event can be native dom or generated.\n\t\tvar stop;\n\t\tif (e.dispatchTarget) {\n\t\t\t// allow a dom event if it orignated with this scroller or its strategy\n\t\t\tstop = this.preventScrollPropagation && !(e.originator == this ||\n\t\t\t\te.originator.owner == this.$.strategy);\n\t\t} else {\n\t\t\tstop = this.shouldStopScrollEvent(e);\n\t\t}\n\t\tif (!stop) {\n\t\t\tthis.decorateScrollEvent(e);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t* Calls [shouldStopScrollEvent()]{@link module:enyo/Scroller~Scroller#shouldStopScrollEvent} to\n\t* determine whether current scroll {@glossary event} should be stopped.\n\t*\n\t* @private\n\t*/\n\tscrollStop: function (sender, e) {\n\t\tif (!this.shouldStopScrollEvent(e)) {\n\t\t\tthis.decorateScrollEvent(e);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t/**\n\t* Scrolls to the top of the scrolling region.\n\t*\n\t* @public\n\t*/\n\tscrollToTop: function () {\n\t\tthis.setScrollTop(0);\n\t},\n\n\t/**\n\t* Scrolls to the bottom of the scrolling region.\n\t*\n\t* @public\n\t*/\n\tscrollToBottom: function () {\n\t\tthis.setScrollTop(this.getScrollBounds().maxTop);\n\t},\n\n\t/**\n\t* Scrolls to the right edge of the scrolling region.\n\t*\n\t* @public\n\t*/\n\tscrollToRight: function () {\n\t\tthis.setScrollLeft(this.getScrollBounds().maxLeft);\n\t},\n\n\t/**\n\t* Scrolls to the left edge of the scrolling region.\n\t*\n\t* @public\n\t*/\n\tscrollToLeft: function () {\n\t\tthis.setScrollLeft(0);\n\t},\n\n\t/**\n\t* Ensures scroll position is in bounds.\n\t*\n\t* @public\n\t*/\n\tstabilize: function () {\n\t\tvar s = this.getStrategy();\n\t\tif (s.stabilize) {\n\t\t\ts.stabilize();\n\t\t}\n\t},\n\n\t/**\n\t* Sends the [useMouseWheel]{@link module:enyo/Scroller~Scroller#useMouseWheel} property to the scroll\n\t* strategy.\n\t*\n\t* @private\n\t*/\n\tuseMouseWheelChanged: function () {\n\t\tthis.$.strategy.setUseMouseWheel(this.useMouseWheel);\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tresize: kind.inherit(function (sup) {\n\t\treturn function () {\n\t\t\tif (this.getAbsoluteShowing(true)) {\n\t\t\t\tsup.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t})\n});\n\n// provide a touch scrolling solution by default when the environment is mobile\nif (Scroller.hasTouchScrolling()) {\n\tScroller.prototype.strategyKind = Scroller.getTouchStrategy();\n}\n",
    "nodeModules": false,
    "lib": "/home/udo/git/NCPV/lib/enyo",
    "libName": "enyo",
    "relPath": "enyo/Scroller",
    "requires": [
      "enyo",
      "../kind",
      "../platform",
      "../Control",
      "../ScrollStrategy",
      "../TouchScrollStrategy",
      "../TranslateScrollStrategy"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/lib/enyo/src/Scroller/Scroller.css"
    ]
  },
  {
    "path": "onyx",
    "base": "/home/udo/git/NCPV/lib/onyx/src/Toolbar",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/onyx",
    "libName": "onyx",
    "relName": "onyx",
    "name": "onyx",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/onyx",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/onyx/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/onyx/package.json": 1542469889003,
      "/home/udo/git/NCPV/lib/onyx/index.js": 1542469888999,
      "/home/udo/git/NCPV/lib/onyx/images/checkbox.png": 1542469888987,
      "/home/udo/git/NCPV/lib/onyx/images/close-active.png": 1542469888987,
      "/home/udo/git/NCPV/lib/onyx/images/close-inactive.png": 1542469888991,
      "/home/udo/git/NCPV/lib/onyx/images/grabbutton.png": 1542469888991,
      "/home/udo/git/NCPV/lib/onyx/images/gradient-invert.png": 1542469888991,
      "/home/udo/git/NCPV/lib/onyx/images/gradient.png": 1542469888991,
      "/home/udo/git/NCPV/lib/onyx/images/more.png": 1542469888995,
      "/home/udo/git/NCPV/lib/onyx/images/progress-button-cancel.png": 1542469888995,
      "/home/udo/git/NCPV/lib/onyx/images/search-input-cancel.png": 1542469888995,
      "/home/udo/git/NCPV/lib/onyx/images/search-input-search.png": 1542469888995,
      "/home/udo/git/NCPV/lib/onyx/images/slider-handle.png": 1542469888995,
      "/home/udo/git/NCPV/lib/onyx/images/spinner-dark.gif": 1542469888999,
      "/home/udo/git/NCPV/lib/onyx/images/spinner-light.gif": 1542469888999
    },
    "json": {
      "name": "onyx",
      "assets": [
        "images/*.png",
        "images/*.gif"
      ],
      "devAssets": [],
      "styles": [
        "css/onyx-variables.less",
        "css/onyx-rules.less"
      ],
      "main": "index.js",
      "moduleDir": "src",
      "version": "2.7.0",
      "optionalLibs": [
        "enyo-ilib"
      ],
      "directories": {
        "doc": "docs"
      },
      "scripts": {
        "test": "./node_modules/.bin/gulp"
      },
      "repository": {
        "type": "git",
        "url": "https://github.com/enyojs/onyx.git"
      },
      "author": "",
      "license": "Apache-2.0",
      "homepage": "https://github.com/enyojs/onyx",
      "devDependencies": {
        "gulp": "^3.9.0",
        "gulp-jshint": "^2.0.0",
        "jshint": "^2.9.1",
        "jshint-stylish": "^2.1.0"
      }
    },
    "main": "/home/udo/git/NCPV/lib/onyx/index.js",
    "contents": "/**\n* Features a variety of commonly used widgets, including toolbars, text inputs, checkboxes, groups\n* and multiple types of buttons.\n*\n* @namespace onyx\n*/\nmodule.exports.version = \"2.7.0\";\n\nvar dom = require('enyo/dom');\ndom.addBodyClass('onyx');\n",
    "nodeModules": false,
    "relPath": "onyx",
    "requires": [
      "enyo/dom"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/lib/onyx/css/onyx-variables.less",
      "/home/udo/git/NCPV/lib/onyx/css/onyx-rules.less"
    ],
    "assets": [
      "/home/udo/git/NCPV/lib/onyx/images/checkbox.png",
      "/home/udo/git/NCPV/lib/onyx/images/close-active.png",
      "/home/udo/git/NCPV/lib/onyx/images/close-inactive.png",
      "/home/udo/git/NCPV/lib/onyx/images/grabbutton.png",
      "/home/udo/git/NCPV/lib/onyx/images/gradient-invert.png",
      "/home/udo/git/NCPV/lib/onyx/images/gradient.png",
      "/home/udo/git/NCPV/lib/onyx/images/more.png",
      "/home/udo/git/NCPV/lib/onyx/images/progress-button-cancel.png",
      "/home/udo/git/NCPV/lib/onyx/images/search-input-cancel.png",
      "/home/udo/git/NCPV/lib/onyx/images/search-input-search.png",
      "/home/udo/git/NCPV/lib/onyx/images/slider-handle.png",
      "/home/udo/git/NCPV/lib/onyx/images/spinner-dark.gif",
      "/home/udo/git/NCPV/lib/onyx/images/spinner-light.gif"
    ]
  },
  {
    "path": "onyx/Toolbar",
    "base": "/home/udo/git/NCPV/src/views",
    "external": true,
    "relName": "onyx/Toolbar",
    "name": "onyx/Toolbar",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/onyx/src/Toolbar",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/onyx/src/Toolbar/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/onyx/src/Toolbar/package.json": 1542469889215,
      "/home/udo/git/NCPV/lib/onyx/src/Toolbar/Toolbar.js": 1542469889211
    },
    "json": {
      "main": "Toolbar.js",
      "styles": [
        "Toolbar.less"
      ]
    },
    "main": "/home/udo/git/NCPV/lib/onyx/src/Toolbar/Toolbar.js",
    "contents": "require('onyx');\n\n/**\n* Contains the declaration for the {@link module:onyx/Toolbar~Toolbar} kind.\n* @module onyx/Toolbar\n*/\n\nvar\n\tkind = require('enyo/kind'),\n\tplatform = require('enyo/platform'),\n\tControl = require('enyo/Control');\n\n/**\n* {@link module:onyx/Toolbar~Toolbar} is a horizontal bar containing controls used to perform\n* common UI actions.\n*\n* A toolbar customizes the styling of the controls it hosts, including buttons,\n* icons, and inputs.\n*\n* ```\n* var\n* \tButton = require('onyx/Button'),\n* \tIconButton = require('onyx/IconButton'),\n* \tInput = require('onyx/Input'),\n* \tInputDecorator = require('onyx/InputDecorator'),\n* \tToolbar = require('onyx/Toolbar');\n*\n*\t{kind: Toolbar, components: [\n*\t\t{kind: Button, content: 'Favorites'},\n*\t\t{kind: InputDecorator, components: [\n*\t\t\t{kind: Input, placeholder: 'Enter a search term...'}\n*\t\t]},\n*\t\t{kind: IconButton, src: '@../assets/go.png'}\n*\t]}\n* ```\n*\n* @class Toolbar\n* @extends module:enyo/Control~Control\n* @ui\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:onyx/Toolbar~Toolbar.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'onyx.Toolbar',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Control,\n\n\t/**\n\t* @private\n\t*/\n\tclasses: 'onyx onyx-toolbar onyx-toolbar-inline',\n\n\t/**\n\t* @private\n\t*/\n\tcreate: function () {\n\t\tControl.prototype.create.apply(this, arguments);\n\n\t\t//workaround for android 4.0.3 rendering glitch (ENYO-674)\n\t\tif (this.hasClass('onyx-menu-toolbar') && (platform.android >= 4)) {\n\t\t\tthis.applyStyle('position', 'static');\n\t\t}\n\t}\n});\n",
    "nodeModules": false,
    "lib": "/home/udo/git/NCPV/lib/onyx",
    "libName": "onyx",
    "relPath": "onyx/Toolbar",
    "requires": [
      "onyx",
      "enyo/kind",
      "enyo/platform",
      "enyo/Control"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/lib/onyx/src/Toolbar/Toolbar.less"
    ]
  },
  {
    "path": "onyx/Button",
    "base": "/home/udo/git/NCPV/src/views",
    "external": true,
    "relName": "onyx/Button",
    "name": "onyx/Button",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/onyx/src/Button",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/onyx/src/Button/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/onyx/src/Button/package.json": 1542469889007,
      "/home/udo/git/NCPV/lib/onyx/src/Button/Button.js": 1542469889003
    },
    "json": {
      "main": "Button.js",
      "styles": [
        "Button.less"
      ]
    },
    "main": "/home/udo/git/NCPV/lib/onyx/src/Button/Button.js",
    "contents": "require('onyx');\n\n/**\n* Contains the declaration for the {@link module:onyx/Button~Button} kind.\n* @module onyx/Button\n*/\n\nvar\n\tkind = require('enyo/kind'),\n\tButton = require('enyo/Button');\n\n/**\n* {@link module:onyx/Button~Button} is an {@link module:enyo/Button~Button} with Onyx styling applied. The\n* color of the button may be customized by specifying a background color.\n*\n* The `'onyx-affirmative'`, `'onyx-negative'`, and `'onyx-blue'` classes provide\n* some built-in presets.\n*\n* ```javascript\n* \tvar\n* \t\tkind = require('enyo/kind'),\n* \t\tButton = require('onyx/Button');\n*\n* \t{kind: Button, content: 'Button'},\n* \t{kind: Button, content: 'Affirmative', classes: 'onyx-affirmative'},\n* \t{kind: Button, content: 'Negative', classes: 'onyx-negative'},\n* \t{kind: Button, content: 'Blue', classes: 'onyx-blue'},\n* \t{kind: Button, content: 'Custom', style: 'background-color: purple; color: #F1F1F1;'}\n* ```\n* For more information, see the documentation on\n* [Buttons]{@linkplain $dev-guide/building-apps/controls/buttons.html} in the\n* Enyo Developer Guide.\n*\n* @class Button\n* @extends module:enyo/Button~Button\n* @ui\n* @public\n*/\nmodule.exports = kind(\n\t/** @lends module:onyx/Button~Button.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname: 'onyx.Button',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Button,\n\n\t/**\n\t* @private\n\t*/\n\tclasses: 'onyx-button enyo-unselectable',\n\n\t/**\n\t* @private\n\t*/\n\thandlers: {\n\t\tondown: 'down',\n\t\tonenter: 'enter',\n\t\tondragfinish: 'dragfinish',\n\t\tonleave: 'leave',\n\t\tonup: 'up'\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdown: function (sender, event) {\n\t\tif (this.disabled) {\n\t\t\treturn true;\n\t\t}\n\t\tthis.addClass('pressed');\n\t\tthis._isPressed = true;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tenter: function (sender, event) {\n\t\tif (this.disabled) {\n\t\t\treturn true;\n\t\t}\n\t\tif(this._isPressed) {\n\t\t\tthis.addClass('pressed');\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tdragfinish: function (sender, event) {\n\t\tif (this.disabled) {\n\t\t\treturn true;\n\t\t}\n\t\tthis.removeClass('pressed');\n\t\tthis._isPressed = false;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tleave: function (sender, event) {\n\t\tif (this.disabled) {\n\t\t\treturn true;\n\t\t}\n\t\tthis.removeClass('pressed');\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tup: function (sender, event) {\n\t\tif (this.disabled) {\n\t\t\treturn true;\n\t\t}\n\t\tthis.removeClass('pressed');\n\t\tthis._isPressed = false;\n\t}\n});\n",
    "nodeModules": false,
    "lib": "/home/udo/git/NCPV/lib/onyx",
    "libName": "onyx",
    "relPath": "onyx/Button",
    "requires": [
      "onyx",
      "enyo/kind",
      "enyo/Button"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/lib/onyx/src/Button/Button.less"
    ]
  },
  {
    "path": "./FittableLayout",
    "base": "/home/udo/git/NCPV/lib/layout/src",
    "external": true,
    "lib": "/home/udo/git/NCPV/lib/layout",
    "libName": "layout",
    "relName": "layout/FittableLayout",
    "name": "layout/FittableLayout",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV/lib/layout/src/FittableLayout",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/lib/layout/src/FittableLayout/package.json",
    "mtime": {
      "/home/udo/git/NCPV/lib/layout/src/FittableLayout/package.json": 1542469889079,
      "/home/udo/git/NCPV/lib/layout/src/FittableLayout/FittableLayout.js": 1542469889075
    },
    "json": {
      "main": "FittableLayout.js",
      "styles": [
        "FittableLayout.css"
      ]
    },
    "main": "/home/udo/git/NCPV/lib/layout/src/FittableLayout/FittableLayout.js",
    "contents": "/**\n* Contains the declaration for the {@link module:layout/FittableLayout~FittableLayout}, {@link module:layout/FittableLayout~FittableColumnsLayout}\n* and {@link module:layout/FittableLayout~FittableRowsLayout} kinds.\n* @module layout/FittableLayout\n*/\n\nvar\n\tkind = require('enyo/kind'),\n\tdom = require('enyo/dom'),\n\tControl = require('enyo/Control'),\n\tLayout = require('enyo/Layout');\n\nvar detector = document.createElement('div'),\n\tflexAvailable =\n\t\t(detector.style.flexBasis !== undefined) ||\n\t\t(detector.style.webkitFlexBasis !== undefined) ||\n\t\t(detector.style.mozFlexBasis !== undefined) ||\n\t\t(detector.style.msFlexBasis !== undefined);\n\n/**\n* {@link module:layout/FittableLayout~FittableLayout} provides the base\n* positioning and boundary logic for the fittable layout strategy. The fittable\n* layout strategy is based on laying out items in either a set of rows or a set\n* of columns, with most of the items having natural size, but one item expanding\n* to fill the remaining space. The item that expands is labeled with the\n* attribute `fit: true`.\n*\n* The subkinds {@link module:layout/FittableLayout~FittableColumnsLayout} and\n* {@link module:layout/FittableLayout~FittableRowsLayout} (or _their_ subkinds)\n* are used for layout rather than `FittableLayout` because they specify\n* properties that the framework expects to be available when laying items out.\n*\n* When available on the platform, you can opt-in to have `FittableLayout` use\n* CSS flexible box (flexbox) to implement fitting behavior on the platform for\n* better performance; Enyo will fall back to JavaScript-based layout on older\n* platforms. Three subtle differences between the flexbox and JavaScript\n* implementations should be noted:\n\n* - When using flexbox, vertical margins (i.e., `margin-top`, `margin-bottom`) will\n* not collapse; when using JavaScript layout, vertical margins will collapse according\n* to static layout rules.\n*\n* - When using flexbox, non-fitting children of the Fittable must not be sized\n* using percentages of the container (even if set to `position: relative`);\n* this is explicitly not supported by the flexbox 2013 spec.\n*\n* - The flexbox-based Fittable implementation will respect multiple children\n* with `fit: true` (the fitting space will be divided equally between them).\n* This is NOT supported by the JavaScript implementation, and you should not rely\n* upon this behavior if you are deploying to platforms without flexbox support.\n*\n* The flexbox implementation was added to Enyo 2.5.0 as an optional performance\n* optimization; to use the optimization, set `useFlex: true` on the Fittable\n* container.  This will cause flexbox to be used when possible.\n*\n* @class FittableLayout\n* @extends module:enyo/Layout~Layout\n* @public\n*/\nvar FittableLayout = module.exports = kind(/** @lends module:layout/FittableLayout~FittableLayout.prototype */{\n\tname: 'enyo.FittableLayout',\n\n\t/**\n\t* @private\n\t*/\n\tkind: Layout,\n\n\t/**\n\t* @private\n\t*/\n\tnoDefer: true,\n\n\t/**\n\t* @method\n\t* @private\n\t*/\n\tconstructor: function () {\n\t\tLayout.prototype._constructor.apply(this, arguments);\n\n\t\t// Add the force-ltr class if we're in RTL mode, but this control is set explicitly to NOT be in RTL mode.\n\t\tthis.container.addRemoveClass('force-left-to-right', (Control.prototype.rtl && !this.container.get('rtl')) );\n\n\t\t// Flexbox optimization is determined by global flexAvailable and per-instance opt-in useFlex flag\n\t\tthis.useFlex = flexAvailable && (this.container.useFlex === true);\n\t\tif (this.useFlex) {\n\t\t\tthis.container.addClass(this.flexLayoutClass);\n\t\t} else {\n\t\t\tthis.container.addClass(this.fitLayoutClass);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tcalcFitIndex: function () {\n\t\tvar aChildren = this.container.children,\n\t\t\toChild,\n\t\t\tn;\n\n\t\tfor (n=0; n<aChildren.length; n++) {\n\t\t\toChild = aChildren[n];\n\t\t\tif (oChild.fit && oChild.showing) {\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetFitControl: function () {\n\t\tvar aChildren = this.container.children,\n\t\t\toFitChild = aChildren[this.fitIndex];\n\n\t\tif (!(oFitChild && oFitChild.fit && oFitChild.showing)) {\n\t\t\tthis.fitIndex = this.calcFitIndex();\n\t\t\toFitChild = aChildren[this.fitIndex];\n\t\t}\n\t\treturn oFitChild;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tshouldReverse: function () {\n\t\treturn this.container.rtl && this.orient === 'h';\n\t},\n\t\n\t/**\n\t* @private\n\t*/\n\tdestroy: function () {\n\t\tLayout.prototype.destroy.apply(this, arguments);\n\t\t\n\t\tif (this.container) {\n\t\t\tthis.container.removeClass(this.useFlex ? this.flexLayoutClass : this.fitLayoutClass);\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetFirstChild: function() {\n\t\tvar aChildren = this.getShowingChildren();\n\n\t\tif (this.shouldReverse()) {\n\t\t\treturn aChildren[aChildren.length - 1];\n\t\t} else {\n\t\t\treturn aChildren[0];\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetLastChild: function() {\n\t\tvar aChildren = this.getShowingChildren();\n\n\t\tif (this.shouldReverse()) {\n\t\t\treturn aChildren[0];\n\t\t} else {\n\t\t\treturn aChildren[aChildren.length - 1];\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t*/\n\tgetShowingChildren: function() {\n\t\tvar a = [],\n\t\t\tn = 0,\n\t\t\taChildren = this.container.children,\n\t\t\tnLength   = aChildren.length;\n\n\t\tfor (;n<nLength; n++) {\n\t\t\tif (aChildren[n].showing) {\n\t\t\t\ta.push(aChildren[n]);\n\t\t\t}\n\t\t}\n\n\t\treturn a;\n\t},\n\n\t/**\n\t* @private\n\t*/\n\t_reflow: function(sMeasureName, sClienMeasure, sAttrBefore, sAttrAfter) {\n\t\tthis.container.addRemoveClass('enyo-stretch', !this.container.noStretch);\n\t\t\n\t\tvar oFitChild       = this.getFitControl(),\n\t\t\toContainerNode  = this.container.hasNode(),  // Container node\n\t\t\tnTotalSize     = 0,                          // Total container width or height without padding\n\t\t\tnBeforeOffset   = 0,                         // Offset before fit child\n\t\t\tnAfterOffset    = 0,                         // Offset after fit child\n\t\t\toPadding,                                    // Object containing t,b,r,l paddings\n\t\t\toBounds,                                     // Bounds object of fit control\n\t\t\toLastChild,\n\t\t\toFirstChild,\n\t\t\tnFitSize;\n\n\t\tif (!oFitChild || !oContainerNode) { return true; }\n\n\t\toPadding   = dom.calcPaddingExtents(oContainerNode);\n\t\toBounds    = oFitChild.getBounds();\n\t\tnTotalSize = oContainerNode[sClienMeasure] - (oPadding[sAttrBefore] + oPadding[sAttrAfter]);\n\n\t\t// If total size is zero, there's nothing for us to do (and the Control\n\t\t// we're doing layout for is probably hidden). In this case, we\n\t\t// short-circuit and return `true` to signify that we want to reflow\n\t\t// again the next time the Control is shown.\n\t\tif (nTotalSize === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.shouldReverse()) {\n\t\t\toFirstChild  = this.getFirstChild();\n\t\t\tnAfterOffset = nTotalSize - (oBounds[sAttrBefore] + oBounds[sMeasureName]);\n\n\t\t\tvar nMarginBeforeFirstChild = dom.getComputedBoxValue(oFirstChild.hasNode(), 'margin', sAttrBefore) || 0;\n\n\t\t\tif (oFirstChild == oFitChild) {\n\t\t\t\tnBeforeOffset = nMarginBeforeFirstChild;\n\t\t\t} else {\n\t\t\t\tvar oFirstChildBounds      = oFirstChild.getBounds(),\n\t\t\t\t\tnSpaceBeforeFirstChild = oFirstChildBounds[sAttrBefore] - (oPadding[sAttrBefore] || 0);\n\n\t\t\t\tnBeforeOffset = oBounds[sAttrBefore] + nMarginBeforeFirstChild - nSpaceBeforeFirstChild;\n\t\t\t}\n\t\t} else {\n\t\t\toLastChild    = this.getLastChild();\n\t\t\tnBeforeOffset = oBounds[sAttrBefore] - (oPadding[sAttrBefore] || 0);\n\n\t\t\tvar nMarginAfterLastChild = dom.getComputedBoxValue(oLastChild.hasNode(), 'margin', sAttrAfter) || 0;\n\n\t\t\tif (oLastChild == oFitChild) {\n\t\t\t\tnAfterOffset = nMarginAfterLastChild;\n\t\t\t} else {\n\t\t\t\tvar oLastChildBounds = oLastChild.getBounds(),\n\t\t\t\t\tnFitChildEnd     = oBounds[sAttrBefore] + oBounds[sMeasureName],\n\t\t\t\t\tnLastChildEnd    = oLastChildBounds[sAttrBefore] + oLastChildBounds[sMeasureName] +  nMarginAfterLastChild;\n\n\t\t\t\tnAfterOffset = nLastChildEnd - nFitChildEnd;\n\t\t\t}\n\t\t}\n\n\t\tnFitSize = nTotalSize - (nBeforeOffset + nAfterOffset);\n\t\toFitChild.applyStyle(sMeasureName, nFitSize + 'px');\n\t},\n\n\t/**\n\t* Assigns any static layout properties not dependent on changes to the\n\t* rendered component or container sizes, etc.\n\t* \n\t* @public\n\t*/\n\tflow: function() {\n\t\tif (this.useFlex) {\n\t\t\tvar i,\n\t\t\t\tchildren = this.container.children,\n\t\t\t\tchild;\n\t\t\tthis.container.addClass(this.flexLayoutClass);\n\t\t\tthis.container.addRemoveClass('nostretch', this.container.noStretch);\n\t\t\tfor (i=0; i<children.length; i++) {\n\t\t\t\tchild = children[i];\n\t\t\t\tchild.addClass('enyo-flex-item');\n\t\t\t\tchild.addRemoveClass('flex', child.fit);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* Updates the layout to reflect any changes made to the layout container or\n\t* the contained components.\n\t*\n\t* @public\n\t*/\n\treflow: function() {\n\t\tif (!this.useFlex) {\n\t\t\tif (this.orient == 'h') {\n\t\t\t\treturn this._reflow('width', 'clientWidth', 'left', 'right');\n\t\t\t} else {\n\t\t\t\treturn this._reflow('height', 'clientHeight', 'top', 'bottom');\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t* @private\n\t* @lends module:layout/FittableLayout~FittableLayout.prototype\n\t*/\n\tstatics: {\n\t\t/**\n\t\t* Indicates whether flexbox optimization can be used.\n\t\t*\n\t\t* @type {Boolean}\n\t\t* @default  false\n\t\t* @private\n\t\t*/\n\t\tflexAvailable: flexAvailable\n\t}\n});\n\n/**\n* {@link module:layout/FittableLayout~FittableColumnsLayout} provides a\n* container in which items are laid out in a set of vertical columns, with most\n* of the items having natural size, but one expanding to fill the remaining\n* space. The one that expands is labeled with the attribute `fit: true`.\n*\n* `FittableColumnsLayout` is meant to be used as a value for the `layoutKind`\n* property of other kinds. `layoutKind` provides a way to add layout behavior in\n* a pluggable fashion while retaining the ability to use a specific base kind.\n*\n* For more information, see the documentation on\n* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the\n* Enyo Developer Guide.\n*\n* @class FittableColumnsLayout\n* @extends module:layout/FittableLayout~FittableLayout\n* @public\n*/\n\n/**\n* The declaration for {@link module:layout/FittableLayout~FittableColumnsLayout}\n*/\nmodule.exports.Columns = kind(/** @lends module:layout/FittableLayout~FittableColumnsLayout.prototype */{\n\tname        : 'enyo.FittableColumnsLayout',\n\tkind        : FittableLayout,\n\torient      : 'h',\n\tfitLayoutClass : 'enyo-fittable-columns-layout',\n\tflexLayoutClass: 'enyo-flex-container columns'\n});\n\n\n/**\n* {@link module:layout/FittableLayout~FittableRowsLayout} provides a container\n* in which items are laid out in a set of horizontal rows, with most of the\n* items having natural size, but one expanding to fill the remaining space. The\n* one that expands is labeled with the attribute `fit: true`.\n*\n* `FittableRowsLayout` is meant to be used as a value for the `layoutKind`\n* property of other kinds. `layoutKind` provides a way to add layout behavior in\n* a pluggable fashion while retaining the ability to use a specific base kind.\n*\n* For more information, see the documentation on\n* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the\n* Enyo Developer Guide.\n*\n* @class FittableRowsLayout\n* @extends module:layout/FittableLayout~FittableLayout\n* @public\n*/\n\n/**\n* The declaration for {@link module:layout/FittableLayout~FittableRowsLayout}\n*/\nmodule.exports.Rows = kind(\n\t/** @lends module:layout/FittableLayout~FittableRowsLayout.prototype */ {\n\n\t/**\n\t* @private\n\t*/\n\tname        : 'enyo.FittableRowsLayout',\n\n\t/**\n\t* @private\n\t*/\n\tkind        : FittableLayout,\n\n\t/**\n\t* Layout CSS class used to fit rows.\n\t*\n\t* @type {String}\n\t* @default 'enyo-fittable-rows-layout'\n\t* @public\n\t*/\n\tfitLayoutClass : 'enyo-fittable-rows-layout',\n\n\t/**\n\t* The orientation of the layout.\n\t*\n\t* @type {String}\n\t* @default 'v'\n\t* @public\n\t*/\n\torient      : 'v',\n\n\t/**\n\t* @private\n\t*/\n\tflexLayoutClass: 'enyo-flex-container rows'\n});\n",
    "nodeModules": false,
    "relPath": "layout/FittableLayout",
    "requires": [
      "enyo/kind",
      "enyo/dom",
      "enyo/Control",
      "enyo/Layout"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/lib/layout/src/FittableLayout/FittableLayout.css"
    ]
  },
  {
    "path": "layout/FittableRows",
    "base": "/home/udo/git/NCPV/src/views",
    "external": true,
    "relName": "layout/FittableRows",
    "name": "layout/FittableRows",
    "isFile": true,
    "contents": "/**\n* Contains the declaration for the {@link module:layout/FittableRows~FittableRows} kind.\n* @module layout/FittableRows\n*/\n\nvar\n\tkind = require('enyo/kind')\t;\n\nvar\n\tFittableLayout = require('./FittableLayout'),\n\tFittableRowsLayout = FittableLayout.Rows;\n\n/**\n* {@link module:layout/FittableRows~FittableRows} provides a container in which items are laid out in a\n* set\tof horizontal rows, with most of the items having natural size, but one\n* expanding to fill the remaining space. The one that expands is labeled with\n* the attribute `fit: true`.\n*\n* For more information, see the documentation on\n* [Fittables]{@linkplain $dev-guide/building-apps/layout/fittables.html} in the\n* Enyo Developer Guide.\n*\n* @class FittableRows\n* @extends module:enyo/Control~Control\n* @ui\n* @public\n*/\nmodule.exports = kind(/** @lends module:layout/FittableRows~FittableRows.prototype */{\n\n\t/**\n\t* @private\n\t*/\n\tname: 'enyo.FittableRows',\n\n\t/**\n\t* A {@glossary kind} used to manage the size and placement of child\n\t* [components]{@link module:enyo/Component~Component}.\n\t*\n\t* @type {String}\n\t* @default ''\n\t* @private\n\t*/\n\tlayoutKind: FittableRowsLayout,\n\n\t/**\n\t* By default, items in columns stretch to fit horizontally; set to `true` to\n\t* avoid this behavior.\n\t*\n\t* @type {Boolean}\n\t* @default false\n\t* @public\n\t*/\n\tnoStretch: false\n});\n",
    "mtime": 1542469889079,
    "fullpath": "/home/udo/git/NCPV/lib/layout/src/FittableRows.js",
    "lib": "/home/udo/git/NCPV/lib/layout",
    "libName": "layout",
    "relPath": "layout/FittableRows",
    "requires": [
      "enyo/kind",
      "./FittableLayout"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./views/MainView",
    "base": "/home/udo/git/NCPV/src",
    "relName": "src/views/MainView",
    "name": "/home/udo/git/NCPV/src/views/MainView",
    "isFile": true,
    "contents": "/**\n\tFor simple applications, you might define all of your views in this file.\n\tFor more complex applications, you might choose to separate these kind definitions\n\tinto multiple files under this folder and require() as needed.\n*/\n\nvar\n\tkind = require('enyo/kind'),\n\tFittableRows = require('layout/FittableRows'),\n\tToolbar = require('onyx/Toolbar'),\n\tScroller = require('enyo/Scroller'),\n\tButton = require('onyx/Button');\n\nmodule.exports = kind({\n\tkind: FittableRows,\n\tfit: true,\n\tcomponents:[\n\t\t{kind: Toolbar, content: 'Hello World'},\n\t\t{kind: Scroller, fit: true, components: [\n\t\t\t{name: 'main', allowHtml: true}\n\t\t]},\n\t\t{kind: Toolbar, components: [\n\t\t\t{kind: Button, content: 'Tap me', ontap: 'helloWorldTap'}\n\t\t]}\n\t],\n\thelloWorldTap: function(inSender, inEvent) {\n\t\tthis.$.main.addContent('The button was tapped.<br/>');\n\t}\n});\n",
    "mtime": 1542469879983,
    "fullpath": "/home/udo/git/NCPV/src/views/MainView.js",
    "relPath": "src/views/MainView.js",
    "requires": [
      "enyo/kind",
      "layout/FittableRows",
      "onyx/Toolbar",
      "enyo/Scroller",
      "onyx/Button"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "./src/App",
    "base": "/home/udo/git/NCPV",
    "relName": "src/App",
    "name": "/home/udo/git/NCPV/src/App",
    "isFile": true,
    "contents": "/**\n\tDefine your enyo/Application kind in this file.\n*/\n\nvar\n\tkind = require('enyo/kind'),\n\tApplication = require('enyo/Application'),\n\tMainView = require('./views/MainView');\n\nmodule.exports = kind({\n\tkind: Application,\n\tview: MainView\n});\n",
    "mtime": 1542469879975,
    "fullpath": "/home/udo/git/NCPV/src/App.js",
    "relPath": "src/App.js",
    "requires": [
      "enyo/kind",
      "enyo/Application",
      "./views/MainView"
    ],
    "requests": [],
    "resolved": true
  },
  {
    "path": "/home/udo/git/NCPV",
    "entry": true,
    "relName": "index",
    "name": "/home/udo/git/NCPV",
    "isDirectory": true,
    "fullpath": "/home/udo/git/NCPV",
    "isPackage": true,
    "packageFile": "/home/udo/git/NCPV/package.json",
    "mtime": {
      "/home/udo/git/NCPV/package.json": 1542469879987,
      "/home/udo/git/NCPV/index.js": 1542469879967,
      "/home/udo/git/NCPV/favicon.ico": 1542469879967
    },
    "json": {
      "name": "NCPV",
      "version": "0.0.1",
      "description": "An Enyo-based template to build web applications using HTML, CSS and JavaScript.",
      "main": "index.js",
      "moduleDir": "src",
      "assets": [
        "favicon.ico",
        "assets/**/*.*"
      ],
      "styles": [
        "css/*.less",
        "css/*.css"
      ]
    },
    "main": "/home/udo/git/NCPV/index.js",
    "contents": "/**\n\tInstantiate your enyo/Application kind in this file.  Note, application\n\trendering should be deferred until the DOM is ready by wrapping it in a\n\tcall to ready().\n*/\n\nvar\n\tready = require('enyo/ready'),\n\tApp = require('./src/App');\n\nready(function () {\n\tnew App();\n});\n",
    "nodeModules": false,
    "relPath": "/home/udo/git/NCPV",
    "requires": [
      "enyo/ready",
      "./src/App"
    ],
    "requests": [],
    "resolved": true,
    "styles": [
      "/home/udo/git/NCPV/css/main.less"
    ],
    "assets": [
      "/home/udo/git/NCPV/favicon.ico"
    ]
  }
]